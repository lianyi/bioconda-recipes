diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/Makefile.in ncbi-blast-2.7.1+-src-working/c++/src/app/Makefile.in
--- ncbi-blast-2.7.1+-src/c++/src/app/Makefile.in	2017-04-05 14:39:44.000000000 -0400
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/Makefile.in	2018-03-13 14:39:58.586660000 -0400
@@ -3,19 +3,7 @@
 # Miscellaneous applications
 #################################
 
-SUB_PROJ = asn2asn asn2fasta asn2flat asnval asn_cleanup \
-           id1_fetch blast convert_seq \
-           nmer_repeats objmgr gi2taxid netschedule grid netstorage igblast \
-           winmasker dustmasker segmasker blastdb vecscreen \
-           agpconvert id2_fetch agp_validate objextract \
-           bdb_env_keeper nw_aligner speedtest idmapper formatguess \
-           multireader read_blast_result splign hfilter \
-           annotwriter compart streamtest lds2_indexer \
-           discrepancy_report biosample_chk gap_stats table2asn \
-           srcchk tableval ncbi_encrypt ssub_fork asn_cache magicblast \
-           pub_report prot_match gff_deconcat sub_fuse
-
-EXPENDABLE_SUB_PROJ = split_cache wig2table netcache rmblastn dblb tls idfetch
+SUB_PROJ = rpsbproc sparclelabel
 
 REQUIRES = app
 
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/Makefile.in ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/Makefile.in
--- ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/Makefile.in	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/Makefile.in	2018-03-05 15:50:35.912575000 -0500
@@ -0,0 +1,7 @@
+# $Id: RpsbProc Makefile.in shlu $
+
+APP_PROJ = rpsbproc
+
+srcdir = @srcdir@
+include @builddir@/Makefile.meta
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/Makefile.rpsbproc.app ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/Makefile.rpsbproc.app
--- ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/Makefile.rpsbproc.app	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/Makefile.rpsbproc.app	2018-03-05 15:50:35.933413000 -0500
@@ -0,0 +1,11 @@
+#$Id: Makefile.rpsbproc.app Shennan Lu $
+
+APP = rpsbproc
+SRC = rpsbproc
+
+CPPFLAGS = -I. \
+	$(ORIG_CPPFLAGS)
+
+LIB = blastxml xser xutil xncbi
+
+LIBS = $(DL_LIBS) $(ORIG_LIBS)
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/README.md ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/README.md
--- ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/README.md	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/README.md	2018-03-05 20:13:12.768646657 -0500
@@ -0,0 +1,3 @@
+# Source of SPARCLE binary 
+
+Sync from ftp://ftp.ncbi.nih.gov/pub/mmdb/cdd/rpsbproc/rpsbproc-src/
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/rpsbproc.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/rpsbproc.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/rpsbproc.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/rpsbproc.cpp	2018-03-05 15:50:35.980856000 -0500
@@ -0,0 +1,5388 @@
+/*$Id$
+*  =========================================================================
+*
+*                            PUBLIC DOMAIN NOTICE
+*               National Center for Biotechnology Information
+*
+*  This software/database is a "United States Government Work" under the
+*  terms of the United States Copyright Act.  It was written as part of
+*  the author's official duties as a United States Government employee and
+*  thus cannot be copyrighted.  This software/database is freely available
+*  to the public for use. The National Library of Medicine and the U.S.
+*  Government have not placed any restriction on its use or reproduction.
+*
+*  Although all reasonable efforts have been taken to ensure the accuracy
+*  and reliability of the software and data, the NLM and the U.S.
+*  Government do not and cannot warrant the performance or results that
+*  may be obtained by using this software or data. The NLM and the U.S.
+*  Government disclaim all warranties, express or implied, including
+*  warranties of performance, merchantability or fitness for any particular
+*  purpose.
+*
+*  Please cite the author in any work or product based on this material.
+*  ===========================================================================
+* 
+*  Authors:  Shennan Lu
+*
+*  =======================================================================*/
+
+#include <ncbi_pch.hpp>
+#if defined(__BLAST_XML2__)
+#include <objects/blastxml2/blastxml2__.hpp>
+#else
+#include <objects/blastxml/blastxml__.hpp>
+#endif
+#include <objects/seqloc/Na_strand.hpp>
+#include <serial/objostrxml.hpp>
+#include <serial/objistr.hpp>
+#include <serial/serial.hpp>
+#include <corelib/ncbireg.hpp>
+#include <algorithm>
+#include <vector>
+#include <string>
+#include <list>
+#include <stack>
+#include <map>
+#include <cstdio>
+#include <cstdlib>
+#include <iostream>
+#include <fstream>
+#include <cstring>
+
+USING_NCBI_SCOPE;
+using namespace objects;
+
+/**********************************************************************
+*	Constants defined here
+***********************************************************************/
+
+const string k_strEmptyString("");
+	
+const char * const DATAPATH = "datapath";
+const char * const CDDIDS = "cdd";
+const char * const CDTRACKINFO = "cdt";
+const char * const CLUSTERLINKS = "clst";
+const char * const FEATURES = "feats";
+const char * const GENERIC_FEATURES = "genfeats";
+const char * const SPECIFICTHRESHOLDS = "spthr";
+
+const int COORDSBASE = 1;
+
+const char DELIMIT = '\t';
+const char COORDELIMIT = ',';
+
+const char * const HITTYPE_SPECIFIC = "Specific";
+const char * const HITTYPE_NONSPECIFIC = "Non-specific";
+const char * const HITTYPE_CLUSTER = "Superfamily";
+const char * const HITTYPE_MULTIDOM = "Multidom";
+const char * const ANNOTTYPE_SPECIFIC = "Specific";
+const char * const ANNOTTYPE_GENERIC = "Generic";
+const char * const QUERY_TYPE_PEPTIDE = "Peptide";
+const char * const QUERY_TYPE_NUCLEOTIDE = "Nucleotide";
+
+const char * const PROGRAM_TITLE = "Post-RPSBLAST Processing Utility v0.11";
+
+const char * const DATASTART = "DATA";
+const char * const DATAEND = "ENDDATA";
+
+const char * const SESSIONSTART = "SESSION";
+const char * const SESSIONEND = "ENDSESSION";
+
+const char * const QUERYSTART = "QUERY";
+const char * const QUERYEND = "ENDQUERY";
+
+const char * const DOMSTART = "DOMAINS";
+const char * const DOMEND = "ENDDOMAINS";
+
+const char * const FAMSTART = "SUPERFAMILIES";
+const char * const FAMEND = "ENDSUPERFAMILIES";
+
+const char * const FEATSTART = "SITES";
+const char * const FEATEND = "ENDSITES";
+
+const char * const MOTIFSTART = "MOTIFS";
+const char * const MOTIFEND = "ENDMOTIFS";
+
+const char * const CONFIGFILE = "rpsbproc.ini";
+// -- standard file names
+const char * const CDIDFILE = "cddid.tbl";
+const char * const CDTRACKFILE = "cdtrack.txt";
+const char * const CLSTLINKFILE = "family_superfamily_links.txt";
+const char * const SPFEATFILE = "cddannot.dat";
+const char * const GENFEATFILE = "cddannot_generic.dat";
+const char * const MINBSCOREFILE = "bitscore_specific.txt";
+
+const int OVERLAPLEADING = 500000;
+/**********************************************************************
+*	Commandline switches defined here
+***********************************************************************/
+struct TCMLSwitches
+{
+	// -- called to actually process the switch
+	// -- first parameter will be the index of the switch. Program should
+	// -- give an enum type to name indice of all switches for better sense.
+	// -- if invalid (ie undefined) switches are found, first argument will be
+	// -- m_iTotalSwitches. If a parameter is not a switch, the first argument
+	// -- will be -1.
+	typedef void lpfnSwitchProcessor(int, const char * );
+	struct TCMLSwitch
+	{
+		char m_cToken;	//the switch token
+		bool m_bUseParam;	//have a parameter
+		
+		TCMLSwitch(char tkn, bool useparam):
+			m_cToken(tkn), m_bUseParam(useparam)
+		{};
+	};
+	
+	static const int NONSWITCH = -1;
+	
+	const TCMLSwitch *m_dimSWITCHES;
+	int m_iTotalSwitches;
+	const char * m_dimSwitchChar;	//char that identifies a switch, such as / or -. Must terminate with '\0'
+	TCMLSwitches(const TCMLSwitch *pSwDefs, int ttl, const char * sc = "-"): m_dimSWITCHES(pSwDefs), m_iTotalSwitches(ttl), m_dimSwitchChar(sc) {};
+	bool IsSwitchChar(char c) const;
+	// -- return index of the switch. If not found, return m_iTotalSwitches
+	// -- as an indication of invalid switch. bUseParam set to false.
+	int FindSwitch (char cToken, bool &bUseParam) const;
+	void IterParameters(int argc, char * argv[], lpfnSwitchProcessor proc) const;
+		
+	
+};
+
+
+bool TCMLSwitches::IsSwitchChar(char c) const
+{
+	for (const char *p = m_dimSwitchChar; 0 != *p; ++p)
+		if (*p == c) return true;
+	return false;
+}
+
+// -- return index of the switch. If not found, return m_iTotalSwitches
+// -- as an indication of invalid switch. bUseParam set to false.
+int TCMLSwitches::FindSwitch (char cToken, bool &bUseParam) const
+{
+	for (int i = 0; i < m_iTotalSwitches; ++i)
+	{
+		if (m_dimSWITCHES[i].m_cToken == cToken)
+		{
+			bUseParam = m_dimSWITCHES[i].m_bUseParam;
+			return i;
+		}
+	}
+	
+	bUseParam = false;
+	return m_iTotalSwitches;	//invalid switch
+}
+
+void TCMLSwitches::IterParameters(int argc, char * argv[], lpfnSwitchProcessor proc) const
+{
+	int cmdStatus = NONSWITCH;
+	bool bReqParam = false;
+	
+	for (int i = 1; i < argc; ++i)
+	{
+		size_t argCharCnt = strlen(argv[i]);
+		size_t argCharIdx = 0;
+		
+		if (argCharIdx < argCharCnt)	//has content
+		{
+			if (IsSwitchChar(argv[i][0]))	//is switch
+			{
+				++argCharIdx;
+				if (argCharIdx < argCharCnt)
+				{
+					// -- new switch, end of last switch no matter what
+					if (NONSWITCH != cmdStatus)
+					{
+						proc(cmdStatus, NULL);
+						cmdStatus = NONSWITCH;
+					}
+					// -- find it
+					cmdStatus = FindSwitch(argv[i][argCharIdx], bReqParam);
+
+					
+					if (bReqParam)
+					{
+						++argCharIdx;
+						if (argCharIdx < argCharCnt)	//has immediately followed parameter
+						{
+							proc(cmdStatus, argv[i] + argCharIdx);
+							cmdStatus = NONSWITCH;
+						}
+						else	//wait for next parameter as 
+							continue;
+					}
+					else	//no parameter, check any other
+					{
+						// call
+						if (cmdStatus == m_iTotalSwitches)	//invalid
+							proc(cmdStatus, argv[i] + argCharIdx);
+						else
+							proc(cmdStatus, NULL);
+						cmdStatus = NONSWITCH;
+						++argCharIdx;
+						while (argCharIdx < argCharCnt)
+						{
+							cmdStatus = FindSwitch(argv[i][argCharIdx], bReqParam);
+							if (bReqParam)	//requires parameter, the rest of string to be parameter
+							{
+								++argCharIdx;
+								if (argCharIdx < argCharCnt)
+								{
+									proc(cmdStatus, argv[i] + argCharIdx);
+									cmdStatus = NONSWITCH;
+								}
+								else	//wait for next commandline
+									break;
+							}
+							else	//no parameters needed
+							{
+								if (cmdStatus == m_iTotalSwitches)	//invalid
+									proc(cmdStatus, argv[i] + argCharIdx);
+								else
+									proc(cmdStatus, NULL);
+								cmdStatus = NONSWITCH;
+								++argCharIdx;
+							}
+						}
+					}
+				}
+				else	//no switch, just a '-' or '/', treat as non-switch
+				{
+					proc(cmdStatus, argv[i]);
+					cmdStatus = NONSWITCH;
+				}
+			}
+			else	//not a switch
+			{
+				proc(cmdStatus, argv[i]);	//call as a parameter for last switch (need a parameter)
+				cmdStatus = NONSWITCH;
+			}
+		}
+	}
+}
+
+
+/**********************************************************************
+*	Commandline switches - numeric code
+***********************************************************************/
+struct TRpsbProcCmds: public TCMLSwitches
+{
+	enum EIndex
+	{
+		eCfgFile = 0,
+		eInFile = eCfgFile + 1,	//source data stream (blast results in xml format), default to stdin
+		eOutFile = eInFile + 1,	//destination (data output), default to stdout
+		eEVCutoff = eOutFile + 1,	//filter with evalue
+		eMode = eEVCutoff + 1,	//concise (default), standard and full
+		eTData = eMode + 1,
+		eData = eTData + 1,	//path to data files
+		eFams = eData + 1,
+		eQuiet = eFams + 1,	//added as user request, append all domains superfamily information.
+		eHelp = eQuiet + 1,	//help
+		eInvalid = eHelp + 1
+	};
+	
+	static TCMLSwitch m_dimRpsbProcSwitches[eInvalid];
+	
+	TRpsbProcCmds(void): TCMLSwitches(m_dimRpsbProcSwitches, eInvalid) {};
+	
+};
+
+TCMLSwitches::TCMLSwitch TRpsbProcCmds::m_dimRpsbProcSwitches[] = 
+{
+	TCMLSwitch('c', true),
+	TCMLSwitch('i', true),
+	TCMLSwitch('o', true),
+	TCMLSwitch('e', true),
+	TCMLSwitch('m', true),
+	TCMLSwitch('t', true),
+	TCMLSwitch('d', true),	//datapath, requested by user siewyit@ebi.ac.uk 
+	TCMLSwitch('f', true),	//family
+	TCMLSwitch('q', false),
+	TCMLSwitch('h', false)
+};
+
+/**********************************************************************
+*	Enum-Lit Type processor
+***********************************************************************/
+template<class EnumLitType>
+int GetIdx(const string& strLit)
+{
+	for (int i = EnumLitType::eEnumStart; i < EnumLitType::eEnumEnd; ++i)
+	{
+		if (strLit == EnumLitType::dimLits[i - EnumLitType::eEnumStart]) return i;
+	}
+	
+	return EnumLitType::eDefault;
+}
+
+/**********************************************************************
+*	Result redundent level
+***********************************************************************/
+struct TDataModes
+{
+	enum EIndex
+	{
+		eEnumStart = 0,
+		e_rep = eEnumStart,
+		e_std = e_rep + 1,
+		e_full = e_std + 1,
+		eEnumEnd = e_full + 1
+	};
+	
+	static const EIndex eDefault = e_rep;
+	static const char* dimLits[eEnumEnd - eEnumStart];
+	static const char* dimDisplay[eEnumEnd - eEnumStart];
+};
+
+const char * TDataModes::dimLits[] = {"rep", "std", "full"};
+const char * TDataModes::dimDisplay[] = {"Concise", "Standard", "Full"};
+	
+/**********************************************************************
+*	Target data
+***********************************************************************/
+struct TTargetData
+{
+	enum EIndex
+	{
+		eEnumStart = 0,
+		e_doms = eEnumStart,
+		e_feats = e_doms + 1,
+		e_both = e_feats + 1,
+		eEnumEnd = e_both + 1
+	};
+	
+	static const EIndex eDefault = e_both;
+	static const char* dimLits[eEnumEnd - eEnumStart];
+	static const char* dimDisplay[eEnumEnd - eEnumStart];
+};
+
+const char * TTargetData::dimLits[] = {"doms", "feats", "both"};
+const char * TTargetData::dimDisplay[] = {"Domain hits", "Site annotations", "Domain hits and site annotations"};
+
+
+/**********************************************************************
+*	Helper classes -- sequence Segment
+***********************************************************************/
+enum EResidueExtension
+{
+	eFullLeft = -2,
+	eHalfLeft = -1,
+	eAccurate = 0,
+	eHalfRight = 1,
+	eFullRight = 2,
+	eUseDefaultExt = 255
+	
+};
+
+
+
+struct TSeg
+{
+	int from;
+	int to;
+	
+	EResidueExtension lext;
+	EResidueExtension rext;
+	
+	// -- give up tracking conversion, just keep the original in the segment.
+	int ori_from;
+	
+	bool operator == (const TSeg& other) const;
+	
+	TSeg(int f = 0, int t = 0, EResidueExtension le = eAccurate, EResidueExtension re = eAccurate): from(f), to(t), lext(le), rext(re), ori_from(f) {};
+	bool IsValid(void) const;
+	
+	bool LeftTo(const TSeg& rSrcSeg) const {return (to < rSrcSeg.from - 1);} 
+	bool RightTo(const TSeg& rSrcSeg) const {return (from > rSrcSeg.to + 1);}
+	bool LeftTouch(const TSeg& rSrcSeg) const {return (to == rSrcSeg.from - 1);}
+	bool RightTouch(const TSeg& rSrcSeg) const {return (from == rSrcSeg.to + 1);}
+	bool MoreLeft(const TSeg& rSrcSeg) const {return (from < rSrcSeg.from);}
+	bool MoreRight(const TSeg& rSrcSeg) const {return (to > rSrcSeg.to);}
+	bool Overlap(const TSeg& rSrcSeg) const {return ((from >= rSrcSeg.from && from <= rSrcSeg.to) || (rSrcSeg.from >= from && rSrcSeg.from <= to));}
+	bool Touch(const TSeg& rSrcSeg) const {return (LeftTouch(rSrcSeg) || RightTouch(rSrcSeg));}
+	
+	
+	//void SaveToCache(CDataCache &dc) const;
+	//void RestoreFromCache(CDataCache &dc);
+
+};
+
+// -- sort from left most to right
+struct TSegSortLeft
+{
+	bool operator () (const TSeg* s1, const TSeg* s2);
+};
+
+
+// -- sort from long to short segs, so short segs will be drawn later than long segs
+
+struct TSegSortLength
+{
+	bool operator () (const TSeg* s1, const TSeg* s2);
+};
+
+
+
+typedef list<TSeg> TSegs;
+
+class CSegSet
+{
+	friend struct TOflAlignInfo;
+public:
+	struct TResiduePos
+	{
+		int curr, ori;
+		TResiduePos(int c = 0, int o = 0): curr(c), ori(o) {};
+	};
+	
+	CSegSet(void): m_iFactor(1), m_lstContainer(), m_ulGapThreshold(-1) {};
+	CSegSet(const vector<int> &residues);
+	CSegSet(const vector<int>& starts, const vector<unsigned int>& lens);	//always set ofs to zero! so must use slave coordinates.
+	virtual ~CSegSet(void) {};
+	
+	void SetData(const vector<int>& starts, const vector<unsigned int>& lens);	//always set ofs to zero! so must use slave coordinates.
+	void SetData(const vector<int> &residues);
+
+	bool operator == (const CSegSet& other) const;
+	
+	// -- status
+	bool IsEmpty(void) const {return m_lstContainer.empty();}
+	int GetTransFactor(void) const {return m_iFactor;}
+	
+	// -- manipulate. 
+	// -- any operation, the ori_from and ori_to are calculated based on target segment. src segs ori information are discarded.
+	void AddSeg(int f, int t, EResidueExtension le = eAccurate, EResidueExtension re = eAccurate);	//  
+	void AddSeg(const TSeg& seg);
+	
+	void Clear(void) {m_lstContainer.clear();}
+	
+	void Merge(const CSegSet& src);
+	void Cross(const CSegSet& src);
+	void Clip(const CSegSet& src);
+	void Inv(int from, int to);	//inverse against a total range
+
+	int GetLeft(void) const;
+	int GetRight(void) const;
+	int GetTotalResidues(void) const;
+
+	void GetOverall(TSeg &target, int &ori_to) const;	//ori-to is calculated from the last segment factor is 1 or 3 -- if Pr2na
+	int GetOriTo(TSegs::const_iterator citer, int pos = -1) const;
+	int GetOriTo(void) const;
+	const TSegs& GetSegs(void) const {return m_lstContainer;}
+	
+	// -- gapThreshold is AA residue counts. Will automatically convert to NA (if applicable) counts in the result
+	void GetGaps(CSegSet &dst) const;
+	
+	void GetTranslatedPosMap(size_t aaSeqLen, std::vector<TResiduePos> &dst) const;
+	void GetSimplePosMap(vector<TResiduePos> &dst) const;
+	void GetOriSimplePosMap(vector<TResiduePos> &dst) const;
+	
+	
+	virtual int GetCompleteSize(void) const {return -1;}
+	
+private:
+	// -- the actual container
+	int m_iFactor;	//factor: when map protein to na, it is 3, otherwise it is 1. sign denotes the direction
+	TSegs m_lstContainer;
+public:
+	unsigned int m_ulGapThreshold;
+
+};
+
+bool TSeg::IsValid(void) const
+{
+	return (from >= 0 && to >= from);
+}
+
+bool TSeg::operator == (const TSeg& other) const
+{
+	return from == other.from && to == other.to;
+}
+
+bool TSegSortLeft::operator () (const TSeg* s1, const TSeg* s2)
+{
+	return s1->from < s2->from;
+}
+
+bool TSegSortLength::operator () (const TSeg* s1, const TSeg* s2)
+{
+	return s1->to - s1->from > s2->to - s2->from;
+}
+
+CSegSet::CSegSet(const vector<int> &residues)
+{
+	SetData(residues);
+}
+
+CSegSet::CSegSet(const vector<int> &starts, const vector<unsigned int> &lens): m_iFactor(1), m_lstContainer(), m_ulGapThreshold(-1)
+{
+	// -- do not clear segset first. we may need to add segs
+	SetData(starts, lens);
+}
+
+bool CSegSet::operator == (const CSegSet& other) const
+{
+	return m_lstContainer == other.m_lstContainer;
+}
+
+void CSegSet::SetData(const vector<int>& starts, const vector<unsigned int>& lens)
+{
+	m_lstContainer.clear();
+	for (size_t i = 0; i < lens.size(); ++i)
+		AddSeg(starts[i], starts[i] + lens[i] - 1, eAccurate, eAccurate);
+}
+
+void CSegSet::SetData(const vector<int> &residues)
+{
+	m_lstContainer.clear();
+	
+	if (residues.empty()) return;
+	
+	vector<int> sorted(residues);
+	sort(sorted.begin(), sorted.end());
+	
+	TSeg seg;
+	
+	seg.from = seg.to = seg.ori_from = sorted[0];
+	
+	size_t i = 0, iEnd = sorted.size();
+	
+	while (i < iEnd)
+	{
+		if (sorted[i] > seg.to + 1)
+		{
+			AddSeg(seg);
+			seg.from = seg.to = seg.ori_from = sorted[i];
+		}
+		else if (sorted[i] > seg.to)
+		{
+			seg.to = sorted[i];
+		}
+		
+		++i;
+	}
+	AddSeg(seg);
+}
+
+
+void CSegSet::AddSeg(int f, int t, EResidueExtension le, EResidueExtension re)
+{
+	AddSeg(TSeg(f, t, le, re));
+}
+
+// -- will discard seg original info
+void CSegSet::AddSeg(const TSeg& seg)
+{
+	if (!seg.IsValid()) return;
+	TSegs::iterator curr = m_lstContainer.begin(), dstEnd = m_lstContainer.end();
+	
+	while (dstEnd != curr && curr -> to < seg.from - 1) ++curr;
+	if (curr == m_lstContainer.end())	//add to end
+	{
+		m_lstContainer.insert(dstEnd, seg);
+		return;
+	}
+	else if (curr->from > seg.to + 1)	// gap big enough
+	{
+		m_lstContainer.insert(curr, seg);
+		return;
+	}
+	else	//merge the seg in
+	{
+		if (curr->from > seg.from)
+		{
+			curr->ori_from -= (curr->from - seg.from) / m_iFactor;
+			curr->from = seg.from;	//extended left
+			curr->lext = seg.lext;
+			
+		}
+		if (curr->to < seg.to)
+		{
+			curr->to = seg.to;	//extended right
+			curr->rext = seg.rext;
+		}
+		
+		TSegs::iterator nxt = curr;
+		
+		++nxt;
+		while (nxt != dstEnd && nxt->from <= curr->to + 1)
+		{
+			if (curr->to < nxt->to)
+			{
+				curr->to = nxt->to;	//merge next
+				curr->rext = nxt->rext;
+			}
+			m_lstContainer.erase(nxt);
+			nxt = curr;
+			++nxt;
+		}
+	}
+}
+
+
+
+void CSegSet::Merge(const CSegSet& src)
+{
+	TSegs::iterator curr = m_lstContainer.begin();
+	TSegs::const_iterator scur = src.m_lstContainer.begin();
+	
+	while (curr!= m_lstContainer.end() && scur != src.m_lstContainer.end())
+	{
+		if (curr->to < scur->from - 1) ++curr;
+		else if (scur->to < curr->from - 1)
+		{
+			m_lstContainer.insert(curr, *scur);
+			++scur;
+		}
+		else
+		{
+			// -- merge this src seg
+			if (curr->from > scur->from)
+			{
+				curr->ori_from -= (curr->from - scur->from) / m_iFactor;
+				curr->from = scur->from;
+				curr->lext = scur->lext;
+			}
+			if (curr->to < scur->to)
+			{
+				curr->to = scur->to;
+				curr->rext = scur->rext;
+			}
+			// -- to next src seg
+			++scur;
+			
+			// maintain this set			
+			TSegs::iterator nxt = curr;
+			++nxt;
+			while (nxt != m_lstContainer.end() && nxt->from <= curr->to + 1)
+			{
+				if (curr->to < nxt->to)
+				{
+					curr->to = nxt->to;	//merge next
+					curr->rext = nxt->rext;
+				}
+				m_lstContainer.erase(nxt);
+				nxt = curr;
+				++nxt;
+			}
+		}
+	}
+	// -- add the rest segs in
+	
+	while (scur != src.m_lstContainer.end())
+		m_lstContainer.push_back(*scur++);
+}
+
+void CSegSet::Cross(const CSegSet& src)
+{
+	TSegs::iterator curr = m_lstContainer.begin();
+	TSegs::const_iterator scur = src.m_lstContainer.begin();
+	
+	while (curr!= m_lstContainer.end() && scur != src.m_lstContainer.end())
+	{
+		if (curr->to < scur->from)
+		{
+			TSegs::iterator del = curr;
+			++curr;
+			m_lstContainer.erase(del);
+		} 
+		else if (scur->to < curr->from)
+		{
+			++scur;
+		}
+		else
+		{
+			if (curr->from < scur->from)
+			{
+				curr->ori_from += (scur->from - curr->from) / m_iFactor;
+				curr->from = scur->from;
+				curr->lext = scur->lext;
+			}
+			if (curr->to > scur->to + 1)
+			{
+				TSeg temp(curr->from, scur->to, curr->lext, scur->rext);
+				temp.ori_from = curr->ori_from;
+				m_lstContainer.insert(curr, temp);
+				
+				curr->ori_from += (scur->to + 2 - curr->from) / m_iFactor;
+				curr->from = scur->to + 2;
+				++scur;
+			}
+			else
+			{
+				if (curr->to > scur->to)
+				{
+					curr->to = scur->to;
+					curr->rext = scur->rext;
+					++scur;
+				}
+				++curr;
+			}
+		}
+	}
+	m_lstContainer.erase(curr, m_lstContainer.end());
+}
+
+void CSegSet::Clip(const CSegSet& src)
+{
+	TSegs::iterator curr = m_lstContainer.begin();
+	TSegs::const_iterator scur = src.m_lstContainer.begin();
+	
+	while (curr!= m_lstContainer.end() && scur != src.m_lstContainer.end())
+	{
+		if (curr->to < scur->from)
+		{
+			++curr;
+		} 
+		else if (scur->to < curr->from)
+		{
+			++scur;
+		}
+		else
+		{
+			if (curr->from < scur->from)
+			{
+				TSeg temp(curr->from, scur->from - 1, curr->lext, eFullRight);
+				temp.ori_from = curr->ori_from;
+				m_lstContainer.insert(curr, temp);
+			}
+			if (curr->to <= scur->to)
+			{
+				TSegs::iterator del = curr;
+				++curr;
+				m_lstContainer.erase(del);
+			}
+			else
+			{
+				curr->ori_from += (scur->to + 1 - curr->from) / m_iFactor;
+				curr->from = scur->to + 1;
+				curr->lext = eFullLeft;
+				++scur;
+			}
+		}
+	}
+}
+
+void CSegSet::Inv(int from, int to)	//inverse against a total range, discard original coordinates
+{
+	TSegs::iterator hdr = m_lstContainer.begin(), curr = hdr, dstEnd = m_lstContainer.end();
+	
+	while (curr != dstEnd && curr->to < from)
+		++curr;
+	m_lstContainer.erase(hdr, curr);
+	
+	int start = from;
+	while (curr != dstEnd && curr->from < to)
+	{
+		if (curr->from > start)	//insert new
+		{
+			TSeg temp(start, curr->from - 1);
+			m_lstContainer.insert(curr, temp);
+		}
+		start = curr->to + 1;
+		TSegs::iterator del = curr;
+		++curr;
+		m_lstContainer.erase(del);
+	}
+	
+	// -- assert()
+	if (start <= to)
+		m_lstContainer.insert(curr, TSeg(start, to));
+	// -- assert(curr->from > end);
+	m_lstContainer.erase(curr, dstEnd);
+}
+
+
+int CSegSet::GetLeft(void) const
+{
+	return IsEmpty() ? -1 : m_lstContainer.begin()->from;
+}
+
+int CSegSet::GetRight(void) const
+{
+	return IsEmpty() ? -1 : m_lstContainer.rbegin()->to;
+}
+
+int CSegSet::GetTotalResidues(void) const
+{
+	int iResult = 0;
+	for (TSegs::const_iterator iter = m_lstContainer.begin(); iter != m_lstContainer.end(); ++iter)
+	{
+		iResult += iter->to - iter->from + 1;
+	}
+	return iResult/abs(m_iFactor);
+}
+
+
+void CSegSet::GetOverall(TSeg &target, int &ori_to) const
+{
+	if (IsEmpty())
+	{
+		target.from = target.to = target.ori_from = -1;
+	}
+	else
+	{
+		TSegs::const_iterator iterFirst = m_lstContainer.begin();
+		TSegs::const_reverse_iterator iterLast = m_lstContainer.rbegin();
+		target.from = iterFirst->from;
+		target.ori_from = iterFirst->ori_from;
+		target.lext = iterFirst->lext;
+		target.to = iterLast->to;
+		target.rext = iterLast->rext;
+		ori_to = iterLast->ori_from + (iterLast->to - iterLast->from) / m_iFactor;
+	}
+}
+
+int CSegSet::GetOriTo(void) const
+{
+	if (m_lstContainer.empty()) return -1;
+	TSegs::const_reverse_iterator riter = m_lstContainer.rbegin();
+		
+	return riter->ori_from + (riter->to - riter->from) / m_iFactor;
+}
+
+int CSegSet::GetOriTo(TSegs::const_iterator citer, int pos) const
+{
+	//return citer->ori_from + (citer->to - citer->from) / m_iFactor;
+	if (pos < 0) pos = citer->to;
+	return citer->ori_from + (pos - citer->from) / m_iFactor;
+}
+
+void CSegSet::GetGaps(CSegSet &dst) const
+{
+	dst.Clear();
+	
+	if (IsEmpty() || ((size_t)-1 == m_ulGapThreshold)) return;
+	int fac = abs(m_iFactor);
+	unsigned int gapThreshold = fac * m_ulGapThreshold;
+	if (3 == fac && gapThreshold > 2) gapThreshold -= 2;
+	
+	TSegs::const_iterator iter = m_lstContainer.begin(), iter2 = iter, iterEnd = m_lstContainer.end();
+	
+	++iter2;
+	
+	
+	while (iterEnd != iter2)
+	{
+		int f = iter->to + 1, t = iter2->from - 1;
+		if (t - f + 1 > (int)gapThreshold)	//consider as gap
+			dst.AddSeg(f, t, eFullLeft, eFullRight);
+			
+		++iter;
+		++iter2;
+	}
+}
+
+void CSegSet::GetTranslatedPosMap(size_t aaSeqLen, vector<CSegSet::TResiduePos> &dst) const
+{
+	if (m_iFactor > 0)	//positive, nothing to worry about
+	{
+		for (TSegs::const_iterator iter = m_lstContainer.begin(), iterEnd = m_lstContainer.end(); iter != iterEnd; ++iter)
+		{
+			for (TSignedSeqPos c = iter->from, inc = 0; c <= iter->to; c += m_iFactor, ++inc)
+			{
+				dst.push_back(TResiduePos(c / m_iFactor, iter->ori_from + inc));
+			}
+		}
+	}
+	else
+	{
+		for (TSegs::const_iterator iter = m_lstContainer.begin(), iterEnd = m_lstContainer.end(); iter != iterEnd; ++iter)
+		{
+			for (TSignedSeqPos c = iter->to, inc = 0; c > iter->from; c += m_iFactor, ++inc)
+			{
+				dst.push_back(TResiduePos(aaSeqLen + c / m_iFactor, iter->ori_from + inc));
+			}
+		}
+	}
+}
+
+void CSegSet::GetSimplePosMap(vector<CSegSet::TResiduePos> &dst) const
+{
+	dst.clear();
+//	int sc = m_iFactor > 0 ? m_iFactor : -m_iFactor;
+	for (TSegs::const_iterator iter = m_lstContainer.begin(), iterEnd = m_lstContainer.end(); iter != iterEnd; ++iter)
+	{
+		for (int c = iter->from; c <= iter->to; ++c)
+		{
+			dst.push_back(TResiduePos(c, iter->ori_from + (c - iter->from) / m_iFactor));
+		}
+	}
+}
+
+
+void CSegSet::GetOriSimplePosMap(vector<CSegSet::TResiduePos> &dst) const
+{
+	dst.clear();
+	int fact = abs(m_iFactor);
+	
+	for (TSegs::const_iterator iter = m_lstContainer.begin(), iterEnd = m_lstContainer.end(); iter != iterEnd; ++iter)
+	{
+		for (int c = iter->from; c <= iter->to; c += fact)
+		{
+			dst.push_back(TResiduePos(c, iter->ori_from + (c - iter->from) / m_iFactor));
+		}
+	}
+}
+
+
+/**********************************************************************
+*	Helper class -- CProSite
+***********************************************************************/
+class CProSite
+{
+public:
+	enum EParseError
+	{
+		eNoError,
+		eInvalidChar,
+		eSyntaxError,
+		eUnexpectedEnd
+	};
+
+	struct TMatched
+	{
+		size_t start, end;
+		TMatched(size_t s = std::string::npos, size_t e = std::string::npos): start(s), end(e) {};
+	};
+	CProSite(void):m_vecCompiledPattern() {};
+	EParseError Parse(const std::string &expr, size_t &errorPos);
+	size_t Match(const std::string &text, size_t tlen, size_t start_pos) const;
+	void Search(const std::string &text, std::vector<TMatched> &result) const;
+	
+	// -- return a vector of minimal match length, with 'X' as generic, 'A' as alternative and S as strict.
+	void GetMinimalXMap(std::string &minMap) const;
+	
+private:
+	struct TPatternPos
+	{
+		static const unsigned int NEGATIVE_FILTER = 0x1;
+		static const unsigned int LAZY_MATCH = 0x2;
+		unsigned int m_uiFlags;	//positive or negative select
+		std::string m_strAltChars;
+		size_t m_ulMinCount, m_ulMaxCount;
+		size_t (TPatternPos::*m_pfnMatch)(const std::string &text, size_t tlen, size_t pos) const;
+		
+		TPatternPos(void);
+		//return <0 as match fail. return 0 as "just match" without flex. return >0 as how many flex positions
+		int Match(const std::string &text, size_t tlen, std::vector<size_t> &rMatchRec, size_t start_pos = std::string::npos) const;
+		size_t x_NegMatch(const std::string &text, size_t tlen, size_t pos) const;
+		size_t x_PosMatch(const std::string &text, size_t tlen, size_t pos) const;
+			
+		void x_NormalizeAltChars(void);
+	};
+	
+
+
+	struct x_TMatchRec
+	{
+		std::vector<size_t> flex;
+		std::vector<TPatternPos> :: const_iterator iterPos;
+		
+		x_TMatchRec(std::vector<TPatternPos> :: const_iterator p): flex(), iterPos(p) {};
+	};
+	
+	std::vector<TPatternPos> m_vecCompiledPattern;
+	
+};
+
+
+CProSite::TPatternPos::TPatternPos(void):
+	m_uiFlags(0), m_strAltChars(k_strEmptyString), m_ulMinCount(1), m_ulMaxCount(1), m_pfnMatch(&TPatternPos::x_PosMatch)
+{};
+
+
+
+void CProSite::Search(const std::string &text, vector<CProSite::TMatched> &result) const
+{
+	result.clear();
+	size_t tlen = text.size();
+	for (size_t i = 0; i < tlen; ++i)
+	{
+		size_t mpos = Match(text, tlen, i);
+		if (string::npos != mpos)	//success
+			result.push_back(TMatched(i, mpos));
+	}
+}
+
+ 
+CProSite::EParseError CProSite::Parse(const string &expr, size_t &errorPos)
+{
+	if (expr.empty()) return eUnexpectedEnd;
+	
+	enum __EParserStatus
+	{
+		eParserReady = 0,
+		ePlainText,	//collecting plain text
+		eAlternates,	//in [] collecting alternative
+		eAltRedund,
+		eNegations,	//in {} collecting alternative
+		eNegRedund,
+		eRepeats,	//in () collecting repeats
+		eRange	//only valid for X, in (a,b) collecting 
+	} status = eParserReady;
+	
+	EParseError eErrorType = eNoError;	
+
+	
+	string::const_iterator iterChar = expr.begin(), iterCharEnd = expr.end();
+	
+	m_vecCompiledPattern.clear();
+	TPatternPos __dummy;
+	vector<TPatternPos> :: iterator iterCurr = m_vecCompiledPattern.end();
+	
+	string lit(k_strEmptyString);
+	bool bEscaped = false;	//if '\' is detected
+	bool bInfLit = false;
+	
+	while (iterCharEnd != iterChar)
+	{
+		char c = *iterChar;
+		if ('a' <= c && 'z' >= c) c -= 0x20;	//turn to capital letters
+		switch (c)
+		{
+		case '*':	//stop codon
+			if (!bEscaped)	//not escaped, as equivalent to (0, inf)
+			{
+				switch (status)
+				{
+				case ePlainText:
+					iterCurr->m_ulMinCount = 0;
+					iterCurr->m_ulMaxCount = -1;	//the biggest possible
+					if (iterCurr->m_strAltChars == "X") iterCurr->m_uiFlags |= TPatternPos::LAZY_MATCH;
+					break;
+				case eAlternates:	//always treat as a literal * (stop codon)
+				case eNegations:
+					iterCurr->m_strAltChars.push_back(c);
+					break;
+				case eRange:	//accepting max
+				case eRepeats:
+					if (lit.empty() && !bInfLit) 
+					{
+						bInfLit = true;
+						break;
+					}
+				case eAltRedund:
+				case eNegRedund:
+					break;
+				default:
+					eErrorType = eSyntaxError;
+					goto labelErrorRet;
+				}
+				break;
+			}
+			
+		case 'A':
+		case 'C':
+		case 'D':
+		case 'E':
+		case 'F':
+		case 'G':
+		case 'H':
+		case 'I':
+		case 'K':
+		case 'L':
+		case 'M':
+		case 'N':
+		case 'P':
+		case 'Q':
+		case 'R':
+		case 'S':
+		case 'T':
+		case 'U':	//newly added selenocysteine
+		case 'V':
+		case 'W':
+		case 'Y':
+		
+			switch (status)
+			{
+			case eParserReady:	//No current
+				status = ePlainText;
+			case ePlainText:	//current is valid
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+			case eAlternates:	//single char alternative, assume: iterCurrAltPattern is undefined
+			case eNegations:
+				iterCurr->m_strAltChars.push_back(c);
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			bEscaped = false;
+			break;
+		case 'X':	//special: wildcard, no alternates or negates allowed.
+			switch (status)
+			{
+			case eParserReady:	//No current
+				status = ePlainText;
+			case ePlainText:	//current is valid
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				iterCurr->m_strAltChars.push_back(c);
+				//iterCurr->m_uiFlags |= TPatternPos::LAZY_MATCH;
+				break;
+			case eAlternates:	//if alternates, and 'X' mean everything canbe accepted.
+			case eNegations:
+				iterCurr->m_strAltChars.push_back(c);
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			bEscaped = false;
+			break;
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			switch (status)
+			{
+			case eRepeats:
+			case eRange:
+				if (!bInfLit)
+				{
+					lit.push_back(c);
+					break;
+				}
+			
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+				
+			case eAltRedund:
+			case eNegRedund:
+				break;	//ignore it
+			}
+			bEscaped = false;
+			break;
+		case '(':
+			switch (status)
+			{
+			case ePlainText:
+				status = eRepeats;	//change to repeats. assert(cTargetChar is defined)
+				lit.clear();
+				break;
+			// -- added 02/12/2016 to tolerate redunence in alternations
+			case eAlternates:
+				status = eAltRedund;
+				break;
+			case eNegations:
+				status = eNegRedund;
+				break;
+			// -- End added 02/12/2016 
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case ')':
+			switch (status)
+			{
+			case eRepeats:	//end of repeat
+				if (!lit.empty())	//has input
+				{
+					iterCurr->m_ulMinCount = iterCurr->m_ulMaxCount = (size_t)atol(lit.c_str());
+				}
+				else if (bInfLit)
+				{
+					iterCurr->m_ulMinCount = 0;
+					iterCurr->m_ulMaxCount = -1;	//the biggest possible
+					if (iterCurr->m_strAltChars == "X") iterCurr->m_uiFlags |= TPatternPos::LAZY_MATCH;	//infinit X will have lazy match
+					bInfLit = false;
+				}
+				else
+				{
+					eErrorType = eSyntaxError;
+					goto labelErrorRet;
+				}
+				status = ePlainText;
+
+				break;
+			case eRange:	//end of range, assume iterGroup already renewed by the ',' token
+				if (!lit.empty())	//has input
+				{
+					iterCurr->m_ulMaxCount = (size_t)atol(lit.c_str());
+					// -- check for reversed
+					if (iterCurr->m_ulMaxCount < iterCurr->m_ulMinCount)
+					{
+						iterCurr->m_ulMaxCount ^= iterCurr->m_ulMinCount;
+						iterCurr->m_ulMinCount ^= iterCurr->m_ulMaxCount;
+						iterCurr->m_ulMaxCount ^= iterCurr->m_ulMinCount;
+					}
+				}
+				else if (bInfLit)
+				{
+					iterCurr->m_ulMaxCount = -1;
+					if (iterCurr->m_strAltChars == "X") iterCurr->m_uiFlags |= TPatternPos::LAZY_MATCH;
+					bInfLit = false;
+				}
+				else
+				{
+					eErrorType = eSyntaxError;
+					goto labelErrorRet;
+				}
+				status = ePlainText;
+				break;
+			case eAltRedund:
+				status = eAlternates;
+				break;
+			case eNegRedund:
+				status = eNegations;
+				break;	//ignore it 
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			};
+			break;
+
+		case ',':	//turn repeat into range
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case eRepeats:	//turn repeats into a range spec.
+			
+				if (!lit.empty())
+				{
+					iterCurr->m_ulMinCount = (size_t)atol(lit.c_str());
+					lit.clear();
+					status = eRange;
+					break;
+				}
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			case eAltRedund:
+			case eNegRedund:
+				break;
+			};
+			break;
+		case '\\':
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			bEscaped = true;
+			break;
+			
+		case '[':	//start variable set
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case ePlainText:
+			case eParserReady:
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				//iterCurr->m_uiFlags = true;
+				status = eAlternates;
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			};
+			break;
+		case ']':	//end variable set
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case eAlternates:
+				if (!iterCurr->m_strAltChars.empty())
+				{
+					iterCurr->x_NormalizeAltChars();
+					status = ePlainText;
+					break;
+				}
+				
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case '{':	//negative set
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case ePlainText:	//start of alternative
+			case eParserReady:
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				iterCurr->m_uiFlags |= TPatternPos::NEGATIVE_FILTER;
+				iterCurr->m_pfnMatch = &TPatternPos::x_NegMatch;
+				status = eNegations;
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			};
+			break;
+		case '}':	//end negative set
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case eNegations:
+				if (!iterCurr->m_strAltChars.empty())
+				{
+					iterCurr->x_NormalizeAltChars();
+					status = ePlainText;
+					break;
+				}
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case '<':	//start anchor
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case eAlternates:
+				if (m_vecCompiledPattern.begin() != iterCurr)	//not the first 
+				{
+					eErrorType = eSyntaxError;
+					goto labelErrorRet;
+				}
+			case eNegations:
+				iterCurr->m_strAltChars.push_back(c);
+				break;
+			case eParserReady:
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				iterCurr->m_strAltChars.push_back(c);
+				status = ePlainText;
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case '>':	//end anchor
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case ePlainText:
+			case eParserReady:
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				iterCurr->m_strAltChars.push_back(c);
+				status = ePlainText;
+				break;
+			case eNegations:
+				iterCurr->m_strAltChars.push_back(c);
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case '-':	//ignore
+		case ' ':
+		case '\t':
+			break;
+		default:
+			eErrorType = eInvalidChar;
+			goto labelErrorRet;
+		}
+		++iterChar;
+	}
+	
+labelErrorRet:
+	errorPos = (iterChar - expr.begin());
+	return eErrorType;	
+}
+ 
+size_t CProSite::Match(const string &text, size_t tlen, size_t start_pos) const
+{
+	if (start_pos >= tlen) return string::npos;
+	stack<x_TMatchRec> stkFlexStack;
+	
+	x_TMatchRec curr(m_vecCompiledPattern.begin());
+	
+	vector<TPatternPos> :: const_iterator iterPosEnd = m_vecCompiledPattern.end();
+	
+	
+	while (iterPosEnd != curr.iterPos)
+	{
+		int matched = curr.iterPos->Match(text, tlen, curr.flex, start_pos);
+		if (matched < 0)	//match failed
+		{
+			if (stkFlexStack.empty()) return string::npos;
+			curr = stkFlexStack.top();
+			stkFlexStack.pop();
+		}
+		else	//match success
+		{
+			if (matched > 0) stkFlexStack.push(curr);
+			start_pos = curr.flex.back();
+			++curr.iterPos;
+			curr.flex.clear();
+		}
+	}
+	
+	
+	// -- successfully matched all PatternPosition
+	return start_pos;	//should always be valid.
+	
+}
+void CProSite::TPatternPos::x_NormalizeAltChars(void)
+{
+	if (!m_strAltChars.empty())
+	{
+		size_t idx = 0, ttl = m_strAltChars.size();
+		vector<size_t> veciidx;
+		veciidx.reserve(ttl);
+		while (idx < ttl)
+		{
+			char currc = m_strAltChars[idx];
+			if ('X' == currc)	//no matter others, just being the one
+			{
+				m_strAltChars.clear();
+				m_strAltChars.push_back('X');
+				break;
+			}
+			veciidx.clear();
+			
+			size_t mv = 0;
+			size_t idx2 = idx + 1;
+			while (idx2 < ttl)
+			{
+				if (m_strAltChars[idx2] == currc)
+					++mv;
+				else if (mv > 0)
+					m_strAltChars[idx2 - mv] = m_strAltChars[idx2];
+				
+				++idx2;
+			}
+			
+			ttl -= mv;
+			
+			while (mv > 0)
+			{
+				m_strAltChars.pop_back();
+				--mv;
+			}
+			
+			++idx;
+		}
+	}
+
+}
+// -- negative position match
+size_t CProSite::TPatternPos::x_NegMatch(const string &text, size_t tlen, size_t pos) const
+{
+	string::const_iterator iterChar = m_strAltChars.begin(), iterCharEnd = m_strAltChars.end();
+	size_t adv = 0;
+	
+	while (iterCharEnd != iterChar)
+	{
+		switch (*iterChar)
+		{
+		case '<':	//start anchor
+			if (0 == pos)	//matched, fail it
+				return string::npos;
+			break;
+		case '>':	//end anchor
+			if (pos == tlen)	//matched
+				return string::npos;
+			break;
+		case 'X':
+			if (pos < tlen)
+				return string::npos;
+			break;
+		default:
+			if (pos < tlen)
+			{
+				char c = text[pos];
+				adv = 1;
+				if ('a' <= c && 'z' >= c) c -= 0x20;
+				if (*iterChar == c)	//matched
+					return string::npos;
+			}
+			else
+				return string::npos;
+		}
+		
+		++iterChar;
+	}
+	return adv;	//nothing matched, successful
+}
+ 
+// -- positive position match
+size_t CProSite::TPatternPos::x_PosMatch(const string &text, size_t tlen, size_t pos) const
+{
+	string::const_iterator iterChar = m_strAltChars.begin(), iterCharEnd = m_strAltChars.end();
+	while (iterCharEnd != iterChar)
+	{
+		switch (*iterChar)
+		{
+		case '<':	//start anchor
+			if (0 == pos)	//matched
+				return 0;
+			break;
+		case '>':	//end anchor
+			if (pos == tlen)	//matched
+				return 0;
+			break;
+		case 'X':	//match any
+			if (pos < tlen)	//last, 
+				return 1;
+			break;
+		default:
+			if (pos < tlen)
+			{
+				char c = text[pos];
+				if ('a' <= c && 'z' >= c) c -= 0x20;
+				if (*iterChar == c)	//matched
+					return 1;
+			}
+		}
+		
+		++iterChar;
+	}
+	return string::npos;
+}
+
+
+int CProSite::TPatternPos::Match(const string &text, size_t tlen, vector<size_t> &rMatchRec, size_t start_pos) const
+{
+
+	size_t matched = rMatchRec.size();	//assume: at least one [0] as the start position
+
+	int retVal = 0;	//return 0: match success but no more flex, -1: match failed. >1: # of flex left
+	if (m_uiFlags & LAZY_MATCH)	//do not clear rMatchRec
+	{
+		if (0 == matched)	//the first time
+		{
+			
+			rMatchRec.push_back(start_pos);
+			
+			// -- first, must match to minimal count
+			
+			while (rMatchRec.size() <= m_ulMinCount)
+			{
+				size_t adv = (this->*m_pfnMatch)(text, tlen, start_pos);
+				
+				if (string::npos == adv)	//fail
+				{
+					return -1;
+				}
+				start_pos += adv;
+				rMatchRec.push_back(start_pos);
+			}
+			if (m_ulMaxCount > m_ulMinCount) retVal = 1;
+			else retVal = 0;
+		}
+		else if (matched <= m_ulMaxCount)	//still flex	//revisit
+		{
+			start_pos = rMatchRec[matched - 1];
+			size_t adv = (this->*m_pfnMatch)(text, tlen, start_pos);
+			if (string::npos == adv)	//successful
+				retVal = -1;
+			else
+			{
+				start_pos += adv;
+				rMatchRec.push_back(start_pos);
+				if (m_ulMaxCount > matched) retVal = 1;
+				else retVal = 0;
+			}
+		}
+	}
+	else	//aggressive match
+	{
+		if (0 == matched)	//the first time
+		{
+			rMatchRec.push_back(start_pos);
+			while ((matched = rMatchRec.size()) <= m_ulMaxCount)
+			{
+				size_t adv = (this->*m_pfnMatch)(text, tlen, start_pos);
+				if (string::npos == adv)	//fail
+					break;
+				start_pos += adv;
+				rMatchRec.push_back(start_pos);
+			}
+		}
+		else 
+		{
+			rMatchRec.pop_back();
+			matched = rMatchRec.size();
+		}
+		if (matched < m_ulMinCount + 1) retVal = -1;	// minimal match not reached
+		else if (matched > m_ulMinCount + 1) retVal = 1;	//with flex
+		else retVal = 0;
+	}
+	return retVal;
+}
+
+void CProSite::GetMinimalXMap(string &minMap) const
+{
+	minMap.clear();
+	size_t ttl = m_vecCompiledPattern.size();
+
+	if (ttl > 0)
+	{
+		minMap.reserve(ttl + ttl);
+		for (size_t i = 0; i < ttl; ++i)
+		{
+			if (m_vecCompiledPattern[i].m_ulMinCount > 0)
+			{
+				switch (m_vecCompiledPattern[i].m_strAltChars.size())
+				{
+				case 0:
+					break;
+				case 1:
+					if ('X' == m_vecCompiledPattern[i].m_strAltChars[0]) minMap.append(m_vecCompiledPattern[i].m_ulMinCount, 'X');
+					else if (m_vecCompiledPattern[i].m_uiFlags & TPatternPos::NEGATIVE_FILTER) minMap.append(m_vecCompiledPattern[i].m_ulMinCount, 'A');
+					else minMap.append(m_vecCompiledPattern[i].m_ulMinCount, 'S');
+					break;
+				default:	//>1
+					minMap.append(m_vecCompiledPattern[i].m_ulMinCount, 'A');
+				}
+			}
+		}
+	}
+	
+}
+
+
+/**********************************************************************
+*	Global data
+***********************************************************************/
+string g_strCfgFile(k_strEmptyString);
+string g_strSrcFile(k_strEmptyString);
+string g_strDstFile(k_strEmptyString);
+string g_strDataPath(k_strEmptyString);
+
+double g_dEValue = 0.01;
+int g_iDataMode = TDataModes::eDefault;
+int g_iTargetData = TTargetData::eDefault;
+bool g_bSuperfams = false;
+bool g_bRunProg = true;	//by default, program will run, but if user specified -h to get help, program won't run, just display usage information
+bool g_bSilent = false;	//display program info
+
+const char * g_pProgName = NULL;
+
+
+
+/**********************************************************************
+*	NCBI Registry handler -- config file
+***********************************************************************/
+bool ReadConfig(const char * cfgfile, CNcbiRegistry &reg)
+{
+	if (!cfgfile) cfgfile = CONFIGFILE;
+	bool status = false;
+	
+	ifstream regfs(cfgfile, ios::in | ios::binary);
+
+	if (regfs.good())
+	{
+		reg.Read(regfs);
+		status = true;
+	}
+		
+	regfs.close();
+	return status;
+}
+
+
+/**********************************************************************
+*	Bio-objects in/out templates
+***********************************************************************/
+template<class BioObj> 
+void ObjStreamIn(CNcbiIstream& is, BioObj& rBioObj, ESerialDataFormat eFormat = eSerial_AsnText)
+{
+	CObjectIStream *pIStream = CObjectIStream::Open(eFormat, is, eNoOwnership);
+	*pIStream >> rBioObj;
+	//pIStream->Read(ObjectInfo(rBioObj));
+	delete pIStream;
+}
+
+template<class BioObj> 
+BioObj* ObjStreamIn(CNcbiIstream& is, BioObj* pBioObj = nullptr, ESerialDataFormat eFormat = eSerial_AsnText)
+{
+	BioObj* pEffective = pBioObj ? pBioObj : new BioObj();
+	CObjectIStream *pIStream = CObjectIStream::Open(eFormat, is, eNoOwnership);
+
+	*pIStream >> (*pEffective);
+	delete pIStream;
+	return pEffective;
+}
+
+template<class BioObj> 
+void ObjStreamOut(CNcbiOstream& os, const BioObj& rBioObj, ESerialDataFormat eFormat = eSerial_AsnText)
+{
+
+  if (eSerial_Xml == eFormat)	//Get rid of dtd
+  {
+  	CObjectOStreamXml os_xml(os, false);
+  	os_xml.SetReferenceDTD(false);
+  	os_xml << rBioObj;
+  }
+	else
+	{
+		CObjectOStream *pOStream = CObjectOStream::Open(eFormat, os, eNoOwnership);
+		*pOStream << rBioObj;
+		delete pOStream;
+	}
+}
+
+template<class BioObj> 
+void ObjStreamOut(CNcbiOstream& os, const BioObj* pBioObj, ESerialDataFormat eFormat = eSerial_AsnText)
+{
+	if (nullptr == pBioObj) return;
+	
+	if (eSerial_Xml == eFormat)	//Get rid of dtd
+    {
+    	CObjectOStreamXml os_xml(os, false);
+    	os_xml.SetReferenceDTD(false);
+    	os_xml << (*pBioObj);
+    }
+	else
+	{
+		CObjectOStream *pOStream = CObjectOStream::Open(eFormat, os, eNoOwnership);
+		*pOStream << (*pBioObj);
+		delete pOStream;
+	}
+}
+
+
+struct TDomSrcCount
+{
+	enum ESrcIdx
+	{
+		eCDD = 0,
+		ePFam = eCDD + 1,
+		eTIGRFam = ePFam + 1,
+		eCOG = eTIGRFam + 1,
+		eSMART = eCOG + 1,
+		ePRK = eSMART + 1,
+		TOTALSRCS = ePRK + 1
+	};
+	
+	//static const size_t TOTALSRCS = ePRK + 1;
+	static const size_t TOTALSIGS = 11;
+	static const char * DOMSRCSIGS[TOTALSIGS];
+	static const int MAXCOUNTS[TOTALSRCS];
+	static ESrcIdx DomAccType(const string &acxn);
+	
+	
+	map<ESrcIdx, int> m_SrcCounter;
+	// -- return true: counted. false: src already full, so not counted
+	bool CountSrc(const std::string &acxn);
+};
+
+const int TDomSrcCount::MAXCOUNTS[] = {1, 1, 1, 1, 1, 1};
+const char * TDomSrcCount::DOMSRCSIGS[] = {"CD", "PFAM", "TIGR", "COG", "SMART", "PRK", "CHL", "MTH", "PHA", "PLN", "PTZ"};
+
+TDomSrcCount::ESrcIdx TDomSrcCount::DomAccType(const string &acxn)
+{
+	size_t iSig = 0, iChar = 0, iAccChar = 0, acclen = acxn.size();
+	
+
+	while (iSig < TOTALSIGS && 0 != DOMSRCSIGS[iSig][iChar] && iAccChar < acclen)
+	{
+		char accChar = acxn[iAccChar];
+		if ('a' <= accChar && 'z' >= accChar) accChar -= 0x20;	//to uppercase
+		if (accChar == DOMSRCSIGS[iSig][iChar])
+		{
+			++iAccChar;
+			++iChar;
+		}
+		else
+		{
+
+			++iSig;
+			iChar = 0;
+			iAccChar = 0;
+		}
+	}
+/**************************************************************************************
+Besides Pfam, CDD, TIGRFAM, COGs, SMART, PRK, we still have these type of accessions:
+"CHL", "MTH", "PHA", "PLN", "PTZ"
+All of these should be grouped together with the PRK as PRK models
+***************************************************************************************/
+
+	if (iSig < ePRK)
+		return static_cast<ESrcIdx> (iSig);
+	else if (iSig < TOTALSIGS)
+		return ePRK;
+	else
+		return TOTALSRCS;
+}
+
+bool TDomSrcCount::CountSrc(const std::string &acxn)
+{
+	ESrcIdx srctype = DomAccType(acxn);
+	if (TOTALSRCS == srctype) return true;	//unknown src always enter.
+	
+	map<ESrcIdx, int> :: iterator iter = m_SrcCounter.emplace(srctype, 0).first;
+
+
+	if (iter->second >= MAXCOUNTS[srctype]) return false;
+	++iter->second;
+	return true;
+}
+
+
+
+
+/**********************************************************************
+*	Data structure and processing classes
+***********************************************************************/
+const int RF_SIZE = 3;	//reading frame size
+const int TOTAL_RFS = 6;	//reading frame size
+const char* RF_TITLES[TOTAL_RFS] = {"RF +1", "RF +2", "RF +3", "RF -1", "RF -2", "RF -3"};
+
+inline int RF2Idx(int rf)
+{
+	return (rf > 0 ? rf - 1 : -rf + 2);
+}
+
+inline int Idx2RF(int idx)
+{
+	return (idx > 2 ? 2 - idx : idx + 1);
+}
+
+/**********************************************************************
+*	Biodata structure -- domain feature (site annotation)
+***********************************************************************/
+struct TOflCDFeat: public CSegSet
+{
+	enum EFeatType	//this is arbitrary. 
+	{
+		eType_Other = 0,
+		eType_Active = 1,
+		eType_PolyPBinding = 2,
+		eType_NtBinding = 3,
+		eType_IonBinding = 4,
+		eType_ChemBinding = 5,
+		eType_PostTransMod = 6,
+		eType_StructMotif = 7
+	};
+	
+	static const int TOTAL_TYPES = eType_StructMotif + 1;
+	static const char * GENERIC_SITE_TITLE;
+	
+	static const char * FEATTYPES[TOTAL_TYPES];
+	
+	static const unsigned int STRUCTURE_BASED_EVIDENCE = 0x1 << 0;
+	static const unsigned int REFERENCE_BASED_EVIDENCE = 0x1 << 1;
+	static const unsigned int ADDITIONAL_COMMENTS = 0x1 << 2;
+	
+	string m_strTitle;	//short title
+	string m_strDescr;	//descrption, future use
+	string m_strMotif;
+	string m_strModifiedMotif;	//depends on m_iMotifuse, this is a working version for CProSite
+	int m_iMotifuse;
+	int m_iIndex;	//index within pssm or other sequence
+	int m_iType;
+	int m_iCompleteSize;
+	
+	unsigned int flags;
+	
+	
+	
+	virtual int GetCompleteSize(void) const {return m_iCompleteSize;}
+	void SetMotifStr(const string &rMotifStr);
+	
+	// -- this is to checked the mapped site with motif. If rSeqData is provided, it ckecks
+	// -- both the residue position and type. If rSeqData is not provided, just check for
+	// -- all non-x residues are mapped. return values:
+	// -- 0: success or No motif to check.
+	// -- 1: Essential positions not complete
+	// -- 2: Essential positions complete but residue type mismatch.
+	int MotifCheck(const vector<CSegSet::TResiduePos> &rMappedRes, const string &rSeqData = k_strEmptyString) const;	//TResiduePos contains mapped and original positions, both on protein sequence
+	TOflCDFeat(void);
+	
+};
+
+const char * TOflCDFeat::GENERIC_SITE_TITLE = "active site";
+const char * TOflCDFeat::FEATTYPES[] = {"other", "active site", "polypeptide binding site", "nucleotide binding site", "ion binding site", "chemical binding site", "posttranslational modification", "structural motif"};
+
+TOflCDFeat::TOflCDFeat(void):
+	CSegSet(), m_strTitle(k_strEmptyString), m_strDescr(k_strEmptyString), m_strMotif(k_strEmptyString), m_strModifiedMotif(k_strEmptyString), 
+	m_iMotifuse(0), m_iIndex(0), m_iType(eType_Active), m_iCompleteSize(0), flags(0)
+{}
+
+void TOflCDFeat::SetMotifStr(const string &rMotifStr)
+{
+	m_strMotif = rMotifStr;
+	
+	//// -- modify. at this time, just turn all 'X' to X* so the non-essential residues are optional
+	//m_strModifiedMotif.clear();
+	//char cLast = 0;
+	//int count = 0;
+	//for (string::const_iterator iter = m_strMotif.begin(), iterEnd = m_strMotif.end(); iter != iterEnd; ++iter)
+	//{
+	//	char cCurr = *iter;
+	//	if (cCurr >= 'a' && cCurr <= 'z') cCurr -= 0x20;
+	//	
+	//	if (cCurr >= 'A' && cCurr <= 'Z')	//is residue
+	//	{
+	//		if (cCurr == cLast)
+	//		{
+	//			if ('X' != cLast) ++count;
+	//		}
+	//		else	//cCurr != cLast
+	//		{
+	//			if ('X' != cLast && count > 1)
+	//			{
+	//				char dimBuf[16];
+	//				sprintf(dimBuf, "(%d)", count);
+	//				m_strModifiedMotif.append(dimBuf);
+	//				
+	//			}
+	//			
+	//			count = 0;
+	//			cLast = cCurr;
+	//			
+	//			m_strModifiedMotif.push_back(cCurr);
+	//			
+	//			if ('X' == cCurr)
+	//				m_strModifiedMotif.push_back('*');
+	//			else
+	//				count = 1;
+	//				
+	//		}
+	//	}
+	//	else	//not residue
+	//	{
+	//		if (count > 1 && 'X' != cLast)	//
+	//		{
+	//			char dimBuf[16];
+	//			sprintf(dimBuf, "(%d)", count);
+	//			m_strModifiedMotif.append(dimBuf);
+	//		}
+	//		count = 0;
+	//		cLast = 0;
+	//		
+	//		m_strModifiedMotif.push_back(cCurr);
+	//	}
+	//}
+}
+
+int TOflCDFeat::MotifCheck(const vector<CSegSet::TResiduePos> &rMappedRes, const string &rSeqData) const
+{
+	if (!m_strMotif.empty())
+	{
+		size_t seqLen = rSeqData.size();
+		vector<CSegSet::TResiduePos> vecOriPoses;
+		GetTranslatedPosMap(seqLen, vecOriPoses);
+
+
+		CProSite ps;
+		size_t errPos;
+		CProSite::EParseError err = ps.Parse(m_strMotif, errPos);
+		if (CProSite::eNoError != err)
+		{
+			cerr << "Motif string parse error -- Motif = " << m_strMotif << ", error position: " << errPos;
+		}
+		string minMap(k_strEmptyString);
+		ps.GetMinimalXMap(minMap);
+		
+		size_t mtfLen = minMap.size();
+		size_t mappedLen = rMappedRes.size();
+//		assert(mtfLen == vecOriPoses.size());
+		
+		for (size_t i = 0; i < mtfLen; ++i)
+		{
+
+			if (minMap[i] != 'X')	//x always match
+			{
+				for (size_t j = 0; j < mappedLen; ++j)
+				{
+					if (rMappedRes[j].ori == vecOriPoses[i].curr)	//found, means mapped
+						goto labelResidueMapped;
+				}
+				return 1;
+			labelResidueMapped:;
+					
+			}
+		}
+		
+		if (!rSeqData.empty())
+		{
+			
+			minMap.clear();	//borrow this for other use
+			
+			for (size_t i = 0; i < mappedLen; ++i)
+				if ((size_t)rMappedRes[i].curr < seqLen)
+				{
+
+					minMap.push_back(rSeqData[rMappedRes[i].curr]);
+				}
+
+			size_t endPos = ps.Match(minMap, seqLen, 0);
+			if (string::npos == endPos)
+			{
+				return 2;
+			}
+		}
+	}
+
+	return 0;
+
+
+//	if (!m_strMotif.empty())
+//	{
+//		vector<CSegSet::TResiduePos> vecOriPoses;
+//		GetSimplePosMap(vecOriPoses);
+//		
+//
+//		CProSite ps;
+//		size_t errPos;
+//		CProSite::EParseError err = ps.Parse(m_strMotif, errPos);
+//		if (CProSite::eNoError != err)
+//		{
+//			cerr << "Motif string parse error -- Motif = " << m_strMotif << ", error position: " << errPos;
+//			//throw CException(CDiagCompileInfo(__FILE__, __LINE__, "int TOflCDFeat::MotifCheck(const CSegSet &mapped, const string &rSeqData) const"), NULL, CException::eUnknown, ss.str());
+//		}
+//		string minMap(k_strEmptyString);
+//		ps.GetMinimalXMap(minMap);
+//		
+//		size_t mtfLen = minMap.size();
+//		size_t mappedLen = rMappedRes.size();
+////		assert(mtfLen == vecOriPoses.size());
+//		
+//		for (size_t i = 0; i < mtfLen; ++i)
+//		{
+//			if (minMap[i] != 'X')
+//			{
+//				for (size_t j = 0; j < mappedLen; ++j)
+//				{
+//					if (rMappedRes[j].ori == vecOriPoses[i].curr)	//found, means mapped
+//						goto labelResidueMapped;
+//				}
+//				// --  not mapped, return failure
+//				return 1;
+//			labelResidueMapped:;
+//					
+//			}
+//		}
+//		
+//		if (!rSeqData.empty())
+//		{
+//			err = ps.Parse(m_strModifiedMotif, errPos);
+//			if (CProSite::eNoError != err)
+//			{
+//				cerr << "Motif string parse error -- Working Motif = " << m_strMotif << ", error position: " << errPos;
+//			}
+//			
+//			minMap.clear();	//borrow this for other use
+//			size_t seqLen = rSeqData.size();
+//			for (size_t i = 0; i < mappedLen; ++i)
+//				if ((size_t)rMappedRes[i].curr < seqLen)
+//				{
+//
+//					minMap.push_back(rSeqData[rMappedRes[i].curr]);
+//				}
+//			size_t endPos = ps.Match(minMap, seqLen, 0);
+//			if (string::npos == endPos)
+//			{
+//				return 2;
+//			}
+//		}
+//		
+//	}
+//	return 0;
+}
+
+/**********************************************************************
+*	Biodata structure -- Cluster (super family)
+***********************************************************************/
+struct TOflClusterInfo
+{
+	//unsigned int m_uiPSSMID;
+	string m_strAccession;
+	string m_strShortName;
+	string m_strDefline;
+	unsigned int m_uiLength;
+	TOflClusterInfo(void);
+	void Reset(void);
+};
+
+TOflClusterInfo::TOflClusterInfo(void):
+	m_strAccession(k_strEmptyString), m_strShortName(k_strEmptyString), m_strDefline(k_strEmptyString), m_uiLength(0)
+{}
+
+void TOflClusterInfo::Reset(void)
+{
+	m_strAccession.clear();
+	m_strShortName.clear();
+	m_strDefline.clear();
+	m_uiLength = 0;
+}
+
+
+/**********************************************************************
+*	Biodata structure -- Conserved Domain information
+***********************************************************************/
+struct TOflCDInfo: public TOflClusterInfo
+{
+	double m_dMinBitScore;
+	unsigned int m_uiHierarchyRoot;	//root pssmid
+	unsigned int m_uiHierarchyParent;	//root pssmid
+	unsigned int m_uiClusterPSSMID;
+	bool m_bCurated;
+	bool m_bIsStructDom;
+	bool m_bMultiDom;
+	
+	list<TOflCDFeat> m_lstSpecFeatures;
+	list<TOflCDFeat> m_lstGenFeatures;
+	TOflCDInfo(void);
+	void Reset(void);
+};
+
+TOflCDInfo::TOflCDInfo(void):
+	TOflClusterInfo(), m_dMinBitScore(0.0),
+	m_uiHierarchyRoot(0), m_uiHierarchyParent(0), m_uiClusterPSSMID(0), m_bCurated(false), m_bIsStructDom(false), m_bMultiDom(true), m_lstSpecFeatures(), m_lstGenFeatures()
+{}
+
+
+void TOflCDInfo::Reset(void)
+{
+	TOflClusterInfo::Reset();
+	m_dMinBitScore = 0.0;
+	m_uiHierarchyRoot = 0;
+	m_uiHierarchyParent = 0;
+	m_uiClusterPSSMID = 0;
+	m_bCurated = false;
+	m_bIsStructDom = false;
+	m_bMultiDom = true;
+	m_lstSpecFeatures.clear();
+	m_lstGenFeatures.clear();
+}
+
+/**********************************************************************
+*	Biodata structure -- Domain/Cluster info data center
+***********************************************************************/
+class COflDomClstInfo
+{
+public:
+	
+	static const unsigned int CDD_DATA_NOT_FOUND = 0x1;
+	static const unsigned int CLUSTER_LINK_NOT_FOUND = 0x1 << 1;
+	static const unsigned int HIERARCHY_DATA_NOT_FOUND = 0x1 << 2;
+	static const unsigned int FEATURE_DATA_NOT_FOUND = 0x1 << 3;
+	static const unsigned int SPTHRESHOLD_DATA_NOT_FOUND = 0x1 << 4;
+	static const unsigned int GENERIC_FEATURE_DATA_NOT_FOUND = 0x1 << 5;
+	COflDomClstInfo(void);
+	//COflDomClstInfo(const CNcbiRegistry &reg);
+	const TOflCDInfo* FindCDInfo(unsigned int pssmid) const;
+	const TOflClusterInfo* FindClusterInfo(unsigned int pssmid) const;
+	unsigned int GetStatus(void) const {return m_uiFlags;}
+	void LoadData(const CNcbiRegistry &reg);	//load data and set m_uiFlags
+	void LoadData(void);
+private:
+	struct TSortCDMapIterByAcc
+	{
+		bool operator () (map<unsigned int, TOflCDInfo> :: iterator v1, map<unsigned int, TOflCDInfo> :: iterator v2) {return v1->second.m_strAccession < v2->second.m_strAccession;}
+	};
+	
+	static unsigned int GetPSSMIdByAcc(vector<map<unsigned int, TOflCDInfo> :: iterator> src, const string & acc);
+
+	
+	void x_LoadData(ifstream &cdid, ifstream &cdtrack, ifstream &clstlink, ifstream &cddannot, ifstream &cddannot_gen, ifstream &spthr);
+	map<unsigned int, TOflCDInfo> m_mapOflCDInfo;
+	map<unsigned int, TOflClusterInfo> m_mapOflClusterInfo;
+		
+	unsigned int m_uiFlags;
+};
+
+unsigned int COflDomClstInfo::GetPSSMIdByAcc(vector<map<unsigned int, TOflCDInfo> :: iterator> src, const string & acc)
+{
+	size_t rbegin = 0, rend = src.size(), dist = rend - rbegin;
+
+	while (dist > 0)
+	{
+		size_t rmid = rbegin + (dist >> 1);
+
+		if (src[rmid]->second.m_strAccession == acc) return src[rmid]->first;
+		else if (src[rmid]->second.m_strAccession < acc) rbegin = rmid + 1;
+		else rend = rmid;
+		dist = rend - rbegin;
+	}
+	
+	return 0;
+}
+
+COflDomClstInfo::COflDomClstInfo(void): m_mapOflCDInfo(), m_mapOflClusterInfo(), m_uiFlags(-1)
+{
+	//if (m_mapOflCDInfo.empty()) LoadData();
+}
+
+	
+//COflDomClstInfo::COflDomClstInfo(const CNcbiRegistry &reg): m_mapOflCDInfo(), m_mapOflClusterInfo(), m_uiFlags(-1)
+//{
+//	//if (m_mapOflCDInfo.empty()) LoadData(reg);
+//}
+
+const TOflCDInfo* COflDomClstInfo::FindCDInfo(unsigned int pssmid) const
+{
+	map<unsigned int, TOflCDInfo> :: const_iterator iter = m_mapOflCDInfo.find(pssmid);
+	if (m_mapOflCDInfo.end() == iter) return NULL;
+	return &(iter->second);
+}
+
+const TOflClusterInfo* COflDomClstInfo::FindClusterInfo(unsigned int pssmid) const
+{
+	map<unsigned int, TOflClusterInfo> :: const_iterator iter = m_mapOflClusterInfo.find(pssmid);
+	if (m_mapOflClusterInfo.end() == iter) return NULL;
+	return &(iter->second);
+}
+
+void COflDomClstInfo::x_LoadData(ifstream &cdid, ifstream &cdtrack, ifstream &clstlink, ifstream &cddannot, ifstream &cddannot_gen, ifstream &spthr)
+{
+	m_mapOflCDInfo.clear();
+	m_mapOflClusterInfo.clear();
+	// -- first read cdid
+	pair<unsigned int, TOflCDInfo> cdValue;
+	pair<unsigned int, TOflClusterInfo> clstValue;
+	
+	vector<map<unsigned int, TOflCDInfo> :: iterator> vecAccSearchMap;
+	vecAccSearchMap.reserve(81920);	//estimated.
+	
+	string buf;
+	
+	while (cdid.good())
+	{
+		getline(cdid, buf);
+		if (!buf.empty() && '#' != buf[0])
+		{
+
+			size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+			unsigned int pssmid = (unsigned int)atoi(buf.substr(pos0, pos1 - pos0).c_str());
+			
+			pos0 = pos1 + 1;
+			pos1 = buf.find('\t', pos0);
+			
+			
+			if (('c' == buf[pos0] || 'C' == buf[pos0]) && ('l' == buf[pos0 + 1] || 'L' == buf[pos0 + 1]) && (buf[pos0 + 2] >= '0' && buf[pos0 + 2] <= '9'))	//cluster
+			{
+				clstValue.first = pssmid;
+				map<unsigned int, TOflClusterInfo> :: iterator iterClst = m_mapOflClusterInfo.insert(clstValue).first;
+				iterClst->second.m_strAccession = buf.substr(pos0, pos1 - pos0);
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);
+				iterClst->second.m_strShortName = buf.substr(pos0, pos1 - pos0);
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);
+				iterClst->second.m_strDefline = buf.substr(pos0, pos1 - pos0);
+				
+				pos0 = pos1 + 1;
+				iterClst->second.m_uiLength = (unsigned int)atoi(buf.substr(pos0).c_str());
+				continue;
+			}
+			
+			cdValue.first = pssmid;
+			map<unsigned int, TOflCDInfo> :: iterator iterDom = m_mapOflCDInfo.insert(cdValue).first;
+			iterDom->second.m_strAccession = buf.substr(pos0, pos1 - pos0);
+			
+			if (iterDom->second.m_strAccession[2] >= '0' && iterDom->second.m_strAccession[2] <= '9')	//cdxxx, sdxxx or clxxx
+			{
+				if ('d' == iterDom->second.m_strAccession[1] || 'D' == iterDom->second.m_strAccession[1])	//cd or sd
+				{
+					if ('c' == iterDom->second.m_strAccession[0] || 'C' == iterDom->second.m_strAccession[0])	//curated
+					{
+						iterDom->second.m_bCurated = true;
+						vecAccSearchMap.push_back(iterDom);
+					}
+						
+					else if ('s' == iterDom->second.m_strAccession[0] || 'S' == iterDom->second.m_strAccession[0])	//curated
+						iterDom->second.m_bIsStructDom = true;
+				}
+			}
+			
+			
+			pos0 = pos1 + 1;
+			pos1 = buf.find('\t', pos0);
+			iterDom->second.m_strShortName = buf.substr(pos0, pos1 - pos0);
+			
+			pos0 = pos1 + 1;
+			pos1 = buf.find('\t', pos0);
+			iterDom->second.m_strDefline = buf.substr(pos0, pos1 - pos0);
+			
+			pos0 = pos1 + 1;
+			iterDom->second.m_uiLength = (unsigned int)atoi(buf.substr(pos0).c_str());
+		}
+	}
+	
+	
+	sort(vecAccSearchMap.begin(), vecAccSearchMap.end(), TSortCDMapIterByAcc());
+	map<unsigned int, TOflCDInfo> :: iterator iterMapEnd = m_mapOflCDInfo.end();
+	
+	while (cdtrack.good())
+	{
+		getline(cdtrack, buf);
+		if (!buf.empty() && '#' != buf[0])
+		{
+			// -- accession
+			size_t pos0 = 0, pos1 = buf.find(' ', pos0);
+			string currAcc = buf.substr(pos0, pos1 - pos0);
+			
+			// -- title
+			while(' ' == buf[pos1]) ++pos1;
+			pos0 = pos1;
+			pos1 = buf.find(' ', pos0);
+			
+			
+			// -- pssmid
+			while(' ' == buf[pos1]) ++pos1;
+			pos0 = pos1;
+			pos1 = buf.find(' ', pos0);
+			
+			unsigned int pssmid = (unsigned int)atoi(buf.substr(pos0, pos1 - pos0).c_str());
+			
+			map<unsigned int, TOflCDInfo> :: iterator iterDom = m_mapOflCDInfo.find(pssmid);
+			if (iterMapEnd != iterDom)
+			{
+
+				// -- parent acc
+				while(' ' == buf[pos1]) ++pos1;
+				pos0 = pos1;
+				pos1 = buf.find(' ', pos0);
+				
+				string parentAcc = buf.substr(pos0, pos1 - pos0);
+				if ("N/A" != parentAcc)
+				{
+					if (parentAcc == iterDom->second.m_strAccession)
+						iterDom->second.m_uiHierarchyParent = iterDom->first;
+					else
+						iterDom->second.m_uiHierarchyParent = GetPSSMIdByAcc(vecAccSearchMap, parentAcc);
+				}
+				// -- root acc
+				while(' ' == buf[pos1]) ++pos1;
+				pos0 = pos1;
+				pos1 = buf.find(' ', pos0);
+				string rootAcc = buf.substr(pos0, pos1 - pos0);
+				
+				if (rootAcc == parentAcc)
+					iterDom->second.m_uiHierarchyRoot = iterDom->second.m_uiHierarchyParent;
+				else if (rootAcc == iterDom->second.m_strAccession)
+					iterDom->second.m_uiHierarchyRoot = iterDom->first;
+				else
+					iterDom->second.m_uiHierarchyRoot = GetPSSMIdByAcc(vecAccSearchMap, rootAcc);
+			}
+		}
+	}	//cdtrack
+	
+	
+
+	while (clstlink.good())
+	{
+		getline(clstlink, buf);
+		if (!buf.empty() && '#' != buf[0])
+		{
+			size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+			pos0 = pos1 + 1;
+			pos1 = buf.find('\t', pos0);
+			
+			unsigned int pssmid = (unsigned int)atoi(buf.substr(pos0, pos1 - pos0).c_str());
+			map<unsigned int, TOflCDInfo> :: iterator iterDom = m_mapOflCDInfo.find(pssmid);
+  
+			if (iterMapEnd != iterDom)
+			{
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);
+				pos0 = pos1 + 1;
+				//pos1 = buf.find('\t', pos0);
+				
+				iterDom->second.m_uiClusterPSSMID = (unsigned int)atoi(buf.substr(pos0).c_str());
+				iterDom->second.m_bMultiDom = false;
+			}
+		}
+	}
+	
+	
+	
+	TOflCDFeat featValue;
+
+
+	while (cddannot.good())
+	{
+		getline(cddannot, buf);
+		if (!buf.empty() && '#' != buf[0])
+		{
+
+			size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+			
+			unsigned int pssmid = (unsigned int)atoi(buf.substr(pos0, pos1 - pos0).c_str());
+			
+			
+			map<unsigned int, TOflCDInfo> :: iterator iterDom = m_mapOflCDInfo.find(pssmid);
+
+
+			
+			if (iterMapEnd != iterDom)
+			{
+				iterDom->second.m_lstSpecFeatures.push_back(featValue);
+				TOflCDFeat &tgt =  *(iterDom->second.m_lstSpecFeatures.rbegin());
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//accession
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//shortname
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//index
+				
+				tgt.m_iIndex = atoi(buf.substr(pos0, pos1 - pos0).c_str());
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//title
+				
+				tgt.m_strTitle = buf.substr(pos0, pos1 - pos0);
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//Motif
+				
+				if ('0' != buf[pos0])
+					tgt.SetMotifStr(buf.substr(pos0, pos1 - pos0).c_str());
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//structure based evidence present
+				
+				if ('1' == buf[pos0])
+					tgt.flags |= TOflCDFeat::STRUCTURE_BASED_EVIDENCE;
+					
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//reference based evidence present
+				
+				if ('1' == buf[pos0])
+					tgt.flags |= TOflCDFeat::REFERENCE_BASED_EVIDENCE;
+					
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//additional comments present
+				
+				if ('1' == buf[pos0])
+					tgt.flags |= TOflCDFeat::ADDITIONAL_COMMENTS;
+					
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//site coordinates
+				
+				vector<int> vecSitePos;	//to store coordinates
+				
+				vecSitePos.reserve((pos1 - pos0) * 3);	//estimated
+				
+				size_t pos_c = buf.find(',', pos0);
+				
+				while (pos_c < pos1)
+				{
+					vecSitePos.push_back(atoi(buf.substr(pos0, pos_c - pos0).c_str()));
+					pos0 = pos_c + 1;
+					pos_c = buf.find(',', pos0);
+				}
+				
+				// -- last one
+				vecSitePos.push_back(atoi(buf.substr(pos0, pos1 - pos0).c_str()));
+				
+				tgt.SetData(vecSitePos);
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//type
+				
+				if (string::npos == pos1)	//no other field
+					tgt.m_iType = atoi(buf.substr(pos0).c_str());
+				else	//assume has motif string added
+					tgt.m_iType = atoi(buf.substr(pos0, pos1 - pos0).c_str());
+			}
+		}
+	}
+
+	while (cddannot_gen.good())
+	{
+		getline(cddannot_gen, buf);
+		if (!buf.empty() && '#' != buf[0])
+		{
+
+			size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+			
+			unsigned int pssmid = (unsigned int)atoi(buf.substr(pos0, pos1 - pos0).c_str());
+			
+			
+			map<unsigned int, TOflCDInfo> :: iterator iterDom = m_mapOflCDInfo.find(pssmid);
+			
+			if (iterMapEnd != iterDom)
+			{
+				iterDom->second.m_lstGenFeatures.push_back(featValue);
+				TOflCDFeat &tgt =  *(iterDom->second.m_lstGenFeatures.rbegin());
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//accession
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//shortname
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//index
+				
+				tgt.m_iIndex = atoi(buf.substr(pos0, pos1 - pos0).c_str());
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//title
+				
+				tgt.m_strTitle = buf.substr(pos0, pos1 - pos0);
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//Motif
+				
+				if ('0' != buf[pos0])
+					tgt.SetMotifStr(buf.substr(pos0, pos1 - pos0).c_str());
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//structure based evidence present
+				
+				if ('1' == buf[pos0])
+					tgt.flags |= TOflCDFeat::STRUCTURE_BASED_EVIDENCE;
+					
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//reference based evidence present
+				
+				if ('1' == buf[pos0])
+					tgt.flags |= TOflCDFeat::REFERENCE_BASED_EVIDENCE;
+					
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//additional comments present
+				
+				if ('1' == buf[pos0])
+					tgt.flags |= TOflCDFeat::ADDITIONAL_COMMENTS;
+					
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//site coordinates
+				
+				vector<int> vecSitePos;	//to store coordinates
+				
+				vecSitePos.reserve((pos1 - pos0) * 3);	//estimated
+				
+				size_t pos_c = buf.find(',', pos0);
+				
+				while (pos_c < pos1)
+				{
+					vecSitePos.push_back(atoi(buf.substr(pos0, pos_c - pos0).c_str()));
+					pos0 = pos_c + 1;
+					pos_c = buf.find(',', pos0);
+				}
+				
+				// -- last one
+				vecSitePos.push_back(atoi(buf.substr(pos0, pos1 - pos0).c_str()));
+				
+				tgt.SetData(vecSitePos);
+				
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);	//type
+				
+				if (string::npos == pos1)	//no other field
+					tgt.m_iType = atoi(buf.substr(pos0).c_str());
+				else	//assume has motif string added
+					tgt.m_iType = atoi(buf.substr(pos0, pos1 - pos0).c_str());
+			}
+		}
+	}
+		
+	
+
+	while (spthr.good())
+	{
+		getline(spthr, buf);
+
+		if (!buf.empty() && '#' != buf[0])
+		{
+
+			size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+
+			unsigned int pssmid = (unsigned int)atoi(buf.substr(pos0, pos1 - pos0).c_str());
+
+			
+			map<unsigned int, TOflCDInfo> :: iterator iterDom = m_mapOflCDInfo.find(pssmid);
+			
+			if (iterMapEnd != iterDom)
+			{
+				// -- accession, no need
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);
+
+				
+				// -- score
+				pos0 = pos1 + 1;
+				pos1 = buf.find('\t', pos0);
+
+
+				if (string::npos == pos1)
+				{
+
+					iterDom->second.m_dMinBitScore = atof(buf.substr(pos0).c_str());
+				}
+				else
+				{
+
+
+					iterDom->second.m_dMinBitScore = atof(buf.substr(pos0, pos1 - pos0).c_str());
+				}
+			}
+		}
+	}
+}
+void COflDomClstInfo::LoadData(void)
+{
+	m_uiFlags = 0;
+	ifstream cdid, cdtrack, clstlink, cddannot, cddannot_gen, spthr;
+	
+	if (!g_strDataPath.empty())
+	{
+		cdid.open((g_strDataPath + "/" + CDIDFILE).c_str());
+		if (!cdid.good())
+			m_uiFlags |= CDD_DATA_NOT_FOUND;
+			
+		cdtrack.open((g_strDataPath + "/" + CDTRACKFILE).c_str());
+		if (!cdtrack.good())
+			m_uiFlags |= HIERARCHY_DATA_NOT_FOUND;
+			
+		clstlink.open((g_strDataPath + "/" + CLSTLINKFILE).c_str());
+		if (!clstlink.good())
+			m_uiFlags |= CLUSTER_LINK_NOT_FOUND;
+			
+		cddannot.open((g_strDataPath + "/" + SPFEATFILE).c_str());
+		if (!cddannot.good())
+			m_uiFlags |= FEATURE_DATA_NOT_FOUND;
+		
+		cddannot_gen.open((g_strDataPath + "/" + GENFEATFILE).c_str());
+		if (!cddannot_gen.good())
+			m_uiFlags |= GENERIC_FEATURE_DATA_NOT_FOUND;
+			
+		spthr.open((g_strDataPath + "/" + MINBSCOREFILE).c_str());
+		if (!spthr.good())
+			m_uiFlags |= SPTHRESHOLD_DATA_NOT_FOUND;
+	}
+	else
+	{
+		cdid.open(CDIDFILE);
+		if (!cdid.good())
+			m_uiFlags |= CDD_DATA_NOT_FOUND;
+			
+		cdtrack.open(CDTRACKFILE);
+		if (!cdtrack.good())
+			m_uiFlags |= HIERARCHY_DATA_NOT_FOUND;
+			
+		clstlink.open(CLSTLINKFILE);
+		if (!clstlink.good())
+			m_uiFlags |= CLUSTER_LINK_NOT_FOUND;
+			
+		cddannot.open(SPFEATFILE);
+		if (!cddannot.good())
+			m_uiFlags |= FEATURE_DATA_NOT_FOUND;
+		
+		cddannot_gen.open(GENFEATFILE);
+		if (!cddannot_gen.good())
+			m_uiFlags |= GENERIC_FEATURE_DATA_NOT_FOUND;
+			
+		spthr.open(MINBSCOREFILE);
+		if (!spthr.good())
+			m_uiFlags |= SPTHRESHOLD_DATA_NOT_FOUND;
+	}
+	
+	if (m_uiFlags > 0)
+	{
+		cdid.close();
+		cdtrack.close();
+		clstlink.close();
+		cddannot.close();
+		cddannot_gen.close();
+		spthr.close();
+		return;
+	}
+	
+	x_LoadData(cdid, cdtrack, clstlink, cddannot, cddannot_gen, spthr);
+	
+	cdid.close();
+	cdtrack.close();
+	clstlink.close();
+	cddannot.close();
+	cddannot_gen.close();
+	spthr.close();
+}
+
+void COflDomClstInfo::LoadData(const CNcbiRegistry &reg)
+{
+
+	// -- check everything and see if ok                                
+	m_uiFlags = 0;
+	
+	ifstream cdid, cdtrack, clstlink, cddannot, cddannot_gen, spthr;
+	
+	if (!g_strDataPath.empty())
+	{
+		cdid.open((g_strDataPath + "/" + CDIDFILE).c_str());
+		if (!cdid.good())
+			m_uiFlags |= CDD_DATA_NOT_FOUND;
+			
+		cdtrack.open((g_strDataPath + "/" + CDTRACKFILE).c_str());
+		if (!cdtrack.good())
+			m_uiFlags |= HIERARCHY_DATA_NOT_FOUND;
+			
+		clstlink.open((g_strDataPath + "/" + CLSTLINKFILE).c_str());
+		if (!clstlink.good())
+			m_uiFlags |= CLUSTER_LINK_NOT_FOUND;
+			
+		cddannot.open((g_strDataPath + "/" + SPFEATFILE).c_str());
+		if (!cddannot.good())
+			m_uiFlags |= FEATURE_DATA_NOT_FOUND;
+		
+		cddannot_gen.open((g_strDataPath + "/" + GENFEATFILE).c_str());
+		if (!cddannot_gen.good())
+			m_uiFlags |= GENERIC_FEATURE_DATA_NOT_FOUND;
+		
+		spthr.open((g_strDataPath + "/" + MINBSCOREFILE).c_str());
+		if (!spthr.good())
+			m_uiFlags |= SPTHRESHOLD_DATA_NOT_FOUND;
+	}
+	else
+	{
+		cdid.open(reg.Get(DATAPATH, CDDIDS).c_str());
+		if (!cdid.good())
+			m_uiFlags |= CDD_DATA_NOT_FOUND;
+			
+		cdtrack.open(reg.Get(DATAPATH, CDTRACKINFO).c_str());
+		if (!cdtrack.good())
+			m_uiFlags |= HIERARCHY_DATA_NOT_FOUND;
+			
+		clstlink.open(reg.Get(DATAPATH, CLUSTERLINKS).c_str());
+		if (!clstlink.good())
+			m_uiFlags |= CLUSTER_LINK_NOT_FOUND;
+		
+		cddannot.open(reg.Get(DATAPATH, FEATURES).c_str());
+		if (!cddannot.good())
+			m_uiFlags |= FEATURE_DATA_NOT_FOUND;
+		
+		cddannot_gen.open(reg.Get(DATAPATH, GENERIC_FEATURES).c_str());
+		if (!cddannot_gen.good())
+			m_uiFlags |= GENERIC_FEATURE_DATA_NOT_FOUND;
+		
+		spthr.open(reg.Get(DATAPATH, SPECIFICTHRESHOLDS).c_str());
+		if (!spthr.good())
+			m_uiFlags |= SPTHRESHOLD_DATA_NOT_FOUND;
+	}
+	
+	if (m_uiFlags > 0)
+	{
+		cdid.close();
+		cdtrack.close();
+		clstlink.close();
+		cddannot.close();
+		cddannot_gen.close();
+		spthr.close();
+		return;
+	}
+	
+	x_LoadData(cdid, cdtrack, clstlink, cddannot, cddannot_gen, spthr);
+	
+	cdid.close();
+	cdtrack.close();
+	clstlink.close();
+	cddannot.close();
+	cddannot_gen.close();
+	spthr.close();
+	
+}
+
+
+/**********************************************************************
+*	Biodata structure -- sequence alignments
+***********************************************************************/
+struct TOflAlignInfo
+{
+	enum EIndex
+	{
+		eEnumStart = 0,
+		// ------------------
+		SORT_BY_EVALUE = eEnumStart,
+		SORT_BY_BITSCORE,
+		SORT_BY_SEQ_IDENTITY,
+		SORT_BY_ALIGNED_LENGTH,
+		
+		// ------------------
+		eEnumStop
+	};
+	
+	
+	static const EIndex eDefault = SORT_BY_EVALUE;
+	static const char* dimLits[eEnumStop];
+	static const char* dimLabels[eEnumStop];
+	
+	typedef bool LPFN_COMPARE(const TOflAlignInfo *p1, const TOflAlignInfo *p2);
+	
+	static bool EValueCompare(const TOflAlignInfo *p1, const TOflAlignInfo *p2)
+	{
+		return p1->m_dEValue < p2->m_dEValue;
+	}
+	
+	static bool BitScoreCompare(const TOflAlignInfo *p1, const TOflAlignInfo *p2)
+	{
+		return p1->m_dBitScore > p2->m_dBitScore;
+	}
+	
+	static bool AlignedLengthCompare(const TOflAlignInfo *p1, const TOflAlignInfo *p2)
+	{
+		return p1->m_uiAlignedLen > p2->m_uiAlignedLen;
+	}
+	
+	static bool SeqIdentityCompare(const TOflAlignInfo *p1, const TOflAlignInfo *p2)
+	{
+		return p1->m_dSeqIdentity > p2->m_dSeqIdentity;
+	}
+	
+	struct TSortObj
+	{
+		TSortObj(LPFN_COMPARE lpfnCompare): m_lpfnCompare(lpfnCompare) {};
+		TSortObj(int iSortIdx);
+		LPFN_COMPARE * GetCompareFunc(void) const {return m_lpfnCompare;}
+		
+		bool operator () (const TOflAlignInfo *p1, const TOflAlignInfo *p2)
+		{
+			return m_lpfnCompare(p1, p2);
+		}
+		
+		LPFN_COMPARE *m_lpfnCompare;
+	};
+	
+	// -- scores
+	unsigned int m_uiAlignedLen;
+	double m_dAlignedPct;
+	int m_iScore;
+	double m_dEValue;
+	double m_dBitScore;
+	int m_iNumIdent;
+	double m_dSeqIdentity;
+	
+	// -- added 6/27/2011 -- for na aligns
+	enum EAlignType
+	{
+		eNormal,	//Na to Na or prot to prot
+		ePr2Na
+	} m_eAlignType;
+	// -- added 6-23-2011: for NA search
+	//enum ENa_strand NCBI_PACKED_ENUM_TYPE( unsigned char )
+	//{
+    //	eNa_strand_unknown  =   0,
+    //	eNa_strand_plus     =   1,
+    //	eNa_strand_minus    =   2,
+    //	eNa_strand_both     =   3,  ///< in forward orientation
+    //	eNa_strand_both_rev =   4,  ///< in reverse orientation
+    //	eNa_strand_other    = 255
+	//} NCBI_PACKED_ENUM_END();
+	ENa_strand m_eStrand;
+	int m_iReadingFrame;	//seqlen << 2 | (abs(rf) - 1)
+	//int m_iSlaveCoordConvert;	//a slave coordination conversion factor for negative factor
+	
+	// -- processed align info
+	vector<int> m_vecMStarts;
+	vector<int> m_vecSStarts;
+	vector<unsigned int> m_vecLens;
+	int m_iRegionIdx;	//region on the query sequence. 
+	
+	CSegSet m_ClipSet;
+	// -- methods
+	TOflAlignInfo(void);
+	
+	
+	void Pr2NaConvert(CSegSet &segset) const;
+	void MapSegSet(CSegSet &segset, bool doConvert = true) const;
+	void CalcMasterGaps(unsigned int gapThreshold, CSegSet &segset) const;
+	
+	int GetRFIdx(void) const;
+	
+	int NAPlus2Pr(int na) const {return na / RF_SIZE;}
+	int Pr2NAPlus(int pr) const	{return pr * RF_SIZE + (m_iReadingFrame & RF_SIZE);}
+	int NAMinus2Pr(int na) const {return ((m_iReadingFrame >> 2) - na - 1) / RF_SIZE;}
+	int Pr2NAMinus(int pr) const {return (m_iReadingFrame >> 2) - pr * RF_SIZE - (m_iReadingFrame & RF_SIZE) - 1;}
+	
+	//protein coord in pr, return true if plus strand, false if minus strand
+	bool NA2Pr(int na, int &pr) const;
+	bool Pr2NA(int pr, int &na) const;
+
+};
+
+const char * TOflAlignInfo::dimLits[] = {"evalue", "bitscore", "seqidentity", "alignedlen"};
+const char * TOflAlignInfo::dimLabels[] = {"BLAST E-value", "BLAST bit score", "Sequence Identity", "Aligned Length"};
+TOflAlignInfo::TSortObj::TSortObj(int iSortIdx):
+	m_lpfnCompare(TOflAlignInfo::EValueCompare)
+{
+	switch (iSortIdx)
+	{
+		case TOflAlignInfo::SORT_BY_BITSCORE:
+			m_lpfnCompare = TOflAlignInfo::BitScoreCompare;
+			break;
+		case TOflAlignInfo::SORT_BY_SEQ_IDENTITY:
+			m_lpfnCompare = TOflAlignInfo::SeqIdentityCompare;
+			break;
+		case TOflAlignInfo::SORT_BY_ALIGNED_LENGTH:
+			m_lpfnCompare = TOflAlignInfo::AlignedLengthCompare;
+			break;
+		default:;
+	}
+}
+
+TOflAlignInfo::TOflAlignInfo(void):
+	m_uiAlignedLen(0), m_dAlignedPct(0.0), m_iScore(0), m_dEValue(0.0), m_dBitScore(0.0), m_iNumIdent(0), m_dSeqIdentity(0.0), m_eAlignType(eNormal), m_eStrand(eNa_strand_unknown), m_iReadingFrame(0), /*m_iSlaveCoordConvert(-1), */m_vecMStarts(), m_vecSStarts(), m_vecLens(), m_iRegionIdx(0), m_ClipSet()
+{}
+
+void TOflAlignInfo::Pr2NaConvert(CSegSet &segset) const
+{
+
+	if (ePr2Na == m_eAlignType)
+	{
+		
+		segset.m_iFactor *= RF_SIZE;
+		
+		if ((m_iReadingFrame >> 2) > 0)	//is minus
+		{
+			for (TSegs::iterator iterSeg = segset.m_lstContainer.begin(); iterSeg != segset.m_lstContainer.end(); ++iterSeg)
+			{
+				
+				int newFrom = Pr2NAMinus(iterSeg->from);
+				iterSeg->from = Pr2NAMinus(iterSeg->to) - RF_SIZE + 1;
+				iterSeg->to = newFrom;
+				EResidueExtension oriLext = iterSeg->lext;
+				iterSeg->lext = iterSeg->rext;
+				iterSeg->rext = oriLext;
+				
+				// -- reverse ori_as well
+				iterSeg->ori_from += (iterSeg->to - iterSeg->from) / segset.m_iFactor;
+				
+			}
+			segset.m_iFactor = -segset.m_iFactor;
+			segset.m_lstContainer.reverse();
+		}
+		else	//plus strand
+		{
+			for (TSegs::iterator iter = segset.m_lstContainer.begin(); iter != segset.m_lstContainer.end(); ++iter)
+			{
+				iter->from = Pr2NAPlus(iter->from);
+				iter->to = Pr2NAPlus(iter->to) + RF_SIZE - 1;
+			}
+		}
+	}
+}
+
+void TOflAlignInfo::MapSegSet(CSegSet &segset, bool doConvert) const
+{
+	if (segset.IsEmpty()) return;
+	
+	TSegs::iterator iter = segset.m_lstContainer.begin();
+	size_t idx = 0;
+	
+	while (iter != segset.m_lstContainer.end())
+	{
+		if (idx >= m_vecLens.size() || m_vecSStarts[idx] > iter->to)	// discard this seg
+		{
+			TSegs::iterator temp = iter;
+			++iter;
+			segset.m_lstContainer.erase(temp);
+		}
+		else
+		{
+			int diff = m_vecSStarts[idx] - m_vecMStarts[idx];
+			int end = m_vecSStarts[idx] + m_vecLens[idx] - 1;
+			if (end >= iter->to)
+			{
+				if (iter->from < m_vecSStarts[idx])	//segment shrinked from left. deal with ori_from
+				{
+					iter->ori_from += (m_vecSStarts[idx] - iter->from) / segset.m_iFactor;
+					iter->from = m_vecSStarts[idx];
+				}
+			
+				if (end == iter->to)	//seg happens to end at aligned seg
+					++idx;	//here is the chance to advance idx
+				
+				
+				// -- mapping
+				iter->from -= diff;
+				iter->to -= diff;
+				
+				++iter;
+			}
+			else if (end >= iter->from)	//end < iter->to
+			{
+				TSeg temp(iter->from, end, iter->lext, eAccurate);
+				temp.ori_from = iter->ori_from;
+				
+				if (temp.from < m_vecSStarts[idx])
+				{
+					temp.ori_from += (m_vecSStarts[idx] - temp.from) / segset.m_iFactor;
+					temp.from = m_vecSStarts[idx];
+					temp.lext = eAccurate;
+				}
+				
+				// -- mapping
+				temp.from -= diff;
+				temp.to -= diff;
+				segset.m_lstContainer.insert(iter, temp);
+				
+				// -- cut original seg for next round
+				iter->ori_from += (end - iter->from + 1) / segset.m_iFactor;
+				iter->from = end + 1;
+				//iter->ori_from += (iter->from) / segset.m_iFactor;
+				iter->lext = eAccurate;
+				++idx;
+			}
+			else	//end < iter->from, step to next denseg
+				++idx;
+		}
+	}
+	if (doConvert) Pr2NaConvert(segset);
+}
+
+void TOflAlignInfo::CalcMasterGaps(unsigned int gapThreshold, CSegSet &segset) const
+{
+	segset.Clear();
+	if (!m_vecLens.empty())
+	{
+		size_t segs = m_vecLens.size();
+		for (size_t i = 0; i < segs - 1; ++i)
+		{
+			int gapstart = m_vecMStarts[i] + (int)m_vecLens[i];
+			int gaplen = m_vecMStarts[i + 1] - gapstart;
+			
+			if (gaplen >= (int)gapThreshold)	//consider a gap
+				segset.AddSeg(gapstart, gapstart + gaplen - 1);
+		}
+	}
+}
+
+int TOflAlignInfo::GetRFIdx(void) const
+{
+	int rfAbs = m_iReadingFrame & RF_SIZE;	//0, 1, 2
+	if (m_iReadingFrame >> 2 > 0)	//minus chain
+	{
+
+		return rfAbs + RF_SIZE;
+	}
+	return rfAbs;
+}
+
+bool TOflAlignInfo::NA2Pr(int na, int &pr) const
+{
+	int len = m_iReadingFrame >> 2;
+	if (len > 0)	//minus strand
+	{
+		pr = (len - na - 1) / 3;
+		return false;
+	}
+	pr = na / 3;
+	return true;
+}
+
+bool TOflAlignInfo::Pr2NA(int pr, int &na) const
+{
+	int len = m_iReadingFrame >> 2;
+	if (len > 0)
+	{
+		na = len - pr * 3 - (m_iReadingFrame & RF_SIZE) - 1;
+		return false;
+	}
+	na = pr * 3 + (m_iReadingFrame & RF_SIZE);
+	return true;
+}
+
+
+
+struct TOflCDAlignInfo: public TOflAlignInfo
+{
+	static const TSeqPos GAP_THRESHOLD = 35;
+	unsigned int m_uiPSSMID;
+	// -- calculated
+	int m_iFrom;
+	int m_iTo;
+	double m_dNMissing;
+	double m_dCMissing;
+	bool m_bSpecQualified;	//higher bitscore than threshold
+	int m_iRepClass;	//single and multi -- sort separately
+	bool m_bRep;
+	bool m_bLifted;	//lifted by a higher evalue and approved by architecture frequencs
+	
+	TOflCDAlignInfo(void);
+	
+	//virtual CJSVar CreateJsonNode(int opts = 0) const;
+	
+	// -- including properly mapped features
+	
+	// -- extra
+	bool IsSpecific(void) const {return m_bRep && m_bSpecQualified;}
+	
+	// -- map a feature to dst. return 0: success. Return 1: not all
+	// -- essential residues are mapped. return 2: residue type
+	// -- mismatch (if seqData is not empty)
+	
+	// -- convert segs (master coordinates already) to translated cooridinates so TOflCDFeat can perform motif check.
+	// -- return reading frame for the alignment, which can be used to select a translation frame index (0 - 5). if 
+	// -- return 0 for protein sequence that needs no translation.
+	int GetTranslatedPosMap(const CSegSet &segs, vector<CSegSet::TResiduePos> &rMappedAAPos) const;
+};
+
+TOflCDAlignInfo::TOflCDAlignInfo(void):
+	TOflAlignInfo(), m_uiPSSMID(0), m_iFrom(0), m_iTo(0), m_dNMissing(0.0), m_dCMissing(0.0), m_bSpecQualified(false), m_iRepClass(0), m_bRep(false), m_bLifted(false)
+{}
+
+
+
+// -- segs are already mapped to master sequence. this is to convert to traslated coordinates. return reading frame index (0-5)
+int TOflCDAlignInfo::GetTranslatedPosMap(const CSegSet &segs, vector<CSegSet::TResiduePos> &rMappedAAPos) const
+{
+	rMappedAAPos.clear();
+	segs.GetTranslatedPosMap(m_iReadingFrame >> 2, rMappedAAPos);
+	if (ePr2Na == m_eAlignType)	//needs translation
+		return GetRFIdx();
+	else
+		return 0;
+	
+	
+	//rMappedAAPos.clear();
+	//if (ePr2Na == m_eAlignType)	//needs translation
+	//{
+	//	segs.GetOriSimplePosMap(rMappedAAPos);
+	//	int seqLen = m_iReadingFrame >> 2;
+	//	if (seqLen > 0)
+	//	{
+	//		for (size_t i = 0, len = rMappedAAPos.size(); i < len; ++i)
+	//			rMappedAAPos[i].curr = (seqLen - rMappedAAPos[i].curr - 1) / RF_SIZE;
+	//		return GetRFIdx();	//isplus = false
+	//	}
+	//	else
+	//	{
+	//		for (size_t i = 0, len = rMappedAAPos.size(); i < len; ++i)
+	//			rMappedAAPos[i].curr /= RF_SIZE;
+	//		return GetRFIdx();	//isplus = true
+	//	}
+	//}
+	//else
+	//	segs.GetSimplePosMap(rMappedAAPos);
+	//	
+	//return 0;
+		
+}
+
+/**********************************************************************
+*	Biodata structure -- Align index
+***********************************************************************/
+struct TOflAlignIndice
+{
+	struct __TOflAlignRecord
+	{
+		const TOflCDAlignInfo * pAlign;
+		const TOflCDInfo * pCDInfo;
+		const TOflClusterInfo * pClst;
+		const TOflCDInfo * pRootCDInfo;
+		
+		//const CDomainInfoMaps::TCuratedClusterInfo * pCuratedClst;
+		size_t idx;	//need to give area id an index to align info
+		size_t idxidx;	//the index in concise
+		
+		__TOflAlignRecord(void): pAlign(nullptr), pCDInfo(nullptr), pClst(nullptr), pRootCDInfo(nullptr), idx(-1), idxidx(-1) {};
+	};
+	
+	
+	vector<size_t> m_vecSortedIndice;
+	vector<size_t> m_vecConciseIndice;
+	vector<size_t> m_vecStdIndice;
+	// -- modified 5/8/2012 -- now feature and rep hits are separated -- since we introduced non-NCBI-curated specific hits
+	vector<size_t> m_vecQualifiedFeatIndice;	//should be every region's best evalue curated
+	// -- modified 9/8/2014 -- Structure domains to add motif annotations
+	vector<size_t> m_vecSDIndice;
+	
+	TOflAlignIndice(void): m_vecSortedIndice(), m_vecConciseIndice(), m_vecStdIndice(), m_vecQualifiedFeatIndice(), m_vecSDIndice() {};
+
+	void CreateRecordSets(const vector<TOflCDAlignInfo> &rAlignments, const COflDomClstInfo & rDomInfo, vector<__TOflAlignRecord> &rDomAligns, vector<__TOflAlignRecord> &rFeatAligns, int mode) const;
+	void ExtractFeatAligns(const __TOflAlignRecord &rRepRec, const vector<TOflCDAlignInfo> &rAlignments, const COflDomClstInfo & rDomInfo, vector<__TOflAlignRecord> &rResult) const;
+};
+
+void TOflAlignIndice::CreateRecordSets(const vector<TOflCDAlignInfo> &rAlignments, const COflDomClstInfo & rDomInfo, vector<__TOflAlignRecord> &rDomAligns, vector<__TOflAlignRecord> &rFeatAligns, int mode) const
+{
+	rDomAligns.clear();
+	rFeatAligns.clear();
+	
+	size_t featIdx0 = 0;
+	size_t amendCount = 0;
+	size_t ccsBase = m_vecConciseIndice.size();
+
+
+	if (TDataModes::e_rep == mode)	//all rep
+	{
+		for (size_t iidx = 0, iidxEnd = m_vecConciseIndice.size(); iidx < iidxEnd; ++iidx)
+		{
+			__TOflAlignRecord alignRec;
+			alignRec.pAlign = &(rAlignments[m_vecConciseIndice[iidx]]);
+			alignRec.pCDInfo = rDomInfo.FindCDInfo(alignRec.pAlign->m_uiPSSMID);
+			if (alignRec.pCDInfo->m_uiClusterPSSMID > 0) alignRec.pClst = rDomInfo.FindClusterInfo(alignRec.pCDInfo->m_uiClusterPSSMID);
+			if (alignRec.pCDInfo->m_uiHierarchyRoot > 0)
+			{
+				if (alignRec.pCDInfo->m_uiHierarchyRoot == alignRec.pAlign->m_uiPSSMID) alignRec.pRootCDInfo = alignRec.pCDInfo;
+				else alignRec.pRootCDInfo = rDomInfo.FindCDInfo(alignRec.pCDInfo->m_uiHierarchyRoot);
+			}
+			alignRec.idx = m_vecConciseIndice[iidx];
+			alignRec.idxidx = iidx;
+
+			if (0 == alignRec.pAlign->m_iRepClass)	//non-multi
+			{
+				ExtractFeatAligns(alignRec, rAlignments, rDomInfo, rFeatAligns);
+				
+				size_t featIdx1 = rFeatAligns.size();
+		    	
+				for (size_t i = featIdx0; i < featIdx1; ++i)
+				{
+					if (rFeatAligns[i].idx == alignRec.idx)
+						rFeatAligns[i].idxidx = alignRec.idxidx;
+					else
+						rFeatAligns[i].idxidx = iidxEnd + amendCount++;
+				}
+				
+				featIdx0 = featIdx1;
+			}
+			
+			rDomAligns.push_back(alignRec);
+		}
+	}
+	else	//non-concise 
+	{
+		size_t repIdx = 0;
+		
+		size_t featIdx0 = 0;
+		size_t amendCount = 0;
+		
+		const vector<size_t> &nonConciseIdx = (TDataModes::e_full == mode ? m_vecSortedIndice : m_vecStdIndice);
+		
+		for (size_t iidx = 0, iidxEnd = nonConciseIdx.size(); iidx < iidxEnd; ++iidx)
+		{
+			__TOflAlignRecord alignRec;
+			alignRec.pAlign = &(rAlignments[nonConciseIdx[iidx]]);
+			alignRec.pCDInfo = rDomInfo.FindCDInfo(alignRec.pAlign->m_uiPSSMID);
+
+
+			if (alignRec.pCDInfo->m_uiClusterPSSMID > 0) alignRec.pClst = rDomInfo.FindClusterInfo(alignRec.pCDInfo->m_uiClusterPSSMID);
+			if (alignRec.pCDInfo->m_uiHierarchyRoot > 0)
+			{
+				if (alignRec.pCDInfo->m_uiHierarchyRoot == alignRec.pAlign->m_uiPSSMID) alignRec.pRootCDInfo = alignRec.pCDInfo;
+				else alignRec.pRootCDInfo = rDomInfo.FindCDInfo(alignRec.pCDInfo->m_uiHierarchyRoot);
+			}
+			alignRec.idx = nonConciseIdx[iidx];
+			alignRec.idxidx = -1;
+			if (alignRec.pAlign->m_bRep)
+			{
+				alignRec.idxidx = repIdx++;
+				if (0 == alignRec.pAlign->m_iRepClass)	//non-multi
+				{
+					ExtractFeatAligns(alignRec, rAlignments, rDomInfo, rFeatAligns);
+					size_t featIdx1 = rFeatAligns.size();
+		    	
+					for (size_t i = featIdx0; i < featIdx1; ++i)
+					{
+						if (rFeatAligns[i].idx == alignRec.idx)
+							rFeatAligns[i].idxidx = alignRec.idxidx;
+						else
+							rFeatAligns[i].idxidx = ccsBase + amendCount++;
+					}
+					featIdx0 = featIdx1;
+				}
+			}
+			rDomAligns.push_back(alignRec);
+		}
+	}
+	
+	// -- added 9/9/2014 handling structure motifs -- attach to 
+	for (size_t iidx = 0, iidxEnd = m_vecSDIndice.size(); iidx < iidxEnd; ++iidx)
+	{
+		__TOflAlignRecord rec;
+		
+		rec.idx = m_vecSDIndice[iidx];
+		
+		rec.pAlign =  &(rAlignments[rec.idx]);
+		
+		rec.pCDInfo = rDomInfo.FindCDInfo(rec.pAlign->m_uiPSSMID);
+		
+		rec.pClst = NULL;
+		
+		rec.pRootCDInfo = NULL;
+		
+		rec.idxidx = ccsBase + amendCount++;
+		
+		rFeatAligns.push_back(rec);
+	}
+}
+
+
+void TOflAlignIndice::ExtractFeatAligns(const __TOflAlignRecord &rRepRec, const vector<TOflCDAlignInfo> &rAlignments, const COflDomClstInfo & rDomInfo, vector<__TOflAlignRecord> &rResult) const
+{
+
+
+	__TOflAlignRecord rec;
+	if (rRepRec.pCDInfo->m_uiClusterPSSMID > 0)	//has cluster, do cluster match
+	{
+		for (size_t fiidx = 0, fiidxEnd = m_vecQualifiedFeatIndice.size(); fiidx < fiidxEnd; ++fiidx)
+		{
+			rec.pAlign = &(rAlignments[m_vecQualifiedFeatIndice[fiidx]]);
+			if (rec.pAlign->m_iRegionIdx == rRepRec.pAlign->m_iRegionIdx)	//region match
+			{
+				rec.pCDInfo = rDomInfo.FindCDInfo(rec.pAlign->m_uiPSSMID);
+				if (rec.pCDInfo->m_uiClusterPSSMID == rRepRec.pCDInfo->m_uiClusterPSSMID)	//matched cluster
+				{
+					rec.pClst = rRepRec.pClst;
+					rec.idx = m_vecQualifiedFeatIndice[fiidx];
+					//rec.idxidx = FeatIdx2Iidx(rec.idx);
+					if (rec.pCDInfo->m_uiHierarchyRoot > 0)
+					{
+						if (rec.pCDInfo->m_uiHierarchyRoot == rec.pAlign->m_uiPSSMID) rec.pRootCDInfo = rec.pCDInfo;
+						else rec.pRootCDInfo = rDomInfo.FindCDInfo(rec.pCDInfo->m_uiHierarchyRoot);
+					}
+					rResult.push_back(rec);
+				}
+			}
+		}
+	}
+	else	//no cluster, just match region class -- should not happen
+	{
+		for (size_t fiidx = 0, fiidxEnd = m_vecQualifiedFeatIndice.size(); fiidx < fiidxEnd; ++fiidx)
+		{
+			rec.pAlign = &(rAlignments[m_vecQualifiedFeatIndice[fiidx]]);
+			if (rec.pAlign->m_iRegionIdx == rRepRec.pAlign->m_iRegionIdx)	//region match
+			{
+				rec.pCDInfo = rDomInfo.FindCDInfo(rec.pAlign->m_uiPSSMID);
+				rec.pClst = rDomInfo.FindClusterInfo(rec.pCDInfo->m_uiClusterPSSMID);
+				if (rec.pCDInfo->m_uiHierarchyRoot > 0)
+				{
+					if (rec.pCDInfo->m_uiHierarchyRoot == rec.pAlign->m_uiPSSMID) rec.pRootCDInfo = rec.pCDInfo;
+					else rec.pRootCDInfo = rDomInfo.FindCDInfo(rec.pCDInfo->m_uiHierarchyRoot);
+				}
+				rec.idx = m_vecQualifiedFeatIndice[fiidx];
+				//rec.idxidx = FeatIdx2Iidx(rec.idx);
+				rResult.push_back(rec);
+			}
+		}
+	}
+}
+
+/**********************************************************************
+*	Biodata structure -- Sequence information
+***********************************************************************/
+struct TOflSeqInfo
+{
+	int m_iGi;
+	string m_strQueryID;
+	unsigned int m_uiSeqLen;	//length of original sequence, could be na
+	bool m_bIsProtein;
+	string m_strDefline;
+	string m_strMessage;
+	
+	string m_dimTranslated[TOTAL_RFS];
+	
+	TOflSeqInfo(void): m_iGi(0), m_strQueryID(k_strEmptyString), m_uiSeqLen(0), m_bIsProtein(true), m_strDefline(k_strEmptyString), m_strMessage(k_strEmptyString) {};
+
+	void Get1LtrSeq(string &dst) const;
+	size_t Translate(const TOflAlignInfo& alignInfo, string &dst) const;
+	unsigned int GetSeqLength(void) const {return m_uiSeqLen;}
+	
+	// -- internals
+	void NACommit(void);
+	void PRCommit(void);
+};
+
+void TOflSeqInfo::Get1LtrSeq(string &dst) const
+{
+	dst.clear();
+	if (m_bIsProtein) dst = m_dimTranslated[0];
+	else dst.append(m_uiSeqLen, 'N');
+}
+
+size_t TOflSeqInfo::Translate(const TOflAlignInfo& alignInfo, string &dst) const
+{
+	dst = m_dimTranslated[alignInfo.GetRFIdx()];
+	return m_uiSeqLen;
+}
+
+void TOflSeqInfo::NACommit(void)
+{
+	m_bIsProtein = false;
+	size_t aaLen = m_uiSeqLen / 3;
+	
+	m_dimTranslated[0].clear();
+	m_dimTranslated[0].append(aaLen, '-');
+	
+	m_dimTranslated[3] = m_dimTranslated[0];
+	
+	aaLen = (m_uiSeqLen - 1) / 3;
+	
+	m_dimTranslated[1].clear();
+	m_dimTranslated[1].append(aaLen, '-');
+	
+	m_dimTranslated[4] = m_dimTranslated[1];
+	
+	aaLen = (m_uiSeqLen - 2) / 3;
+	
+	m_dimTranslated[2].clear();
+	m_dimTranslated[2].append(aaLen, '-');
+	m_dimTranslated[5] = m_dimTranslated[2];
+}
+
+void TOflSeqInfo::PRCommit(void)
+{
+	m_bIsProtein = true;
+	m_dimTranslated[0].clear();
+	m_dimTranslated[0].append(m_uiSeqLen, '-');
+}
+
+/**********************************************************************
+*	Biodata structure -- CD Query result - protein and na
+***********************************************************************/
+struct TOflCDQuery: public TOflSeqInfo, public TOflAlignIndice
+{
+	vector<TOflCDAlignInfo> m_vecAlignments;
+	
+	TOflCDQuery(void);
+	
+	void CreateRecordSets(const COflDomClstInfo & rDomInfo, vector<__TOflAlignRecord> &rDomAligns, vector<__TOflAlignRecord> &rFeatAligns, int mode) const;
+	
+	// -- calculate segments from 
+	void ParseAlignStrings(const string &qseq, const string &hseq, int qf, int hf, size_t start, size_t n, TOflCDAlignInfo &dst, int rfidx = 0);
+	
+};
+
+
+
+// -- extend for nucleic acid queries
+struct TOflCdQueryEx: public TOflCDQuery
+{
+	TOflAlignIndice m_dimSplitAligns[TOTAL_RFS];
+	TOflCdQueryEx(void): TOflCDQuery(), m_dimSplitAligns() {};
+	
+	//void CreateRecordSetsEx(int rfidx, const COflDomClstInfo & rDomInfo, vector<__TOflAlignRecord> &rDomAligns, vector<__TOflAlignRecord> &rFeatAligns, bool bConcise = true) const;
+	void CreateRecordSetsEx(int rfidx, const COflDomClstInfo & rDomInfo, vector<__TOflAlignRecord> &rDomAligns, vector<__TOflAlignRecord> &rFeatAligns, int mode) const;
+	size_t CollectCdQueries(list<TOflCDQuery> &dst) const;
+		
+	void ProcessQueryResult(CRef< CIteration > refOflQueryResult, double evcut = 0.01);
+		
+	void Print(int idxBlObj, const COflDomClstInfo &domInfo, ostream &os, int dmode = TDataModes::e_rep) const;
+};
+
+TOflCDQuery::TOflCDQuery(void):
+	TOflSeqInfo(), TOflAlignIndice(), m_vecAlignments()
+{}
+
+void TOflCDQuery::CreateRecordSets(const COflDomClstInfo & rDomInfo, vector<TOflAlignIndice::__TOflAlignRecord> &rDomAligns, vector<TOflAlignIndice::__TOflAlignRecord> &rFeatAligns, int mode) const
+{
+	TOflAlignIndice::CreateRecordSets(m_vecAlignments, rDomInfo, rDomAligns, rFeatAligns, mode);
+}
+
+void TOflCDQuery::ParseAlignStrings(const string &qseq, const string &hseq, int qf, int hf, size_t start, size_t n, TOflCDAlignInfo &dst, int rfidx)
+{
+	unsigned int segLen = 0;
+	bool bEffSeg = true;
+
+	while (start < n)
+	{
+
+		if (bEffSeg)	//initially, both chains are in effect
+		{
+			if ('-' != qseq[start] && '-' != hseq[start])
+				++segLen;
+			else
+			{
+
+				bEffSeg = false;
+				
+				dst.m_vecMStarts.push_back(qf);
+				dst.m_vecSStarts.push_back(hf);
+				dst.m_vecLens.push_back(segLen);
+				
+				// -- write in master sequence data
+				m_dimTranslated[rfidx].replace(qf, segLen, qseq, start - segLen, segLen);
+				
+				qf += segLen;
+				hf += segLen;
+				segLen = 0;
+				if ('-' == qseq[start])
+					--qf;
+				else
+				{
+					--hf;
+					//write in one more residue
+					m_dimTranslated[rfidx][qf] = qseq[start];
+				}
+			}
+		}
+		else	//not in effective seg
+		{
+			//!bEffSeg
+			bool segStart = true;
+			if ('-' != qseq[start])
+			{
+				++qf;
+				m_dimTranslated[rfidx][qf] = qseq[start];
+			}
+			else
+				segStart = false;
+				
+			if ('-' != hseq[start])
+				++hf;
+			else
+				segStart = false;
+				
+			if ((bEffSeg = segStart)) ++segLen;
+			
+		}
+			
+		++start;
+	}//while
+	// -- last segment
+	if (bEffSeg && segLen > 0)
+	{
+
+		dst.m_vecMStarts.push_back(qf);
+		dst.m_vecSStarts.push_back(hf);
+		dst.m_vecLens.push_back(segLen);
+		
+		m_dimTranslated[rfidx].replace(qf, segLen, qseq, start - segLen, segLen);
+	}
+}
+
+void TOflCdQueryEx::CreateRecordSetsEx(int rfidx, const COflDomClstInfo & rDomInfo, vector<__TOflAlignRecord> &rDomAligns, vector<__TOflAlignRecord> &rFeatAligns, int mode) const
+{
+	m_dimSplitAligns[rfidx].CreateRecordSets(m_vecAlignments, rDomInfo, rDomAligns, rFeatAligns, mode);
+}
+
+size_t TOflCdQueryEx::CollectCdQueries(list<TOflCDQuery> &dst) const
+{
+	dst.clear();
+	size_t total = 0;
+	if (m_bIsProtein)
+	{
+		dst.push_back((const TOflCDQuery &)(*this));
+		return 1;
+	}
+	else	//push as a serious of TOflCDQuery
+	{
+		for (int rf = 0; rf < TOTAL_RFS; ++rf)
+		{
+			if (!m_dimSplitAligns[rf].m_vecSortedIndice.empty())
+			{
+				list<TOflCDQuery> :: iterator iterNewRf = dst.insert(dst.end(), (const TOflCDQuery &)(*this));
+				++total;
+				iterNewRf->m_vecSortedIndice = m_dimSplitAligns[rf].m_vecSortedIndice;
+				iterNewRf->m_vecConciseIndice = m_dimSplitAligns[rf].m_vecConciseIndice;
+				iterNewRf->m_vecStdIndice = m_dimSplitAligns[rf].m_vecStdIndice;
+				iterNewRf->m_strDefline = RF_TITLES[rf];
+				// -- add reading frame id
+			}
+		}
+	}
+	return total;
+}
+
+
+void TOflCdQueryEx::ProcessQueryResult(CRef<CIteration> refOflQueryResult, double evcut)
+{
+	m_vecAlignments.clear();
+	
+	if (refOflQueryResult->CanGetQuery_ID())
+		m_strQueryID = refOflQueryResult->GetQuery_ID();
+	
+	if (refOflQueryResult->CanGetQuery_def())
+		m_strDefline = refOflQueryResult->GetQuery_def();	//length of original sequence, could be na
+	
+	if (!g_bSilent) cerr << "Processing Query " << m_strDefline << endl;
+	
+	if (refOflQueryResult->CanGetQuery_len())
+		m_uiSeqLen = refOflQueryResult->GetQuery_len();	//length of original sequence, could be na
+		
+	
+	if (refOflQueryResult->CanGetMessage())
+		m_strMessage = refOflQueryResult->GetMessage();	//length of original sequence, could be na
+		
+	if (refOflQueryResult->CanGetHits())
+	{
+		const CIteration::THits &hits = refOflQueryResult->GetHits();	//list< CRef< CHit > >
+		if (!hits.empty())
+		{
+
+
+			m_vecAlignments.reserve(hits.size() * 3);	//estimated
+			
+			TOflCDAlignInfo alnVal;
+			
+			for (CIteration::THits::const_iterator iterHit = hits.begin(), iterHitEnd = hits.end(); iterHitEnd != iterHit; ++iterHit)
+			{
+				unsigned int pssmid = (unsigned int)atoi((*iterHit)->GetAccession().c_str());
+				
+				unsigned int cdLen = (*iterHit)->GetLen();
+				const CHit::THsps &hsps = (*iterHit)->GetHsps();	//list< CRef< CHsp > > THsps
+				if (!g_bSilent) cerr << "Domain hit " << pssmid << ", total occurrance = " << hsps.size() << endl;	
+				for (CHit::THsps::const_iterator iterHsp = hsps.begin(), iterHspEnd = hsps.end(); iterHspEnd != iterHsp; ++iterHsp)
+				{
+					double eval = (*iterHsp)->GetEvalue();
+					if (eval > evcut) continue;
+					
+					m_vecAlignments.push_back(alnVal);
+					TOflCDAlignInfo &dst = *m_vecAlignments.rbegin();
+					
+					dst.m_uiPSSMID = pssmid;
+					dst.m_uiAlignedLen = (*iterHsp)->GetAlign_len();
+					dst.m_iScore = (int)((*iterHsp)->GetScore() + 0.5);
+					dst.m_dEValue = eval;
+					dst.m_dBitScore = (*iterHsp)->GetBit_score();
+					dst.m_iNumIdent = (*iterHsp)->GetIdentity();
+					dst.m_dSeqIdentity = (double)dst.m_iNumIdent / (double)cdLen * 100.0;
+					dst.m_iReadingFrame = (*iterHsp)->GetQuery_frame();
+					
+					if (dst.m_iReadingFrame > 1 || dst.m_iReadingFrame < 0)	//na determined
+					{
+						if (m_dimTranslated[0].empty())	//not filled yet
+							NACommit();
+					}
+					
+					
+					dst.m_iFrom = (*iterHsp)->GetQuery_from() - COORDSBASE;
+					dst.m_iTo = (*iterHsp)->GetQuery_to() - COORDSBASE;
+
+					// -- start to parse sequence
+					const string &qseq = (*iterHsp)->GetQseq(), hseq = (*iterHsp)->GetHseq();
+					size_t alnLen = qseq.size(), alnResIdx = 0;	//assume qseq.size() == hseq.size()
+
+					// -- incase of blast problem...
+					while (alnResIdx < alnLen && ('-' == qseq[alnResIdx] || '-' == hseq[alnResIdx])) ++alnResIdx;
+					
+					// -- see if NA
+					if (m_dimTranslated[0].empty())	//not filled yet
+					{
+						int aaRes = 0, t0 = alnResIdx;
+						
+						while (t0 < alnLen)
+						{
+							if ('-' == qseq[t0])
+								++t0;
+							else
+							{
+								size_t t1 = qseq.find('-', t0);
+								if (string::npos == t1)	//
+									t1 = alnLen;
+								aaRes += t1 - t0;
+								t0 = t1 + 1;
+							}
+						}
+						if (aaRes == dst.m_iTo - dst.m_iFrom + 1)
+							PRCommit();
+						else if (aaRes * 3 == dst.m_iTo - dst.m_iFrom + 1)
+							NACommit();
+					}
+					if (m_bIsProtein)
+					{
+						dst.m_iReadingFrame = 0;
+						dst.m_eAlignType = TOflAlignInfo::eNormal;
+						dst.m_eStrand = eNa_strand_unknown;
+						int qfrom = dst.m_iFrom, hfrom = (*iterHsp)->GetHit_from() - COORDSBASE;
+						
+						ParseAlignStrings(qseq, hseq, qfrom, hfrom, alnResIdx, alnLen, dst, 0);
+					}
+					else	//na
+					{
+						// -- calculate 
+						int rfidx = RF2Idx(dst.m_iReadingFrame);
+						dst.m_eAlignType = TOflAlignInfo::ePr2Na;
+
+						if (dst.m_iReadingFrame > 0)	//plus
+						{
+							dst.m_eStrand = eNa_strand_plus;
+							dst.m_iReadingFrame -= 1;	//from 1, 2, 3 to 0, 1 ,2
+							int qfrom = dst.NAPlus2Pr(dst.m_iFrom), hfrom = (*iterHsp)->GetHit_from() - COORDSBASE;
+
+							ParseAlignStrings(qseq, hseq, qfrom, hfrom, alnResIdx, alnLen, dst, rfidx);
+
+						}	//plus strand
+						else	//minus strand
+						{
+							dst.m_eStrand = eNa_strand_minus;
+							// -- squeeze m_uiSeqLen in dst.m_iReadingFrame, rf -1, -2, -3 -> 0, 1, 2
+							dst.m_iReadingFrame = (-dst.m_iReadingFrame - 1) | (m_uiSeqLen << 2);
+							int qfrom = dst.NAMinus2Pr(dst.m_iTo), hfrom = (*iterHsp)->GetHit_from() - COORDSBASE;
+
+							ParseAlignStrings(qseq, hseq, qfrom, hfrom, alnResIdx, alnLen, dst, rfidx);
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+// -- helper function
+void PrintDomLine(ostream &os, const char *pType, const TOflAlignIndice::__TOflAlignRecord &rec)
+{
+	os << pType << DELIMIT << rec.pAlign->m_uiPSSMID << DELIMIT << rec.pAlign->m_iFrom + COORDSBASE << DELIMIT << rec.pAlign->m_iTo + COORDSBASE << DELIMIT << rec.pAlign->m_dEValue << DELIMIT << rec.pAlign->m_dBitScore << DELIMIT << rec.pCDInfo->m_strAccession << DELIMIT << rec.pCDInfo->m_strShortName << DELIMIT;
+	bool bTmMiss = false;
+	if (rec.pAlign->m_dNMissing > 0.2)
+	{
+		os << 'N';
+		bTmMiss = true;
+	}
+	if (rec.pAlign->m_dCMissing > 0.2)
+	{
+		os << 'C';
+		bTmMiss = true;
+	}
+	if (!bTmMiss)
+		os << '-';
+	os << DELIMIT << (NULL == rec.pClst ? '-' :  rec.pCDInfo->m_uiClusterPSSMID);
+}
+
+void PrintClstLine(ostream &os, const TOflAlignIndice::__TOflAlignRecord &rec)
+{
+	os << HITTYPE_CLUSTER << DELIMIT << rec.pCDInfo->m_uiClusterPSSMID << DELIMIT << rec.pAlign->m_iFrom + COORDSBASE << DELIMIT << rec.pAlign->m_iTo + COORDSBASE << DELIMIT << rec.pAlign->m_dEValue << DELIMIT << rec.pAlign->m_dBitScore << DELIMIT << rec.pClst->m_strAccession << DELIMIT << rec.pClst->m_strShortName << DELIMIT;
+	bool bTmMiss = false;
+	if (rec.pAlign->m_dNMissing > 0.2)
+	{
+		os << 'N';
+		bTmMiss = true;
+	}
+	if (rec.pAlign->m_dCMissing > 0.2)
+	{
+		os << 'C';
+		bTmMiss = true;
+	}
+	if (!bTmMiss)
+		os << '-';
+	os << DELIMIT << '-';
+}
+
+struct __MotifType
+{
+	list<TOflCDFeat> :: const_iterator iterMotifFeat;
+	vector<TOflAlignIndice::__TOflAlignRecord> :: const_iterator iterAlignRec;
+	bool bIsSpecific;
+	unsigned int uiSrcPSSMId;
+	__MotifType(list<TOflCDFeat> :: const_iterator iterM, vector<TOflAlignIndice::__TOflAlignRecord> :: const_iterator iterA, bool spec, unsigned int srcpssm): 
+		iterMotifFeat(iterM), iterAlignRec(iterA), bIsSpecific(spec), uiSrcPSSMId(srcpssm) {};
+};
+
+
+void TOflCdQueryEx::Print(int idxBlObj, const COflDomClstInfo &domInfo, ostream &os, int dmode) const
+{
+	os << QUERYSTART << DELIMIT << m_strQueryID << DELIMIT;
+//const char * const QUERY_TYPE_PEPTIDE = "Peptide";
+//const char * const QUERY_TYPE_NUCLEOTIDE = "Nucleotide";
+	if (m_bIsProtein)
+	{
+		os << QUERY_TYPE_PEPTIDE << DELIMIT << m_uiSeqLen << DELIMIT << m_strDefline << endl;
+		vector<TOflAlignIndice::__TOflAlignRecord> vecDomAligns, vecFeatAligns;	//vecDomFams for output of superfamilies of domain hits
+		CreateRecordSets(domInfo, vecDomAligns, vecFeatAligns, dmode);
+		
+		map<int, TOflAlignIndice::__TOflAlignRecord > mapDomFams;
+
+
+		if (TTargetData::e_feats != g_iTargetData)
+		{
+			if (!vecDomAligns.empty())
+			{
+				os << DOMSTART << endl;
+				if (TDataModes::e_rep == dmode)
+				{
+					for (vector<TOflAlignIndice::__TOflAlignRecord> :: const_iterator iterRec = vecDomAligns.begin(), iterRecEnd = vecDomAligns.end(); iterRecEnd != iterRec; ++iterRec)
+					{
+						if (NULL == iterRec->pCDInfo) continue;
+						os << idxBlObj << DELIMIT << m_strQueryID << DELIMIT;
+						if (1 == iterRec->pAlign->m_iRepClass)	//multi, should be no more
+							PrintDomLine(os, HITTYPE_MULTIDOM, *iterRec);
+						else if (iterRec->pAlign->m_bSpecQualified)
+						{
+							PrintDomLine(os, HITTYPE_SPECIFIC, *iterRec);
+							if (NULL != iterRec->pClst)
+							{
+								int key = iterRec->pAlign->m_iRegionIdx * OVERLAPLEADING + iterRec->pCDInfo->m_uiClusterPSSMID;
+								if (mapDomFams.end() == mapDomFams.find(key))
+									mapDomFams.emplace(key, *iterRec);
+							}
+						}
+						else if (NULL != iterRec->pClst)
+							PrintClstLine(os, *iterRec);
+						else	//not qualified for specific, but no cluster -- non-specific
+							PrintDomLine(os, HITTYPE_NONSPECIFIC, *iterRec);
+						os << endl;
+					}	//dom loops end
+				}	//rep mode
+				else	//nonrep mode
+				{
+					for (vector<TOflAlignIndice::__TOflAlignRecord> :: const_iterator iterRec = vecDomAligns.begin(), iterRecEnd = vecDomAligns.end(); iterRecEnd != iterRec; ++iterRec)
+					{
+						if (NULL == iterRec->pCDInfo) continue;
+						os << idxBlObj << DELIMIT << m_strQueryID << DELIMIT;
+						if (1 == iterRec->pAlign->m_iRepClass)	//multi
+							PrintDomLine(os, HITTYPE_MULTIDOM, *iterRec);
+						else if (iterRec->pAlign->m_bRep && iterRec->pAlign->m_bSpecQualified)
+							PrintDomLine(os, HITTYPE_SPECIFIC, *iterRec);
+						else
+							PrintDomLine(os, HITTYPE_NONSPECIFIC, *iterRec);
+						if (NULL != iterRec->pClst)
+						{
+							int key = iterRec->pAlign->m_iRegionIdx * OVERLAPLEADING + iterRec->pCDInfo->m_uiClusterPSSMID;
+							if (mapDomFams.end() == mapDomFams.find(key))
+								mapDomFams.emplace(key, *iterRec);
+						}
+						os << endl;
+					}
+				}
+				
+				os << DOMEND << endl;
+				
+				if (g_bSuperfams)	//user want to see all superfams
+				{
+					os << FAMSTART << endl;
+					for (const auto & v : mapDomFams)
+					{
+						os << idxBlObj << DELIMIT << m_strQueryID << DELIMIT;
+						PrintClstLine(os, v.second);
+						os << endl;
+					}
+					os << FAMEND << endl;
+				}
+			}
+		}
+		
+		if (TTargetData::e_doms != g_iTargetData)
+		{
+			vector<__MotifType> vecMotifRecs;
+			
+			vector<TOflCDQuery::__TOflAlignRecord> :: const_iterator iterFeatAlign = vecFeatAligns.begin(), iterFeatAlignEnd = vecFeatAligns.end();
+			
+			if (iterFeatAlignEnd != iterFeatAlign)	//not empty())
+			{
+				if (!iterFeatAlign->pCDInfo->m_bIsStructDom)	//has regular domains
+				{
+					os << FEATSTART << endl;
+					for ( ; iterFeatAlignEnd != iterFeatAlign; ++iterFeatAlign)
+					{
+						if (iterFeatAlign->pCDInfo->m_bIsStructDom) break;
+							
+						bool bIsSpecific = iterFeatAlign->pAlign->m_bRep && iterFeatAlign->pAlign->m_bSpecQualified;
+						const char * pType = ANNOTTYPE_SPECIFIC;
+						const list <TOflCDFeat> * pFeats = &(iterFeatAlign->pCDInfo->m_lstSpecFeatures);;
+						unsigned int uiSrcPSSMId = iterFeatAlign->pAlign->m_uiPSSMID;
+						
+						if (!bIsSpecific && NULL != iterFeatAlign->pRootCDInfo)
+						{
+							pType = ANNOTTYPE_GENERIC;
+							pFeats = &(iterFeatAlign->pCDInfo->m_lstGenFeatures);
+							uiSrcPSSMId = iterFeatAlign->pCDInfo->m_uiHierarchyRoot;
+						}
+							
+						for (list<TOflCDFeat> :: const_iterator iterFeat = pFeats->begin(); iterFeat != pFeats->end(); ++iterFeat)
+						{
+							if (TOflCDFeat::eType_StructMotif == iterFeat->m_iType)
+							{
+								vecMotifRecs.push_back(__MotifType(iterFeat, iterFeatAlign, bIsSpecific, uiSrcPSSMId));
+								continue;
+							}
+							
+							CSegSet featsegs(*iterFeat);
+							iterFeatAlign->pAlign->MapSegSet(featsegs, false);
+							
+							if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterFeat->GetCompleteSize() > 0.8))
+							{
+								vector<CSegSet::TResiduePos> vecMappedPos;
+								int rfidx = iterFeatAlign->pAlign->GetTranslatedPosMap(featsegs, vecMappedPos);
+    	        	
+								if (iterFeat->MotifCheck(vecMappedPos, m_dimTranslated[rfidx]) > 0) continue;	//failed motif check
+    	        	
+									
+								os << idxBlObj << DELIMIT << m_strQueryID << DELIMIT << pType << DELIMIT << iterFeat->m_strTitle << DELIMIT;
+								
+								const TSegs& segs = featsegs.GetSegs();
+								
+								size_t mapped = 0;
+								
+								char dimDelimit[2] = {0, 0};
+								for (TSegs::const_iterator iterSeg = segs.begin(); iterSeg != segs.end(); ++iterSeg)
+								{
+									for (int res = iterSeg->from; res <= iterSeg->to; ++res)
+									{
+										os << dimDelimit << (char)toupper(m_dimTranslated[rfidx][res]) << (res + COORDSBASE);
+										dimDelimit[0] = COORDELIMIT;
+										++mapped;
+									}
+								}
+								os << DELIMIT << iterFeat->GetTotalResidues() << DELIMIT << mapped << DELIMIT << uiSrcPSSMId << endl;
+							}
+						}
+					}
+					
+					// -- non-motif features from SD
+					
+					for ( ; iterFeatAlignEnd != iterFeatAlign; ++iterFeatAlign)
+					{
+						//if (iterFeatAlign->pCDInfo->m_bIsStructDom) break;
+							
+						//bool bIsSpecific = iterFeatAlign->pAlign->m_bRep && iterFeatAlign->pAlign->m_bSpecQualified;
+						//const char * pType = ANNOTTYPE_SPECIFIC;
+						//const list <TOflCDFeat> * pFeats = &(iterFeatAlign->pCDInfo->m_lstSpecFeatures);;
+						//unsigned int uiSrcPSSMId = iterFeatAlign->pAlign->m_uiPSSMID;
+						
+						//if (!bIsSpecific && NULL != iterFeatAlign->pRootCDInfo)
+						//{
+						//	pType = ANNOTTYPE_GENERIC;
+						//	pFeats = &(iterFeatAlign->pCDInfo->m_lstGenFeatures);
+						//	uiSrcPSSMId = iterFeatAlign->pCDInfo->m_uiHierarchyRoot;
+						//}
+							
+						for (list<TOflCDFeat> :: const_iterator iterFeat = iterFeatAlign->pCDInfo->m_lstSpecFeatures.begin(); iterFeat != iterFeatAlign->pCDInfo->m_lstSpecFeatures.end(); ++iterFeat)
+						{
+							if (TOflCDFeat::eType_StructMotif == iterFeat->m_iType)
+							{
+								vecMotifRecs.push_back(__MotifType(iterFeat, iterFeatAlign, true, 0));
+								continue;
+							}
+							
+							CSegSet featsegs(*iterFeat);
+							iterFeatAlign->pAlign->MapSegSet(featsegs, false);
+							
+							if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterFeat->GetCompleteSize() > 0.8))
+							{
+								vector<CSegSet::TResiduePos> vecMappedPos;
+								int rfidx = iterFeatAlign->pAlign->GetTranslatedPosMap(featsegs, vecMappedPos);
+    	        	
+								if (iterFeat->MotifCheck(vecMappedPos, m_dimTranslated[rfidx]) > 0) continue;	//failed motif check
+    	        	
+									
+								os << idxBlObj << DELIMIT << m_strQueryID << DELIMIT << ANNOTTYPE_SPECIFIC << DELIMIT << iterFeat->m_strTitle << DELIMIT;
+								
+								const TSegs& segs = featsegs.GetSegs();
+								
+								size_t mapped = 0;
+								
+								char dimDelimit[2] = {0, 0};
+								for (TSegs::const_iterator iterSeg = segs.begin(); iterSeg != segs.end(); ++iterSeg)
+								{
+									for (int res = iterSeg->from; res <= iterSeg->to; ++res)
+									{
+										os << dimDelimit << (char)toupper(m_dimTranslated[rfidx][res]) << (res + COORDSBASE);
+										dimDelimit[0] = COORDELIMIT;
+										++mapped;
+									}
+								}
+								os << DELIMIT << iterFeat->GetTotalResidues() << DELIMIT << mapped << DELIMIT << 0/*iterFeatAlign->pAlign->m_uiPSSMID*/ << endl;
+							}
+						}
+					}
+					
+					os << FEATEND << endl;
+				}
+				
+				// -- Motif part
+				if (!vecMotifRecs.empty())
+				{
+					// -- start SD
+					// -- features
+					os << MOTIFSTART << endl;
+					vector<__MotifType> :: const_iterator iterM = vecMotifRecs.begin(), iterMEnd = vecMotifRecs.end();
+					for ( ; iterMEnd != iterM; ++iterM)
+					{
+						if (iterM->iterAlignRec->pCDInfo->m_bIsStructDom) break;
+							
+						CSegSet featsegs(*iterM->iterMotifFeat);
+						iterM->iterAlignRec->pAlign->MapSegSet(featsegs);
+						
+						if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterM->iterMotifFeat->GetCompleteSize() > 0.8))
+						{
+							os << idxBlObj << DELIMIT << m_strQueryID << DELIMIT << iterM->iterMotifFeat->m_strTitle << DELIMIT;
+							int res0 = featsegs.GetLeft(), res1 = featsegs.GetRight(), rfidx = iterM->iterAlignRec->pAlign->GetRFIdx();
+							os << (char)toupper(m_dimTranslated[rfidx][res0]) << res0 + COORDSBASE << DELIMIT << res1 + COORDSBASE << (char)toupper(m_dimTranslated[rfidx][res1]) << DELIMIT << iterM->uiSrcPSSMId << endl;
+						}
+					}
+					
+					// Motif from SD
+					for ( ; iterMEnd != iterM; ++iterM)
+					{
+						CSegSet featsegs(*iterM->iterMotifFeat);
+						if (!iterM->iterAlignRec->pAlign->m_ClipSet.IsEmpty())
+							featsegs.Cross(iterM->iterAlignRec->pAlign->m_ClipSet);
+						
+						iterM->iterAlignRec->pAlign->MapSegSet(featsegs);
+						
+						if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterM->iterMotifFeat->GetCompleteSize() > 0.8))
+						{
+							os << idxBlObj << DELIMIT << m_strQueryID << DELIMIT << iterM->iterMotifFeat->m_strTitle << DELIMIT;
+							int res0 = featsegs.GetLeft(), res1 = featsegs.GetRight(), rfidx = iterM->iterAlignRec->pAlign->GetRFIdx();
+							os << (char)toupper(m_dimTranslated[rfidx][res0]) << res0 + COORDSBASE << DELIMIT << res1 + COORDSBASE << (char)toupper(m_dimTranslated[rfidx][res1]) << DELIMIT << iterM->uiSrcPSSMId << endl;
+						}
+					}
+					
+					// -- now start SD
+					//for ( ; iterFeatAlignEnd != iterFeatAlign; ++iterFeatAlign)
+					//{
+					//	int rfidx = iterFeatAlign->pAlign->GetRFIdx();
+					//	
+					//	for (list<TOflCDFeat> :: const_iterator iterFeat = iterFeatAlign->pCDInfo->m_lstSpecFeatures.begin(); iterFeat != iterFeatAlign->pCDInfo->m_lstSpecFeatures.end(); ++iterFeat)
+					//	{
+					//		
+					//		CSegSet featsegs(*iterFeat);
+					//		iterFeatAlign->pAlign->MapSegSet(featsegs);
+					//		if (!featsegs.IsEmpty())
+					//		{
+					//			os << idxBlObj << DELIMIT << m_strQueryID << DELIMIT << iterFeat->m_strTitle << DELIMIT;
+					//			//int rfidx = iterFeatAlign->pAlign->GetRFIdx();
+					//			int res0 = featsegs.GetLeft(), res1 = featsegs.GetRight();
+					//			os << (char)toupper(m_dimTranslated[rfidx][res0]) << res0 + COORDSBASE << DELIMIT << res1 + COORDSBASE << (char)toupper(m_dimTranslated[rfidx][res1]) << DELIMIT << '-' << endl;
+					//		}
+					//	}
+					//}
+					
+					os << MOTIFEND << endl;
+				}
+			}
+		}
+	}
+	else	//na
+	{
+		os << QUERY_TYPE_NUCLEOTIDE << DELIMIT << m_uiSeqLen << DELIMIT << m_strDefline << endl;
+		
+		vector<TOflAlignIndice::__TOflAlignRecord> dimDomAligns[TOTAL_RFS], dimFeatVecs[TOTAL_RFS];
+		
+		bool bHasFeats = false, bHasRegFeats = false;
+
+		for (int rfidx = 0; rfidx < TOTAL_RFS; ++rfidx)
+		{
+			CreateRecordSetsEx(rfidx, domInfo, dimDomAligns[rfidx], dimFeatVecs[rfidx], dmode);
+			bHasFeats = bHasFeats || !dimFeatVecs[rfidx].empty();
+			bHasRegFeats = (bHasRegFeats || !(dimFeatVecs[rfidx].empty() || dimFeatVecs[rfidx][0].pCDInfo->m_bIsStructDom));
+		}
+
+		if (TTargetData::e_feats != g_iTargetData)
+		{
+			map<int, TOflAlignIndice::__TOflAlignRecord > dimDomFams[TOTAL_RFS];
+			
+			os << DOMSTART << endl;
+			for (int rfidx = 0; rfidx < TOTAL_RFS; ++rfidx)
+			{
+				int rf = Idx2RF(rfidx);
+				if (!dimDomAligns[rfidx].empty())
+				{
+					if (TDataModes::e_rep == dmode)
+					{
+						for (vector<TOflAlignIndice::__TOflAlignRecord> :: const_iterator iterRec = dimDomAligns[rfidx].begin(), iterRecEnd = dimDomAligns[rfidx].end(); iterRecEnd != iterRec; ++iterRec)
+						{
+							if (NULL == iterRec->pCDInfo) continue;
+							os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT;
+							if (1 == iterRec->pAlign->m_iRepClass)	//multi
+								PrintDomLine(os, HITTYPE_MULTIDOM, *iterRec);
+							else if (iterRec->pAlign->m_bSpecQualified)
+							{
+								PrintDomLine(os, HITTYPE_SPECIFIC, *iterRec);
+								if (NULL != iterRec->pClst)
+								{
+									int key = iterRec->pAlign->m_iRegionIdx * OVERLAPLEADING + iterRec->pCDInfo->m_uiClusterPSSMID;
+									if (dimDomFams[rfidx].end() == dimDomFams[rfidx].find(key))
+										dimDomFams[rfidx].emplace(key, *iterRec);
+								}
+							}
+							else if (NULL != iterRec->pClst)
+								PrintClstLine(os, *iterRec);
+							else	//not qualified for specific, but no cluster -- non-specific
+								PrintDomLine(os, HITTYPE_NONSPECIFIC, *iterRec);
+							os << endl;
+						}	//dom loops end
+					}	//rep mode
+					else	//nonrep mode
+					{
+						for (vector<TOflAlignIndice::__TOflAlignRecord> :: const_iterator iterRec = dimDomAligns[rfidx].begin(), iterRecEnd = dimDomAligns[rfidx].end(); iterRecEnd != iterRec; ++iterRec)
+						{
+							if (NULL == iterRec->pCDInfo) continue;
+							os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT;
+							if (1 == iterRec->pAlign->m_iRepClass)	//multi
+								PrintDomLine(os, HITTYPE_MULTIDOM, *iterRec);
+							else if (iterRec->pAlign->m_bRep && iterRec->pAlign->m_bSpecQualified)
+								PrintDomLine(os, HITTYPE_SPECIFIC, *iterRec);
+							else
+								PrintDomLine(os, HITTYPE_NONSPECIFIC, *iterRec);
+								
+							if (NULL != iterRec->pClst)
+							{
+								int key = iterRec->pAlign->m_iRegionIdx * OVERLAPLEADING + iterRec->pCDInfo->m_uiClusterPSSMID;
+								if (dimDomFams[rfidx].end() == dimDomFams[rfidx].find(key))
+									dimDomFams[rfidx].emplace(key, *iterRec);
+							}
+							
+							os << endl;
+						}
+					}
+				}
+			}
+			os << DOMEND << endl;
+			
+			if (g_bSuperfams)	//user want to see all superfams
+			{
+				os << FAMSTART << endl;
+				for (int rfidx = 0; rfidx < TOTAL_RFS; ++rfidx)
+				{
+					int rf = Idx2RF(rfidx);
+					
+					for (const auto & v : dimDomFams[rfidx])
+					{
+						os << idxBlObj << DELIMIT << m_strQueryID << DELIMIT;
+						PrintClstLine(os, v.second);
+						os << endl;
+					}
+					
+				}
+				os << FAMEND << endl;
+			}
+		}
+			
+		if (TTargetData::e_doms != g_iTargetData)
+		{
+			if (bHasFeats)
+			{
+				vector<__MotifType> dimMotifTypes[TOTAL_RFS];
+//				vector<TOflCDQuery::__TOflAlignRecord> :: const_iterator dimSDIter[TOTAL_RFS];
+				
+				bool bHasMotifs = false;
+				
+				if (bHasRegFeats)
+					os << FEATSTART << endl;
+				
+				int iNegRF = TOTAL_RFS / 2;
+				for (int rfidx = 0; rfidx < iNegRF; ++rfidx)	//plus strand reading frames
+				{
+					int rf = rfidx + 1;
+					vector<TOflCDQuery::__TOflAlignRecord> :: const_iterator iterFeatAlign = dimFeatVecs[rfidx].begin(), iterFeatAlignEnd = dimFeatVecs[rfidx].end();
+					//dimSDIter[rfidx] = iterFeatAlignEnd;
+					for ( ; iterFeatAlignEnd != iterFeatAlign; ++iterFeatAlign)
+					{
+						if (iterFeatAlign->pCDInfo->m_bIsStructDom)
+						{
+							//dimSDIter[rfidx] = iterFeatAlign;
+							//bHasMotifs = true;
+							break;
+						}
+						
+						bool bIsSpecific = iterFeatAlign->pAlign->m_bRep && iterFeatAlign->pAlign->m_bSpecQualified;
+						const char * pType = ANNOTTYPE_SPECIFIC;
+						const list <TOflCDFeat> * pFeats = &(iterFeatAlign->pCDInfo->m_lstSpecFeatures);;
+						unsigned int uiSrcPSSMId = iterFeatAlign->pAlign->m_uiPSSMID;
+						
+						if (!bIsSpecific && NULL != iterFeatAlign->pRootCDInfo)
+						{
+							pType = ANNOTTYPE_GENERIC;
+							pFeats = &(iterFeatAlign->pCDInfo->m_lstGenFeatures);
+							uiSrcPSSMId = iterFeatAlign->pCDInfo->m_uiHierarchyRoot;
+						}
+							
+						for (list<TOflCDFeat> :: const_iterator iterFeat = pFeats->begin(); iterFeat != pFeats->end(); ++iterFeat)
+						{
+							if (TOflCDFeat::eType_StructMotif == iterFeat->m_iType)
+							{
+								dimMotifTypes[rfidx].push_back(__MotifType(iterFeat, iterFeatAlign, bIsSpecific, uiSrcPSSMId));
+								bHasMotifs = true;
+								continue;
+							}
+							
+							CSegSet featsegs(*iterFeat);
+							iterFeatAlign->pAlign->MapSegSet(featsegs, false);
+							
+							if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterFeat->GetCompleteSize() > 0.8))
+							{
+								vector<CSegSet::TResiduePos> vecMappedPos;
+								iterFeatAlign->pAlign->GetTranslatedPosMap(featsegs, vecMappedPos);
+      	  	  	
+								if (iterFeat->MotifCheck(vecMappedPos, m_dimTranslated[rfidx]) > 0) continue;	//failed motif check
+									
+								os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT << pType << DELIMIT << iterFeat->m_strTitle << DELIMIT;
+								
+								const TSegs &segs = featsegs.GetSegs();
+								
+								size_t mapped = 0;
+								
+								char dimDelimit[2] = {0, 0};
+								
+								for (TSegs::const_iterator iterSeg = segs.begin(); iterSeg != segs.end(); ++iterSeg)
+								{
+									int xres = iterFeatAlign->pAlign->Pr2NAPlus(iterSeg->from);
+									for (int res = iterSeg->from; res <= iterSeg->to; ++res)
+									{
+										os << dimDelimit << (char)toupper(m_dimTranslated[rfidx][res]) << (xres + COORDSBASE) << '-';
+										xres += RF_SIZE - 1;
+										os << (xres + COORDSBASE);
+										++xres;
+										dimDelimit[0] = COORDELIMIT;
+										++mapped;
+									}
+								}
+								os << DELIMIT << iterFeat->GetTotalResidues() << DELIMIT << mapped << DELIMIT << uiSrcPSSMId << endl;
+							}
+						}
+					}
+					
+					// -- non-motif from sd domains
+					for ( ; iterFeatAlignEnd != iterFeatAlign; ++iterFeatAlign)
+					{
+						//if (iterFeatAlign->pCDInfo->m_bIsStructDom)
+						//{
+						//	dimSDIter[rfidx] = iterFeatAlign;
+						//	bHasMotifs = true;
+						//	break;
+						//}
+						
+						//bool bIsSpecific = iterFeatAlign->pAlign->m_bRep && iterFeatAlign->pAlign->m_bSpecQualified;
+						//const char * pType = ANNOTTYPE_SPECIFIC;
+						//const list <TOflCDFeat> * pFeats = &(iterFeatAlign->pCDInfo->m_lstSpecFeatures);;
+						//unsigned int uiSrcPSSMId = iterFeatAlign->pAlign->m_uiPSSMID;
+						//
+						//if (!bIsSpecific && NULL != iterFeatAlign->pRootCDInfo)
+						//{
+						//	pType = ANNOTTYPE_GENERIC;
+						//	pFeats = &(iterFeatAlign->pCDInfo->m_lstGenFeatures);
+						//	uiSrcPSSMId = iterFeatAlign->pCDInfo->m_uiHierarchyRoot;
+						//}
+							
+						for (list<TOflCDFeat> :: const_iterator iterFeat = iterFeatAlign->pCDInfo->m_lstSpecFeatures.begin(); iterFeat != iterFeatAlign->pCDInfo->m_lstSpecFeatures.end(); ++iterFeat)
+						{
+							if (TOflCDFeat::eType_StructMotif == iterFeat->m_iType)
+							{
+								dimMotifTypes[rfidx].push_back(__MotifType(iterFeat, iterFeatAlign, true, 0));
+								bHasMotifs = true;
+								continue;
+							}
+							
+							CSegSet featsegs(*iterFeat);
+							iterFeatAlign->pAlign->MapSegSet(featsegs, false);
+							
+							if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterFeat->GetCompleteSize() > 0.8))
+							{
+								vector<CSegSet::TResiduePos> vecMappedPos;
+								iterFeatAlign->pAlign->GetTranslatedPosMap(featsegs, vecMappedPos);
+      	  	  	
+								if (iterFeat->MotifCheck(vecMappedPos, m_dimTranslated[rfidx]) > 0) continue;	//failed motif check
+									
+								os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT << ANNOTTYPE_SPECIFIC << DELIMIT << iterFeat->m_strTitle << DELIMIT;
+								
+								const TSegs &segs = featsegs.GetSegs();
+								
+								size_t mapped = 0;
+								
+								char dimDelimit[2] = {0, 0};
+								
+								for (TSegs::const_iterator iterSeg = segs.begin(); iterSeg != segs.end(); ++iterSeg)
+								{
+									int xres = iterFeatAlign->pAlign->Pr2NAPlus(iterSeg->from);
+									for (int res = iterSeg->from; res <= iterSeg->to; ++res)
+									{
+										os << dimDelimit << (char)toupper(m_dimTranslated[rfidx][res]) << (xres + COORDSBASE) << '-';
+										xres += RF_SIZE - 1;
+										os << (xres + COORDSBASE);
+										++xres;
+										dimDelimit[0] = COORDELIMIT;
+										++mapped;
+									}
+								}
+								os << DELIMIT << iterFeat->GetTotalResidues() << DELIMIT << mapped << DELIMIT << 0/*iterFeatAlign->pAlign->m_uiPSSMID*/ << endl;
+							}
+						}
+					}
+				}
+				
+				for (int rfidx = iNegRF; rfidx < TOTAL_RFS; ++rfidx)	//minus strand reading frames
+				{
+					int rf = 2 - rfidx;
+					vector<TOflCDQuery::__TOflAlignRecord> :: const_iterator iterFeatAlign = dimFeatVecs[rfidx].begin(), iterFeatAlignEnd = dimFeatVecs[rfidx].end();
+					for ( ; iterFeatAlignEnd != iterFeatAlign; ++iterFeatAlign)
+					{
+						if (iterFeatAlign->pCDInfo->m_bIsStructDom)
+						{
+							//dimSDIter[rfidx] = iterFeatAlign;
+							//bHasMotifs = true;
+							break;
+						}
+						
+						bool bIsSpecific = iterFeatAlign->pAlign->m_bRep && iterFeatAlign->pAlign->m_bSpecQualified;
+						const char * pType = ANNOTTYPE_SPECIFIC;
+						const list <TOflCDFeat> * pFeats = &(iterFeatAlign->pCDInfo->m_lstSpecFeatures);;
+						unsigned int uiSrcPSSMId = iterFeatAlign->pAlign->m_uiPSSMID;
+						
+						if (!bIsSpecific && NULL != iterFeatAlign->pRootCDInfo)
+						{
+							pType = ANNOTTYPE_GENERIC;
+							pFeats = &(iterFeatAlign->pCDInfo->m_lstGenFeatures);
+							uiSrcPSSMId = iterFeatAlign->pCDInfo->m_uiHierarchyRoot;
+						}
+							
+						for (list<TOflCDFeat> :: const_iterator iterFeat = pFeats->begin(); iterFeat != pFeats->end(); ++iterFeat)
+						{
+							if (TOflCDFeat::eType_StructMotif == iterFeat->m_iType)
+							{
+								dimMotifTypes[rfidx].push_back(__MotifType(iterFeat, iterFeatAlign, bIsSpecific, uiSrcPSSMId));
+								bHasMotifs = true;
+								continue;
+							}
+							
+							CSegSet featsegs(*iterFeat);
+							iterFeatAlign->pAlign->MapSegSet(featsegs, false);
+							
+							if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterFeat->GetCompleteSize() > 0.8))
+							{
+								vector<CSegSet::TResiduePos> vecMappedPos;
+								iterFeatAlign->pAlign->GetTranslatedPosMap(featsegs, vecMappedPos);
+      	  	  	
+								if (iterFeat->MotifCheck(vecMappedPos, m_dimTranslated[rfidx]) > 0) continue;	//failed motif check
+									
+								os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT << pType << DELIMIT << iterFeat->m_strTitle << DELIMIT;
+								
+								const TSegs &segs = featsegs.GetSegs();
+								
+								size_t mapped = 0;
+								
+								char dimDelimit[2] = {0, 0};
+								
+								for (TSegs::const_iterator iterSeg = segs.begin(); iterSeg != segs.end(); ++iterSeg)
+								{
+									int xres = iterFeatAlign->pAlign->Pr2NAMinus(iterSeg->from);
+									for (int res = iterSeg->from; res <= iterSeg->to; ++res)
+									{
+										os << dimDelimit << (char)toupper(m_dimTranslated[rfidx][res]) << (xres + COORDSBASE) << '-';
+										xres -= RF_SIZE - 1;
+										os << (xres + COORDSBASE);
+										--xres;
+										dimDelimit[0] = COORDELIMIT;
+										++mapped;
+									}
+								}
+								os << DELIMIT << iterFeat->GetTotalResidues() << DELIMIT << mapped << DELIMIT << uiSrcPSSMId << endl;
+							}
+						}
+					}
+					
+					// -- non-motif features from SD domain
+					for ( ; iterFeatAlignEnd != iterFeatAlign; ++iterFeatAlign)
+					{
+						//if (iterFeatAlign->pCDInfo->m_bIsStructDom)
+						//{
+						//	//dimSDIter[rfidx] = iterFeatAlign;
+						//	//bHasMotifs = true;
+						//	break;
+						//}
+						
+						//bool bIsSpecific = iterFeatAlign->pAlign->m_bRep && iterFeatAlign->pAlign->m_bSpecQualified;
+						//const char * pType = ANNOTTYPE_SPECIFIC;
+						//const list <TOflCDFeat> * pFeats = &(iterFeatAlign->pCDInfo->m_lstSpecFeatures);;
+						//unsigned int uiSrcPSSMId = iterFeatAlign->pAlign->m_uiPSSMID;
+						//
+						//if (!bIsSpecific && NULL != iterFeatAlign->pRootCDInfo)
+						//{
+						//	pType = ANNOTTYPE_GENERIC;
+						//	pFeats = &(iterFeatAlign->pCDInfo->m_lstGenFeatures);
+						//	uiSrcPSSMId = iterFeatAlign->pCDInfo->m_uiHierarchyRoot;
+						//}
+							
+						for (list<TOflCDFeat> :: const_iterator iterFeat = iterFeatAlign->pCDInfo->m_lstSpecFeatures.begin(); iterFeat != iterFeatAlign->pCDInfo->m_lstSpecFeatures.end(); ++iterFeat)
+						{
+							if (TOflCDFeat::eType_StructMotif == iterFeat->m_iType)
+							{
+								dimMotifTypes[rfidx].push_back(__MotifType(iterFeat, iterFeatAlign, true, 0));
+								bHasMotifs = true;
+								continue;
+							}
+							
+							CSegSet featsegs(*iterFeat);
+							iterFeatAlign->pAlign->MapSegSet(featsegs, false);
+							
+							if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterFeat->GetCompleteSize() > 0.8))
+							{
+								vector<CSegSet::TResiduePos> vecMappedPos;
+								iterFeatAlign->pAlign->GetTranslatedPosMap(featsegs, vecMappedPos);
+      	  	  	
+								if (iterFeat->MotifCheck(vecMappedPos, m_dimTranslated[rfidx]) > 0) continue;	//failed motif check
+									
+								os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT << ANNOTTYPE_SPECIFIC << DELIMIT << iterFeat->m_strTitle << DELIMIT;
+								
+								const TSegs &segs = featsegs.GetSegs();
+								
+								size_t mapped = 0;
+								
+								char dimDelimit[2] = {0, 0};
+								
+								for (TSegs::const_iterator iterSeg = segs.begin(); iterSeg != segs.end(); ++iterSeg)
+								{
+									int xres = iterFeatAlign->pAlign->Pr2NAMinus(iterSeg->from);
+									for (int res = iterSeg->from; res <= iterSeg->to; ++res)
+									{
+										os << dimDelimit << (char)toupper(m_dimTranslated[rfidx][res]) << (xres + COORDSBASE) << '-';
+										xres -= RF_SIZE - 1;
+										os << (xres + COORDSBASE);
+										--xres;
+										dimDelimit[0] = COORDELIMIT;
+										++mapped;
+									}
+								}
+								os << DELIMIT << iterFeat->GetTotalResidues() << DELIMIT << mapped << DELIMIT << 0/*uiSrcPSSMId*/ << endl;
+							}
+						}
+					}
+				}	//negative strand reading frames
+				
+				if (bHasRegFeats)
+					os << FEATEND << endl;
+					
+				if (bHasMotifs)
+				{
+					os << MOTIFSTART << endl;
+					
+					for (int rfidx = 0; rfidx < iNegRF; ++rfidx)
+					{
+						int rf = rfidx + 1;
+						for (vector<__MotifType> :: const_iterator iterM = dimMotifTypes[rfidx].begin(), iterMEnd = dimMotifTypes[rfidx].end(); iterMEnd != iterM; ++iterM)
+						{
+							CSegSet featsegs(*iterM->iterMotifFeat);
+							iterM->iterAlignRec->pAlign->MapSegSet(featsegs);
+							
+							if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterM->iterMotifFeat->GetCompleteSize() > 0.8))
+							{
+								os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT << iterM->iterMotifFeat->m_strTitle << DELIMIT;
+								int res0 = featsegs.GetLeft(), res1 = featsegs.GetRight();
+								os << res0 + COORDSBASE << DELIMIT << res1 + RF_SIZE - 1 + COORDSBASE << DELIMIT << iterM->uiSrcPSSMId << endl;
+							}
+						}
+						
+						// -- now start SD
+						//vector<TOflCDQuery::__TOflAlignRecord> :: const_iterator iterFeatAlign = dimSDIter[rfidx], iterFeatAlignEnd = dimFeatVecs[rfidx].end();
+						//for ( ; iterFeatAlignEnd != iterFeatAlign; ++iterFeatAlign)
+						//{
+						//	//int rfidx = iterFeatAlign->pAlign->GetRFIdx();
+						//	for (list<TOflCDFeat> :: const_iterator iterFeat = iterFeatAlign->pCDInfo->m_lstSpecFeatures.begin(); iterFeat != iterFeatAlign->pCDInfo->m_lstSpecFeatures.end(); ++iterFeat)
+						//	{
+						//		CSegSet featsegs(*iterFeat);
+						//		iterFeatAlign->pAlign->MapSegSet(featsegs);
+						//		if (!featsegs.IsEmpty())
+						//		{
+						//			os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT << iterFeat->m_strTitle << DELIMIT;
+						//			//int rfidx = iterFeatAlign->pAlign->GetRFIdx();
+						//			int res0 = featsegs.GetLeft(), res1 = featsegs.GetRight();
+						//			os << res0 + COORDSBASE << DELIMIT << res1 + RF_SIZE - 1 + COORDSBASE << DELIMIT << '-' << endl;
+						//		}
+						//	}
+						//}
+					}
+					
+					// -- minus strand
+					for (int rfidx = iNegRF; rfidx < TOTAL_RFS; ++rfidx)
+					{
+						int rf = 2 - rfidx;
+						for (vector<__MotifType> :: const_iterator iterM = dimMotifTypes[rfidx].begin(), iterMEnd = dimMotifTypes[rfidx].end(); iterMEnd != iterM; ++iterM)
+						{
+							CSegSet featsegs(*iterM->iterMotifFeat);
+							iterM->iterAlignRec->pAlign->MapSegSet(featsegs);
+							
+							if (!featsegs.IsEmpty() && ((double)featsegs.GetTotalResidues() / (double)iterM->iterMotifFeat->GetCompleteSize() > 0.8))
+							{
+								os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT << iterM->iterMotifFeat->m_strTitle << DELIMIT;
+								int res0 = featsegs.GetLeft(), res1 = featsegs.GetRight();
+								os << res1 + COORDSBASE << DELIMIT << res0 - RF_SIZE + 1 + COORDSBASE << DELIMIT << iterM->uiSrcPSSMId << endl;
+							}
+						}
+						
+						// -- now start SD
+						//vector<TOflCDQuery::__TOflAlignRecord> :: const_iterator iterFeatAlign = dimSDIter[rfidx], iterFeatAlignEnd = dimFeatVecs[rfidx].end();
+						//for ( ; iterFeatAlignEnd != iterFeatAlign; ++iterFeatAlign)
+						//{
+						//	//int rfidx = iterFeatAlign->pAlign->GetRFIdx();
+						//	for (list<TOflCDFeat> :: const_iterator iterFeat = iterFeatAlign->pCDInfo->m_lstSpecFeatures.begin(); iterFeat != iterFeatAlign->pCDInfo->m_lstSpecFeatures.end(); ++iterFeat)
+						//	{
+						//		CSegSet featsegs(*iterFeat);
+						//		iterFeatAlign->pAlign->MapSegSet(featsegs);
+						//		if (!featsegs.IsEmpty())
+						//		{
+						//			os << idxBlObj << DELIMIT << m_strQueryID << '[' << rf << ']' << DELIMIT << iterFeat->m_strTitle << DELIMIT;
+						//			//int rfidx = iterFeatAlign->pAlign->GetRFIdx();
+						//			int res0 = featsegs.GetLeft(), res1 = featsegs.GetRight();
+						//			os << os << res1 + COORDSBASE << DELIMIT << res0 - RF_SIZE + 1 + COORDSBASE << DELIMIT << '-' << endl;
+						//		}
+						//	}
+						//}
+					}
+					os << MOTIFEND << endl;
+				}
+			}
+		}
+	}
+	
+	os << QUERYEND << endl;
+	if (!g_bSilent) cerr << "End processing Query " << m_strDefline << endl;
+}
+
+
+/**********************************************************************
+*	Biodata structure -- The main processor
+***********************************************************************/
+class COflRpsbPostProcessor: public COflDomClstInfo
+{
+public:
+	COflRpsbPostProcessor(void): COflDomClstInfo() {};
+	
+	// -- return count of objects processed
+	int ProcessRpsbDataStream(istream &is, ostream &os, double evcut, int mode) const;
+	
+private:
+	
+	struct TCDSortFacility
+	{
+		TOflCDAlignInfo *pAlign;
+		size_t ulIdx;
+		
+		// -- added 12/03/2013 for sorting modification
+		const TOflCDInfo *pCDInfo;
+		size_t ulGapsIdx;
+		
+		
+		TCDSortFacility(void): pAlign(nullptr), ulIdx(0), pCDInfo(nullptr), ulGapsIdx(string::npos) {};
+	};
+	
+	struct TSortCDByEValue
+	{
+		bool operator () (const TCDSortFacility &p1, const TCDSortFacility &p2)
+		{
+			if (p1.pAlign->m_dEValue < p2.pAlign->m_dEValue) return true;
+			else if (p1.pAlign->m_dEValue > p2.pAlign->m_dEValue) return false;
+			else return (p1.pAlign->m_dBitScore > p2.pAlign->m_dBitScore);
+		}
+	};
+	
+	void x_Calculate(vector<TOflCDAlignInfo> &aligns, const vector<size_t> &selIdx, TOflAlignIndice &dst) const;
+	static void x_SortReadingFrames(vector<size_t> rfIndice[TOTAL_RFS], TOflCdQueryEx &rTarget);
+	static const char * const DOMSRCSIGS[];
+	static const int DOMSRCCNTS[];
+	static int DomAccType(const string &acc);
+};
+
+const char * const COflRpsbPostProcessor::DOMSRCSIGS[] = {"CD", "CHL", "COG", "MTH", "PFAM", "PHA", "PLN", "PRK", "PTZ", "SMART", "TIGR", NULL};
+const int COflRpsbPostProcessor::DOMSRCCNTS[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0};
+
+int COflRpsbPostProcessor::DomAccType(const string &acc)
+{
+	int iSig = 0, iChar = 0, iAccChar = 0;
+	
+	int acclen = (int)acc.size();
+	while (nullptr != DOMSRCSIGS[iSig] && 0 != DOMSRCSIGS[iSig][iChar] && iAccChar < acclen)
+	{
+		char accChar = acc[iAccChar];
+		if ('a' <= accChar && 'z' >= accChar) accChar -= 0x20;	//to uppercase
+		if (accChar == DOMSRCSIGS[iSig][iChar])
+		{
+			++iAccChar;
+			++iChar;
+		}
+		else
+		{
+
+			++iSig;
+			iChar = 0;
+			iAccChar = 0;
+		}
+	}
+	return iSig;
+}
+
+
+int COflRpsbPostProcessor::ProcessRpsbDataStream(istream &is, ostream &os, double evcut, int mode) const
+{
+	int objCounter = 0;
+	while (is.good())
+	{
+		CBlastOutput objBlastOutput;
+		try
+		{
+			ObjStreamIn<CBlastOutput> (is, objBlastOutput, eSerial_Xml);
+		}
+		catch (...)
+		{
+			return objCounter;
+		}
+		// -- start to output
+		const CBlastOutput::TParam &params = objBlastOutput.GetParam();
+		os << SESSIONSTART << DELIMIT << ++objCounter << DELIMIT << objBlastOutput.GetVersion() << DELIMIT << objBlastOutput.GetDb() << DELIMIT << params.GetMatrix() << DELIMIT << params.GetExpect() << endl;
+		if (!g_bSilent) cerr << "RPSBlast session " << objCounter << " start..." << endl;
+		const CBlastOutput::TIterations &rIters = objBlastOutput.GetIterations();
+
+		for (CBlastOutput::TIterations::const_iterator iter = rIters.begin(), iterEnd = rIters.end(); iterEnd != iter; ++iter)
+		{
+			TOflCdQueryEx cdqVal;
+			cdqVal.ProcessQueryResult(*iter, evcut);
+			if (!g_bSilent) cerr << "Calculating...." << endl;
+			if (cdqVal.m_bIsProtein)
+			{
+				size_t ttlAligns = cdqVal.m_vecAlignments.size();
+
+
+				vector<size_t> ttlIndice;
+				ttlIndice.reserve(ttlAligns);
+				for (size_t i = 0; i < ttlAligns; ++i)
+					ttlIndice.push_back(i);
+				x_Calculate(cdqVal.m_vecAlignments, ttlIndice, cdqVal);
+			}
+			else
+			{
+				size_t ttlAligns = cdqVal.m_vecAlignments.size();
+				vector<size_t> rfIndice[TOTAL_RFS];
+				for (size_t i = 0; i < TOTAL_RFS; ++i)
+					rfIndice[i].reserve(ttlAligns);
+					
+				x_SortReadingFrames(rfIndice, cdqVal);
+				
+				for (size_t i = 0; i < TOTAL_RFS; ++i)
+					x_Calculate(cdqVal.m_vecAlignments, rfIndice[i], cdqVal.m_dimSplitAligns[i]);
+			}
+			
+			cdqVal.Print(objCounter, *this, os, mode);
+		}
+		os << SESSIONEND << DELIMIT << objCounter << endl;
+		if (!g_bSilent) cerr << "RPSBlast session " << objCounter << " done..." << endl;
+	}
+	return objCounter;
+}
+
+void COflRpsbPostProcessor::x_SortReadingFrames(vector<size_t> rfIndice[TOTAL_RFS], TOflCdQueryEx &rTarget)
+{
+	for (size_t idx = 0, len = rTarget.m_vecAlignments.size(); idx < len; ++idx)
+		rfIndice[rTarget.m_vecAlignments[idx].GetRFIdx()].push_back(idx);
+}
+
+void COflRpsbPostProcessor::x_Calculate(vector<TOflCDAlignInfo> &aligns, const vector<size_t> &selIdx, TOflAlignIndice &dst) const
+//This implementation does not promote NCBI-curated models
+{
+	vector <CSegSet> vecGaps;
+	vecGaps.push_back(CSegSet());	//sentinel
+	size_t gapIdx = 0;
+	vector <TCDSortFacility> vecPrivileged, vecNonMulti, vecLongMultiDom, vecMultiDom, vecConcise, vecSDs;
+
+	if (!selIdx.empty())
+	{
+		TCDSortFacility dummy;
+		TSortCDByEValue sortingEV;
+		
+		for (vector<size_t> :: const_iterator iterIdx = selIdx.begin(), iterIdxEnd = selIdx.end(); iterIdx != iterIdxEnd; ++iterIdx)
+		{
+			TOflCDAlignInfo &rAlign = aligns[*iterIdx];
+			const TOflCDInfo *pCDInfo = FindCDInfo(rAlign.m_uiPSSMID);
+			
+			if (NULL == pCDInfo)	//unrecognized CD
+			{
+				cerr << "PSSMId " << rAlign.m_uiPSSMID << " not found. Ignored" << endl;
+				continue;
+			}
+			rAlign.m_dSeqIdentity = (double)(rAlign.m_iNumIdent) / (double)(pCDInfo->m_uiLength) * 100.0;
+			
+			int iNMissing = *(rAlign.m_vecSStarts.begin());
+			int iCMissing = pCDInfo->m_uiLength - (*(rAlign.m_vecSStarts.rbegin()) + *(rAlign.m_vecLens.rbegin()) - 1);
+			
+			rAlign.m_dNMissing = (double)(iNMissing) / (double)(pCDInfo->m_uiLength);
+			rAlign.m_dCMissing = (double)(iCMissing) / (double)(pCDInfo->m_uiLength);
+			rAlign.m_uiAlignedLen = pCDInfo->m_uiLength - iNMissing - iCMissing;
+			rAlign.m_dAlignedPct = (double)(rAlign.m_uiAlignedLen) / (double)(pCDInfo->m_uiLength) * 100.0;
+			rAlign.m_bSpecQualified = (pCDInfo->m_dMinBitScore > 0.0 ? rAlign.m_dBitScore >= pCDInfo->m_dMinBitScore : !pCDInfo->m_bCurated);
+			// -- sorting
+			
+			dummy.pAlign = &(rAlign);
+			dummy.ulIdx = *iterIdx;
+			dummy.pCDInfo = pCDInfo;
+			dummy.ulGapsIdx = string::npos;
+			
+			rAlign.CalcMasterGaps(TOflCDAlignInfo::GAP_THRESHOLD, vecGaps[gapIdx]);
+			if (!vecGaps[gapIdx].IsEmpty())
+			{
+				dummy.ulGapsIdx = gapIdx;
+				++gapIdx;
+				vecGaps.push_back(CSegSet());
+			}
+		
+			if (pCDInfo->m_bIsStructDom)
+			{
+				rAlign.m_iRepClass = 0x2;
+				vecSDs.push_back(dummy);
+			}
+			else if (pCDInfo->m_bCurated || !pCDInfo->m_bMultiDom)	//non-curated single dom
+			{
+				rAlign.m_iRepClass = 0;
+				vecNonMulti.push_back(dummy);
+			}
+			//else if (rAlign.m_dAlignedPct > 90.0)	//long
+			//{
+			//	rAlign.m_iRepClass = 1;
+			//	vecLongMultiDom.push_back(dummy);
+			//}
+			else
+			{
+				rAlign.m_iRepClass = 1;
+				vecMultiDom.push_back(dummy);
+			}
+		}
+	  map<int, TDomSrcCount> dimAccTypeCount, dimAccTypeCount2;
+		
+		// -- sort
+		sort(vecNonMulti.begin(), vecNonMulti.end(), sortingEV);
+		for (vector <TCDSortFacility>::const_iterator iter = vecNonMulti.begin(), iterEnd = vecNonMulti.end(); iterEnd != iter; ++iter)
+		{
+
+			CSegSet s_overlaps;	// to calculate combined overlap region
+			
+			CSegSet thisSegs;
+			thisSegs.AddSeg(iter->pAlign->m_iFrom, iter->pAlign->m_iTo);
+			if (string::npos != iter->ulGapsIdx)
+				thisSegs.Clip(vecGaps[iter->ulGapsIdx]);
+			
+			int iThisLength = (int)thisSegs.GetTotalResidues();
+			double dThisLength = (double)iThisLength;
+			
+			for (vector <TCDSortFacility>::const_iterator iterRep = vecConcise.begin(), iterRepEnd = vecConcise.end(); iterRepEnd != iterRep; ++iterRep)
+			{
+				CSegSet repSegs;
+				repSegs.AddSeg(iterRep->pAlign->m_iFrom, iterRep->pAlign->m_iTo);
+				
+				if (string::npos != iterRep->ulGapsIdx)
+					repSegs.Clip(vecGaps[iterRep->ulGapsIdx]);
+				
+				int iRepLength = (int)repSegs.GetTotalResidues();
+				double dRepLength = (double)iRepLength;
+				
+				// -- find gaps. any gap >= half of the domain model length are considered a gap and excluded from overlapping
+				
+				CSegSet olSegs(thisSegs);
+				olSegs.Cross(repSegs);
+				
+				int iOverlapLen = (int)olSegs.GetTotalResidues();
+				double dOverlapLen = (double)iOverlapLen;
+
+				if (dOverlapLen > 0)
+				{
+				
+					if (dOverlapLen / dThisLength > 0.5 || (dOverlapLen / dRepLength > 0.5 && iter->pCDInfo->m_uiClusterPSSMID == iterRep->pCDInfo->m_uiClusterPSSMID))	//mutually overlap > 0.5
+					//if (dOverlapLen / dThisLength + dOverlapLen / dRepLength > 1.0)	//mutually overlap > 0.5
+					{
+						iter->pAlign->m_iRegionIdx = iterRep->pAlign->m_iRegionIdx;
+						iter->pAlign->m_bRep = false;
+						
+						goto labelNextNonMulti;
+					}
+				}
+				s_overlaps.Merge(olSegs);
+
+			}
+			
+			if ((iter->pAlign->m_bRep = (((double)(s_overlaps.GetTotalResidues()) / dThisLength) < 0.5)))	//new region
+			{
+				iter->pAlign->m_iRegionIdx = vecConcise.size();
+				vecConcise.push_back(*iter);
+
+			}
+		labelNextNonMulti:
+			
+			map<int, TDomSrcCount> :: iterator iterSrcCounter = dimAccTypeCount.emplace(iter->pAlign->m_iRegionIdx, TDomSrcCount()).first;
+			if (iterSrcCounter->second.CountSrc(iter->pCDInfo->m_strAccession))
+			{
+				if (iter->pCDInfo->m_bCurated)
+				{
+					dst.m_vecQualifiedFeatIndice.push_back(iter->ulIdx);
+				}
+				dst.m_vecStdIndice.push_back(iter->ulIdx);
+				iter->pAlign->m_bRep = true;
+			}
+			dst.m_vecSortedIndice.push_back(iter->ulIdx);
+		}
+		
+		// -- When done, convert setup dst.m_vecConciseIndice
+		size_t ttlConcise = vecConcise.size();
+		if (ttlConcise > 0)
+		{
+			dst.m_vecConciseIndice.reserve(ttlConcise);
+			for (size_t i = 0; i < ttlConcise; ++i)
+				dst.m_vecConciseIndice.push_back(vecConcise[i].ulIdx);
+		}
+		// -- now deal with multi. first process long (> 90% multi)
+		//sort(vecLongMultiDom.begin(), vecLongMultiDom.end(), sortingEV);
+		//vecPrivileged.clear();
+		//for (vector <TCDSortFacility>::const_iterator iter = vecLongMultiDom.begin(), iterEnd = vecLongMultiDom.end(); iterEnd != iter; ++iter)
+		//{
+		//	CSegSet thisSegs;
+		//	thisSegs.AddSeg(iter->pAlign->m_iFrom, iter->pAlign->m_iTo);
+		//	if (string::npos != iter->ulGapsIdx)
+		//		thisSegs.Clip(vecGaps[iter->ulGapsIdx]);
+		//	
+		//	int iThisLength = (int)thisSegs.GetTotalResidues();
+		//	double dThisLength = (double)iThisLength;
+		//	
+		//	
+		//	CSegSet m_overlaps;	//only consider multi overlaping
+		//	double dMOverlap = 0.0;
+		//	
+		//	for (vector <TCDSortFacility>::const_iterator iterRep = vecPrivileged.begin(), iterRepEnd = vecPrivileged.end(); iterRepEnd != iterRep; ++iterRep)
+		//	{
+		//		if (!(iterRep->pAlign->m_iFrom > iter->pAlign->m_iTo || iterRep->pAlign->m_iTo < iter->pAlign->m_iFrom))	//overlap
+		//		{
+		//			CSegSet repSegs;
+		//			repSegs.AddSeg(iterRep->pAlign->m_iFrom, iterRep->pAlign->m_iTo);
+		//		
+		//			if (string::npos != iterRep->ulGapsIdx)
+		//				repSegs.Clip(vecGaps[iterRep->ulGapsIdx]);
+		//		
+		//			int iRepLength = (int)repSegs.GetTotalResidues();
+		//			double dRepLength = (double)iRepLength;
+		//			
+		//			
+		//			CSegSet olSegs(thisSegs);
+		//			olSegs.Cross(repSegs);
+		//			
+		//			int iOverlapLen = (int)olSegs.GetTotalResidues();
+		//			
+		//			double dOverlapLen = (double)(iOverlapLen);
+		//			
+		//			if (dOverlapLen / dThisLength + dOverlapLen / dRepLength > 1.0)	//mutually overlap > 0.5
+		//			{
+		//				iter->pAlign->m_iRegionIdx = iterRep->pAlign->m_iRegionIdx;
+		//				iter->pAlign->m_bRep = false;
+		//				vecMultiDom.push_back(*iter);
+		//				goto labelNextLongMulti;
+		//			}
+		//			m_overlaps.Merge(olSegs);
+		//		}
+		//	}
+		//	
+		//	dMOverlap = (double)(m_overlaps.GetTotalResidues()) / dThisLength;
+		//	
+		//	if (dMOverlap <= 0.5)	//new multi-dom region -- rep!
+		//	{
+		//		iter->pAlign->m_iRegionIdx = dst.m_vecConciseIndice.size();
+		//		iter->pAlign->m_bRep = true;
+		//		
+		//		map<int, TDomSrcCount> :: iterator iterSrcCounter = dimAccTypeCount2.emplace(iter->pAlign->m_iRegionIdx, TDomSrcCount()).first;
+		//		iterSrcCounter->second.CountSrc(iter->pCDInfo->m_strAccession);
+		//		dst.m_vecConciseIndice.push_back(iter->ulIdx);
+		//		vecConcise.push_back(*iter);
+		//		dst.m_vecStdIndice.push_back(iter->ulIdx);
+		//		dst.m_vecSortedIndice.push_back(iter->ulIdx);
+		//		vecPrivileged.push_back(*iter);
+		//	}
+		//	else vecMultiDom.push_back(*iter);
+		//		
+		//labelNextLongMulti:;
+		//}
+		// -- now deal with short multi
+		// -- if no concise at all, then vecPrivileged should be already empty. so it will not change the status that vecPrivileged always contains the "concise" of multidoms to display if no concise found.
+		
+		vecPrivileged.clear();
+		sort(vecMultiDom.begin(), vecMultiDom.end(), sortingEV);
+		for (vector <TCDSortFacility>::const_iterator iter = vecMultiDom.begin(), iterEnd = vecMultiDom.end(); iterEnd != iter; ++iter)
+		{
+			CSegSet s_overlaps;	// to calculate combined overlap region
+			CSegSet m_overlaps;
+			
+			double dSOverlap = 0.0;	//put here for scope reason
+			double dMOverlap = 0.0;
+			
+			CSegSet thisSegs;
+			thisSegs.AddSeg(iter->pAlign->m_iFrom, iter->pAlign->m_iTo);
+			if (string::npos != iter->ulGapsIdx)
+				thisSegs.Clip(vecGaps[iter->ulGapsIdx]);
+			
+			int iThisLength = (int)thisSegs.GetTotalResidues();
+			double dThisLength = (double)iThisLength;
+			
+			//double dThisLength = (double)(iter->pAlign->m_iTo - iter->pAlign->m_iFrom + 1);
+			for (vector <TCDSortFacility>::const_iterator iterRep = vecConcise.begin(), iterRepEnd = vecConcise.end(); iterRepEnd != iterRep; ++iterRep)
+			{
+				if (!(iterRep->pAlign->m_iFrom > iter->pAlign->m_iTo || iterRep->pAlign->m_iTo < iter->pAlign->m_iFrom))	//overlap
+				{
+					CSegSet repSegs;
+					repSegs.AddSeg(iterRep->pAlign->m_iFrom, iterRep->pAlign->m_iTo);
+					
+					if (string::npos != iterRep->ulGapsIdx)
+						repSegs.Clip(vecGaps[iterRep->ulGapsIdx]);
+					
+					int iRepLength = (int)repSegs.GetTotalResidues();
+					double dRepLength = (double)iRepLength;
+					
+					// -- find gaps. any gap >= half of the domain model length are considered a gap and excluded from overlapping
+					
+					CSegSet olSegs(thisSegs);
+					olSegs.Cross(repSegs);
+					
+					int iOverlapLen = (int)olSegs.GetTotalResidues();
+					
+					double dOverlapLen = (double)iOverlapLen;
+					
+					if (0 == iterRep->pAlign->m_iRepClass)	//single
+					{
+						s_overlaps.Merge(olSegs);
+					}
+					else	//multi
+					{
+						if (dOverlapLen / dThisLength + dOverlapLen / dRepLength > 1.0)	//mutually overlap > 0.5
+						{
+							iter->pAlign->m_iRegionIdx = iterRep->pAlign->m_iRegionIdx;
+							iter->pAlign->m_bRep = false;
+							goto labelNextMulti;
+						}
+						m_overlaps.Merge(olSegs);
+					}
+				}
+			}
+			
+			
+			for (vector <TCDSortFacility>::const_iterator iterRep = vecPrivileged.begin(), iterRepEnd = vecPrivileged.end(); iterRepEnd != iterRep; ++iterRep)
+			{
+				if (!(iterRep->pAlign->m_iFrom > iter->pAlign->m_iTo || iterRep->pAlign->m_iTo < iter->pAlign->m_iFrom))	//overlap
+				{
+					
+					CSegSet repSegs;
+					repSegs.AddSeg(iterRep->pAlign->m_iFrom, iterRep->pAlign->m_iTo);
+					
+					if (string::npos != iterRep->ulGapsIdx)
+						repSegs.Clip(vecGaps[iterRep->ulGapsIdx]);
+					
+					int iRepLength = (int)repSegs.GetTotalResidues();
+					double dRepLength = (double)iRepLength;
+					
+					// -- find gaps. any gap >= half of the domain model length are considered a gap and excluded from overlapping
+					
+					CSegSet olSegs(thisSegs);
+					olSegs.Cross(repSegs);
+					
+					int iOverlapLen = (int)olSegs.GetTotalResidues();
+					
+					double dOverlapLen = (double)iOverlapLen;
+					
+					if (dOverlapLen / dThisLength + dOverlapLen / dRepLength > 1.0)	//mutually overlap > 0.5
+					{
+						iter->pAlign->m_iRegionIdx = iterRep->pAlign->m_iRegionIdx;
+						iter->pAlign->m_bRep = false;
+						goto labelNextMulti;
+					}
+					m_overlaps.Merge(olSegs);
+				}
+			}
+			
+			dSOverlap = (double)(s_overlaps.GetTotalResidues()) / dThisLength;
+			dMOverlap = (double)(m_overlaps.GetTotalResidues()) / dThisLength;
+
+			if (dMOverlap <= 0.5)	//new multi-dom region
+			{
+				if ((dSOverlap <= 0.5 && iter->pAlign->m_dAlignedPct > 50.0) || iter->pAlign->m_bSpecQualified)	//rep!
+				{
+					iter->pAlign->m_iRegionIdx = dst.m_vecConciseIndice.size() + vecPrivileged.size();
+					iter->pAlign->m_bRep = true;
+					
+					
+					dst.m_vecConciseIndice.push_back(iter->ulIdx);
+					vecConcise.push_back(*iter);
+				}
+				vecPrivileged.push_back(*iter);
+			}
+		labelNextMulti:
+			
+			map<int, TDomSrcCount> :: iterator iterSrcCounter = dimAccTypeCount2.emplace(iter->pAlign->m_iRegionIdx, TDomSrcCount()).first;
+			if (iterSrcCounter->second.CountSrc(iter->pCDInfo->m_strAccession))
+				dst.m_vecStdIndice.push_back(iter->ulIdx);
+			
+			dst.m_vecSortedIndice.push_back(iter->ulIdx);
+		
+		}
+		// -- to avoid empty concise
+		
+		if (!dst.m_vecSortedIndice.empty())
+		{
+			if (dst.m_vecConciseIndice.empty())
+			{
+				size_t iEnd = vecPrivileged.size();
+				dst.m_vecConciseIndice.reserve(iEnd);
+				for (size_t i = 0; i < iEnd; ++i)
+				{
+					dst.m_vecConciseIndice.push_back(vecPrivileged[i].ulIdx);
+					vecPrivileged[i].pAlign->m_bRep = true;
+				}
+			}
+			
+			if (dst.m_vecStdIndice.empty())
+			{
+				dst.m_vecStdIndice = dst.m_vecSortedIndice;
+			}
+		}
+
+
+
+		// -- finally calculate SDs
+		// -- SDs: models are sorted according to evalues, each model reserve their regions on the query sequence. that would need to change the from/to and the aligned segments. Features are 
+		// -- then mapped to the query from these regions -- to guarantee non-redundency. Proposed by Aron.
+		// -- implementation: calculate a restriction segset for SD models, which will be used later to trim the sites first
+		if (!vecSDs.empty())
+		{
+			sort(vecSDs.begin(), vecSDs.end(), sortingEV);
+			//vecConcise.clear();
+			dst.m_vecSDIndice.clear();
+			dst.m_vecSDIndice.reserve(vecSDs.size());
+			CSegSet covered_regions;
+			
+			for (vector <TCDSortFacility>::const_iterator iter = vecSDs.begin(), iterEnd = vecSDs.end(); iterEnd != iter; ++iter)
+			{
+
+				CSegSet sdSegSet;
+				sdSegSet.AddSeg(0, iter->pCDInfo->m_uiLength - 1);
+
+
+				iter->pAlign->MapSegSet(sdSegSet);
+				
+				sdSegSet.Clip(covered_regions);
+				
+				if (!sdSegSet.IsEmpty())
+				{
+					iter->pAlign->m_ClipSet.Clear();
+					const TSegs& sdSegs = sdSegSet.GetSegs();
+
+					
+					for (TSegs::const_iterator iterSeg = sdSegs.begin(), iterSegEnd = sdSegs.end(); iterSegEnd != iterSeg; ++iterSeg)
+					{
+						iter->pAlign->m_ClipSet.AddSeg(iterSeg->ori_from, sdSegSet.GetOriTo(iterSeg));
+
+					}
+					
+					covered_regions.Merge(sdSegSet);
+					dst.m_vecSDIndice.push_back(iter->ulIdx);
+				}
+			}
+		}
+	}
+}
+
+/**********************************************************************
+*	Main functions
+***********************************************************************/
+
+void PrintUsage(const char * pname, ostream &os)
+{
+	os << PROGRAM_TITLE << endl;
+	os << "This utility processes domain hit data produced by local RPS-BLAST and" << endl;
+	os << "and generates domain family and/or superfamily annotations on the query sequences." << endl;
+	os << "Some data files (all downloadable from NCBI ftp site) are required for this program" << endl;
+	os << "to function correctly. " << endl << endl;
+	os << "Usage:" << endl;
+	os << pname << " [-c<config-file>] [-i<in-filename>] [-o<out-filename>] [-e<evalue-cutoff>] [-m<data-mode>] [-d<target-data>] [-h]" << endl << endl;
+	os << "\t-c<config-file>" << endl;
+	os << "\t\tBy default, the program looks for a <progname>.ini file in current directory" << endl;
+	os << "\t\tand loads configuration data from it. This -c switch can be used to override the default and load" << endl;
+	os << "\t\tconfiguration data from a different file" << endl << endl;
+	os << "\t-i<in-filename>" << endl;
+	os << "\t\tThe file contains data generated by local RPS-BLAST program. If omitted, default to stdin" << endl << endl;
+	os << "\t-o<out-filename>" << endl;
+	os << "\t\tFile to which the processed results should be written. If omitted, default to stdout" << endl << endl;
+	os << "\t-e<evalue-cutoff>" << endl;
+	os << "\t\tOnly processes hits with evalues better (smaller in value) than the designated." << endl;
+	os << "\t\tIf omitted, default to 0.01" << endl << endl;
+	os << "\t-m<data-mode>" << endl;
+	os << "\t\tSelect redundancy level of domain hit data. Valid options are \"rep\" (concise), \"std\"(standard)" << endl;
+	os << "\t\tand \"full\" (all hits)" << endl << endl;
+	os << "\t-t<target-data>" << endl;
+	os << "\t\tSelect desired (target) data. Valid options are \"doms\", \"feats\" or \"both\". . If omitted, default to \"both\"" << endl << endl;
+	os << "\t-d<datapath>" << endl;
+	os << "\t\tLocation of data files. Usually data files are set in the [datapath] secion of the configure file (" << pname << ".ini)" << endl;
+	os << "\t\tand have the freedom to use any file names. This switch overrides thse settings and looks for the exact file set under the specified path:" << endl;
+	os << endl;
+	os << "\t\t\t" << CDIDFILE << endl;
+	os << "\t\t\t" << CDTRACKFILE << endl;
+	os << "\t\t\t" << CLSTLINKFILE << endl;
+	os << "\t\t\t" << SPFEATFILE << endl;
+	os << "\t\t\t" << GENFEATFILE << endl;
+	os << "\t\t\t" << MINBSCOREFILE << endl;
+	os << endl;
+	os << "\t\tSo be sure to check the data file names after downloading from our ftp site and rename them if this switch is to be used." << endl << endl;
+	os << "\t-f" << endl;
+	os << "\t\tShow corresponding superfamily information for domain hits. A " << FAMSTART << '/' << FAMEND << " section will appear after" << endl;
+	os << "\t\tthe " << DOMSTART << '/' << DOMEND << " section to list superfamily hits corresponding to the representative domain hits in each region." << endl << endl;
+	os << "\t-q" << endl;
+	os << "\t\tQuiet mode -- do not display program information and progress on stderr" << endl << endl;
+	os << "\t-h" << endl;
+	os << "\t\tDisplay this help screen, ignore other switches" << endl << endl;
+	
+	os << "Configuration file:" << endl;
+	os << "The [datapath] section contains paths to required data files. All data files must be downloaded from NCBI FTP site:" << endl << endl;
+	os << "\tftp://ftp.ncbi.nlm.nih.gov/pub/mmdb/cdd/" << endl << endl;
+	os << "to the local file system and decompressed. Edit the configuration file so that the paths point to the" << endl;
+	os << "correct location of these files" << endl << endl;
+	os << "Thanks for using our services and programs." << endl;
+}
+
+void ProcessCmdline(int sw, const char *arg)
+{
+
+	switch (sw)
+	{
+	case TRpsbProcCmds::eCfgFile:
+		if (NULL == arg)
+			cerr << "missing parameter for switch -" << TRpsbProcCmds::m_dimRpsbProcSwitches[TRpsbProcCmds::eCfgFile].m_cToken << ", ignored.." << endl;
+		else
+			g_strCfgFile = arg;
+		break;
+	case TRpsbProcCmds::eInFile:
+		if (NULL == arg)
+			cerr << "missing parameter for switch -" << TRpsbProcCmds::m_dimRpsbProcSwitches[TRpsbProcCmds::eInFile].m_cToken << ", ignored.." << endl;
+		else
+			g_strSrcFile = arg;
+		break;
+	case TRpsbProcCmds::eOutFile:
+		if (NULL == arg)
+			cerr << "missing parameter for switch -" << TRpsbProcCmds::m_dimRpsbProcSwitches[TRpsbProcCmds::eOutFile].m_cToken << ", ignored.." << endl;
+		else
+			g_strDstFile = arg;
+		break;
+	case TRpsbProcCmds::eEVCutoff:
+		if (NULL == arg)
+			cerr << "missing parameter for switch -" << TRpsbProcCmds::m_dimRpsbProcSwitches[TRpsbProcCmds::eEVCutoff].m_cToken << ", ignored.." << endl;
+		else
+			g_dEValue = atof(arg);
+		break;
+	case TRpsbProcCmds::eQuiet:
+		g_bSilent = true;
+		break;
+	case TRpsbProcCmds::eMode:
+		if (NULL == arg)
+			cerr << "missing parameter for switch -" << TRpsbProcCmds::m_dimRpsbProcSwitches[TRpsbProcCmds::eMode].m_cToken << ", ignored.." << endl;
+		else
+			g_iDataMode = GetIdx<TDataModes> (arg);
+		break;
+	case TRpsbProcCmds::eTData:	//target data
+		if (NULL == arg)
+			cerr << "missing parameter for switch -" << TRpsbProcCmds::m_dimRpsbProcSwitches[TRpsbProcCmds::eTData].m_cToken << ", ignored.." << endl;
+		else
+			g_iTargetData = GetIdx<TTargetData> (arg);
+		break;
+	case TRpsbProcCmds::eData:	//target data
+		if (NULL == arg)
+			cerr << "missing parameter for switch -" << TRpsbProcCmds::m_dimRpsbProcSwitches[TRpsbProcCmds::eData].m_cToken << ", ignored.." << endl;
+		else
+			g_strDataPath = arg;
+		break;
+	case TRpsbProcCmds::eFams:
+		g_bSuperfams = true;
+		break;
+	case TRpsbProcCmds::eHelp:
+		PrintUsage(g_pProgName, cout);
+		g_bRunProg = false;
+		break;
+	case TRpsbProcCmds::eInvalid:
+		cerr << "Invalid switch '" << arg[0] << "', ignored.." << endl;
+		break;
+	case TRpsbProcCmds::NONSWITCH:
+	default:
+		;
+	}
+}
+
+/**********************************************************************
+*	main
+***********************************************************************/
+int main(int argc, char * argv[])
+{
+	g_pProgName = argv[0];
+	TRpsbProcCmds().IterParameters(argc, argv, ProcessCmdline);
+
+
+	if (!g_bRunProg) return 2;
+	
+	if (!g_bSilent)	//display information
+	{
+		cerr << PROGRAM_TITLE << endl;
+		cerr << "-------------------------------------------------------" << endl;
+		cerr << "Download:" << endl;
+		cerr << "\tftp://ftp.ncbi.nlm.nih.gov/pub/mmdb/cdd/" << endl << endl;
+		cerr << "Blast applications download:" << endl;
+		cerr << "\tftp://ftp.ncbi.nlm.nih.gov/blast/executables/blast+/LATEST/" << endl << endl;
+		cerr << "For more information please refer to the README file" << endl;
+	}
+	
+	CNcbiRegistry reg;
+	
+	bool bHasConfig = false;
+	
+	if (!g_strCfgFile.empty())
+		bHasConfig = ReadConfig(g_strCfgFile.c_str(), reg);
+	else
+		bHasConfig = ReadConfig((g_pProgName + string(".ini")).c_str(), reg) || ReadConfig(nullptr, reg);
+	
+	istream *pDataSrc = &cin;
+	
+	ifstream ifs;
+	if (!g_strSrcFile.empty())
+	{
+		ifs.open(g_strSrcFile.c_str(), ios::binary | ios::in);
+		pDataSrc = &ifs;
+	}
+	
+	ostream *pDataDst = &cout;
+	ofstream ofs;
+	if (!g_strDstFile.empty())
+	{
+		ofs.open(g_strDstFile.c_str(), ios::binary | ios::out);
+		pDataDst = &ofs;
+	}
+	// -- output to result
+	(*pDataDst) << '#' << PROGRAM_TITLE << endl;
+	
+	(*pDataDst) << "#Config file:\t";
+	if (bHasConfig)
+	{
+		if (g_strCfgFile.empty()) (*pDataDst) << g_pProgName << ".ini";
+		else (*pDataDst) << g_strCfgFile;
+	}
+	(*pDataDst) << endl;
+	
+	(*pDataDst) << "#Input data file:\t";
+	if (g_strSrcFile.empty()) (*pDataDst) << "stdin";
+	else (*pDataDst) << g_strSrcFile;
+	(*pDataDst) << endl;
+	
+	(*pDataDst) << "#Output data file:\t";
+	if (g_strDstFile.empty()) (*pDataDst) << "stdout";
+	else (*pDataDst) << g_strDstFile;
+	(*pDataDst) << endl;
+	(*pDataDst) << "#E-Value cutoff:\t" << g_dEValue << endl;
+	(*pDataDst) << "#Redundancy:\t" << TDataModes::dimDisplay[g_iDataMode] << endl;
+	(*pDataDst) << "#Data requested:\t" << TTargetData::dimDisplay[g_iTargetData] << endl;
+	(*pDataDst) << "#Output format -- tab-delimited table" << endl;
+	(*pDataDst) << '#' << DATASTART << endl;
+	(*pDataDst) << '#' << SESSIONSTART << DELIMIT << "<session-ordinal>" << DELIMIT << "<program>" << DELIMIT << "<database>" << DELIMIT << "<score-matrix>" << DELIMIT << "<evalue-threshold>" << endl;
+	(*pDataDst) << '#' << QUERYSTART << DELIMIT << "<query-id>" << DELIMIT << "<seq-type>" << DELIMIT << "<seq-length>" << DELIMIT << "<definition-line>" << endl;
+
+
+	if (TTargetData::e_feats != g_iTargetData)
+	{
+		(*pDataDst) << '#' << DOMSTART << endl;
+		(*pDataDst) << '#' << "<session-ordinal>" << DELIMIT << "<query-id[readingframe]>" << DELIMIT << "<hit-type>" << DELIMIT << "<PSSM-ID>" << DELIMIT << "<from>" << DELIMIT << "<to>" << DELIMIT << "<E-Value>" << DELIMIT << "<bitscore>" << DELIMIT << "<accession>" << DELIMIT << "<short-name>" << DELIMIT << "<incomplete>" << DELIMIT << "<superfamily PSSM-ID>" << endl;
+		(*pDataDst) << "#more such lines......" << endl;
+		(*pDataDst) << '#' << DOMEND << endl;
+	}
+	if (TTargetData::e_doms != g_iTargetData)
+	{
+		(*pDataDst) << '#' << FEATSTART << endl;
+		(*pDataDst) << '#' << "<session-ordinal>" << DELIMIT << "<query-id[readingframe]>" << DELIMIT << "<annot-type>" << DELIMIT << "<title>" << DELIMIT << "<residue(coordinates)>" << DELIMIT << "<complete-size>" << DELIMIT << "<mapped-size>" << DELIMIT << "<source-domain>" << endl;
+		(*pDataDst) << "#more such lines......" << endl;
+		(*pDataDst) << '#' << FEATEND << endl;
+		(*pDataDst) << '#' << MOTIFSTART << endl;
+		(*pDataDst) << '#' << "<session-ordinal>" << DELIMIT << "<query-id[readingframe]>" << DELIMIT << "<title>" << DELIMIT << "<from>" << DELIMIT << "<to>" << DELIMIT << "<source-domain>" << endl;
+		(*pDataDst) << "#more such lines......" << endl;
+		(*pDataDst) << '#' << MOTIFEND << endl;
+	}
+	(*pDataDst) << '#' << QUERYEND << DELIMIT << "<query-id>" << endl;
+	(*pDataDst) << "#more query sections.." << endl;
+	(*pDataDst) << '#' << SESSIONEND << DELIMIT << "<session-ordinal>" << endl;
+	(*pDataDst) << "#more session sections.." << endl;
+	(*pDataDst) << '#' << DATAEND << endl;
+	(*pDataDst) << "#=====================================================================" << endl;
+	
+	int objCount = 0;
+	if (pDataSrc->good())
+	{
+		
+		COflRpsbPostProcessor proc;
+		if (bHasConfig)
+			proc.LoadData(reg);
+		else
+			proc.LoadData();
+		
+		unsigned int procstatus = proc.GetStatus();
+		
+		if (procstatus > 0)
+		{
+			cerr << "Annotation data loading unsuccessful. Please check the follow data files to make sure they exist and are readable:" << endl;
+			if (!g_strDataPath.empty())
+			{
+				if (procstatus & COflDomClstInfo::CDD_DATA_NOT_FOUND)
+					cerr << '\t' << g_strDataPath << '/' << CDIDFILE << endl;
+				if (procstatus & COflDomClstInfo::CLUSTER_LINK_NOT_FOUND)
+					cerr << '\t' << g_strDataPath << '/' << CLSTLINKFILE << endl;
+				if (procstatus & COflDomClstInfo::HIERARCHY_DATA_NOT_FOUND)
+					cerr << '\t' << g_strDataPath << '/' << CDTRACKFILE << endl;
+				if (procstatus & COflDomClstInfo::FEATURE_DATA_NOT_FOUND)
+					cerr << '\t' << g_strDataPath << '/' << SPFEATFILE << endl;
+				if (procstatus & COflDomClstInfo::GENERIC_FEATURE_DATA_NOT_FOUND)
+					cerr << '\t' << g_strDataPath << '/' << GENFEATFILE << endl;
+				if (procstatus & COflDomClstInfo::SPTHRESHOLD_DATA_NOT_FOUND)
+					cerr << '\t' << g_strDataPath << '/' << MINBSCOREFILE << endl;
+			}
+			else if (bHasConfig)
+			{
+				if (procstatus & COflDomClstInfo::CDD_DATA_NOT_FOUND)
+					cerr << '\t' << reg.Get(DATAPATH, CDDIDS) << endl;
+				if (procstatus & COflDomClstInfo::CLUSTER_LINK_NOT_FOUND)
+					cerr << '\t' << reg.Get(DATAPATH, CLUSTERLINKS) << endl;
+				if (procstatus & COflDomClstInfo::HIERARCHY_DATA_NOT_FOUND)
+					cerr << '\t' << reg.Get(DATAPATH, CDTRACKINFO) << endl;
+				if (procstatus & COflDomClstInfo::FEATURE_DATA_NOT_FOUND)
+					cerr << '\t' << reg.Get(DATAPATH, FEATURES) << endl;
+				if (procstatus & COflDomClstInfo::GENERIC_FEATURE_DATA_NOT_FOUND)
+					cerr << '\t' << reg.Get(DATAPATH, GENERIC_FEATURES) << endl;
+				if (procstatus & COflDomClstInfo::SPTHRESHOLD_DATA_NOT_FOUND)
+					cerr << '\t' << reg.Get(DATAPATH, SPECIFICTHRESHOLDS) << endl;
+			}
+			else
+			{
+				if (procstatus & COflDomClstInfo::CDD_DATA_NOT_FOUND)
+					cerr << '\t' << CDIDFILE << endl;
+				if (procstatus & COflDomClstInfo::CLUSTER_LINK_NOT_FOUND)
+					cerr << '\t' << CLSTLINKFILE << endl;
+				if (procstatus & COflDomClstInfo::HIERARCHY_DATA_NOT_FOUND)
+					cerr << '\t' << CDTRACKFILE << endl;
+				if (procstatus & COflDomClstInfo::FEATURE_DATA_NOT_FOUND)
+					cerr << '\t' << SPFEATFILE << endl;
+				if (procstatus & COflDomClstInfo::GENERIC_FEATURE_DATA_NOT_FOUND)
+					cerr << '\t' << GENFEATFILE << endl;
+				if (procstatus & COflDomClstInfo::SPTHRESHOLD_DATA_NOT_FOUND)
+					cerr << '\t' << MINBSCOREFILE << endl;
+			}
+			return 0;
+		}
+		
+		(*pDataDst) << DATASTART << endl;
+		if (!g_bSilent) cerr << "Start process data..." << endl;
+		objCount = proc.ProcessRpsbDataStream(*pDataSrc, *pDataDst, g_dEValue, g_iDataMode);
+		if (!g_bSilent) cerr << "End process data..." << endl;
+		(*pDataDst) << DATAEND << endl;
+	}
+	
+	(*pDataDst) << endl << "#Total Blastout object processed\t" << objCount << endl;
+	
+	ifs.close();
+	ofs.close();
+	
+	cerr << "Total CBlastOutput objects: " << objCount << endl;
+	return 0;
+}
+
+
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/rpsbproc.ini ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/rpsbproc.ini
--- ncbi-blast-2.7.1+-src/c++/src/app/rpsbproc/rpsbproc.ini	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/rpsbproc/rpsbproc.ini	2018-03-05 15:50:36.017652000 -0500
@@ -0,0 +1,8 @@
+[datapath]
+cdd = ./data/cddid.tbl
+cdt = ./data/cdtrack.txt
+clst = ./data/family_superfamily_links.txt
+feats = ./data/cddannot.dat
+genfeats = ./data/cddannot_generic.dat
+spthr = ./data/bitscore_specific_3.14.txt
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/Makefile.in ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/Makefile.in
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/Makefile.in	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/Makefile.in	2018-03-13 14:39:35.170010000 -0400
@@ -0,0 +1,4 @@
+APP_PROJ = sparclbl
+
+srcdir = @srcdir@
+include @builddir@/Makefile.meta
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/Makefile.sparclbl.app ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/Makefile.sparclbl.app
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/Makefile.sparclbl.app	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/Makefile.sparclbl.app	2018-03-13 14:39:35.160195000 -0400
@@ -0,0 +1,34 @@
+#$Id: Makefile.sparclbl.app$
+APP = sparclbl
+SRC = main argwrapper basealgo cdalignproc_base combistream datanode lxml ljson normbase offl_cd_align_proc offl_sparcle_data offldata prosite segset ustring
+# De-universalize Mac builds to work around a PPC toolchain limitation
+
+CFLAGS   = $(FAST_CXXFLAGS:ppc=i386)
+CXXFLAGS = $(FAST_CXXFLAGS:ppc=i386)
+LDFLAGS  = $(FAST_LDFLAGS:ppc=i386)
+
+CPPFLAGS = -D__DB_OFFLINE__ -I. \
+	$(ORIG_CPPFLAGS)
+
+LIB = \
+	blastxml \
+	xser xutil xncbi
+	
+##LIB_ = $(BLAST_INPUT_LIBS) $(BLAST_LIBS) xregexp $(PCRE_LIB) $(OBJMGR_LIBS)
+##LIB = $(LIB_:%=%$(STATIC))
+##
+### De-universalize Mac builds to work around a PPC toolchain limitation
+##CFLAGS   = $(FAST_CXXFLAGS:ppc=i386)
+##CXXFLAGS = $(FAST_CXXFLAGS:ppc=i386)
+##LDFLAGS  = $(FAST_LDFLAGS:ppc=i386)
+##
+##CPPFLAGS = -DNCBI_MODULE=BLAST $(ORIG_CPPFLAGS)
+
+
+
+
+##LIBS = $(CMPRS_LIBS) $(DL_LIBS) $(BZ2_LIBS) $(Z_LIBS) $(ORIG_LIBS)
+LIBS = $(BZ2_LIBS) $(Z_LIBS) $(DL_LIBS)
+
+
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/argwrapper.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/argwrapper.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/argwrapper.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/argwrapper.cpp	2018-03-13 14:39:35.431038000 -0400
@@ -0,0 +1,94 @@
+#include "argwrapper.hpp"
+
+USING_NCBI_SCOPE;
+
+const char TArgDefinition::EMPTYSTR[] = "";
+
+
+CArgDescriptions * ProcessArgDefinitions(const string &binname, const string &usage, const string &descr, const TArgDefinition *pDefs, size_t ndef, const TExtraArg *pExtra, size_t nextra, CArgDescriptions::EMiscFlags miscflgs)
+{
+
+	CArgDescriptions *pMyArgs = new CArgDescriptions;
+	pMyArgs->SetArgsType(CArgDescriptions::eRegularArgs);
+	pMyArgs->SetMiscFlags(miscflgs);
+	pMyArgs->SetUsageContext(binname, usage);
+	pMyArgs->SetDetailedDescription(descr);
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": ndef = " << ndef << ", pDefs = " << (void*)pDefs << endl;
+#endif
+// ***********************************************************/
+
+	if (nullptr != pDefs && ndef > 0)
+	{
+		// -- setup contraint for args, according to situations
+		// -- yet to find a way to specify them statically
+		// -- add args
+		for (size_t i = 0; i < ndef; ++i)
+		{
+			const TArgDefinition & argdef = pDefs[i];
+			switch (argdef.cat)
+			{
+			case TArgDefinition::eKey:
+				if (argdef.optional)
+				{
+					if (TArgDefinition::EMPTYSTR != argdef.def_val || TArgDefinition::EMPTYSTR != argdef.val_env)
+						pMyArgs->AddDefaultKey(argdef.name, argdef.synopsis, argdef.descr, argdef.type, argdef.def_val, argdef.flags, argdef.val_env, argdef.def_val);
+					else
+						pMyArgs->AddOptionalKey(argdef.name, argdef.synopsis, argdef.descr, argdef.type, argdef.flags);
+				}
+				else	//non-optional
+					pMyArgs->AddKey(argdef.name, argdef.synopsis, argdef.descr, argdef.type, argdef.flags);
+				if (TArgDefinition::EMPTYSTR != argdef.alias)
+					pMyArgs->AddAlias(argdef.alias, argdef.name);
+				break;
+			case TArgDefinition::eOpenPos:	//opening positional
+				pMyArgs->AddOpening(argdef.name, argdef.descr, argdef.type, argdef.flags);
+				if (TArgDefinition::EMPTYSTR != argdef.alias)
+					pMyArgs->AddAlias(argdef.alias, argdef.name);
+				break;
+			case TArgDefinition::ePos:	//positional
+				if (argdef.optional)
+				{
+					if (TArgDefinition::EMPTYSTR != argdef.def_val || TArgDefinition::EMPTYSTR != argdef.val_env)
+						pMyArgs->AddDefaultPositional(argdef.name, argdef.descr, argdef.type, argdef.def_val, argdef.flags, argdef.val_env, argdef.def_val);
+					else
+						pMyArgs->AddOptionalPositional(argdef.name, argdef.descr, argdef.type, argdef.flags);
+				}
+				else	//non-optional
+					pMyArgs->AddPositional(argdef.name, argdef.descr, argdef.type, argdef.flags);
+				if (TArgDefinition::EMPTYSTR != argdef.alias)
+					pMyArgs->AddAlias(argdef.alias, argdef.name);
+				break;
+			case TArgDefinition::eFlag:	//for flag, bool "optional" is used to "set_value"
+				pMyArgs->AddFlag(argdef.name, argdef.descr, argdef.optional);
+				if (TArgDefinition::EMPTYSTR != argdef.alias)
+					pMyArgs->AddAlias(argdef.alias, argdef.name);
+				break;
+			case TArgDefinition::eNegFlag:	//for negated flag, the 'alias' is used as the original flag it negates
+				pMyArgs->AddNegatedFlagAlias(argdef.name, argdef.alias, argdef.descr);
+				break;
+			}
+			if (nullptr != argdef.constraint)
+			{
+				pMyArgs->SetConstraint(argdef.name, argdef.constraint, argdef.neg_constraint);
+			}
+		}
+	}
+	
+	if (nullptr != pExtra && nextra > 0)
+	{
+		// -- add args
+		for (size_t i = 0; i < nextra; ++i)
+		{
+			const TExtraArg &argdef = pExtra[i];
+			pMyArgs->AddExtra(argdef.n_mandatory, argdef.n_optional, argdef.descr, argdef.type, argdef.flags);
+		}
+	}
+	
+	return pMyArgs;
+	
+}
+
+
+	
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/argwrapper.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/argwrapper.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/argwrapper.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/argwrapper.hpp	2018-03-13 14:39:35.436871000 -0400
@@ -0,0 +1,287 @@
+#if !defined(__ARG_WRAPPER__)
+#define __ARG_WRAPPER__
+
+#include <corelib/ncbiargs.hpp>
+#include <corelib/ncbitype.h>
+#include <corelib/ncbienv.hpp>
+#include <corelib/ncbifile.hpp>
+#include <string>
+
+//enum ncbi::CArgDescriptions::EType
+//{
+//	eString = 0, ///< An arbitrary string
+//	eBoolean,    ///< {'true', 't', 'false', 'f'},  case-insensitive
+//	eInt8,       ///< Convertible into an integer number (Int8 only)
+//	eInteger,    ///< Convertible into an integer number (int or Int8)
+//	eDouble,     ///< Convertible into a floating point number (double)
+//	eInputFile,  ///< Name of file (must exist and be readable)
+//	eOutputFile, ///< Name of file (must be writable)
+//	eIOFile,     ///< Name of file (must be writable)
+//	eDirectory,  ///< Name of file directory
+//	eDataSize,   ///< Integer number with possible "software" qualifiers (KB, KiB, et al)
+//	eDateTime,   ///< DateTime string, formats:
+//	             ///< "M/D/Y h:m:s", "Y-M-DTh:m:g", "Y/M/D h:m:g", "Y-M-D h:m:g".
+//	             ///< Time string can have trailing 'Z' symbol, specifying that
+//	             ///< it represent time in the UTC format.
+//	k_EType_Size ///< For internal use only
+//};
+
+//enum ncbi::CArgDescriptions::EFlags
+//{
+//	// File related flags:
+//	
+//	/// Open file right away; for eInputFile, eOutputFile, eIOFile
+//	fPreOpen = (1 << 0),
+//	/// Open as binary file; for eInputFile, eOutputFile, eIOFile
+//	fBinary  = (1 << 1), 
+//	/// Append to end-of-file; for eOutputFile or eIOFile 
+//	fAppend    = (1 << 2),
+//	/// Delete contents of an existing file; for eOutputFile or eIOFile 
+//	fTruncate  = (1 << 12),
+//	/// If the file does not exist, do not create it; for eOutputFile or eIOFile 
+//	fNoCreate = (1 << 11),
+//	/// If needed, create directory where the file is located
+//	fCreatePath = (1 << 8),
+//	
+//	/// Mask for all file-related flags
+//	fFileFlags = fPreOpen | fBinary | fAppend | fTruncate | fNoCreate | fCreatePath,
+//	// multiple keys flag:
+//	
+//	/// Repeated key arguments are legal (use with AddKey)
+//	fAllowMultiple = (1 << 3),
+//	
+//	// Error handling flags:
+//	
+//	/// Ignore invalid argument values. If not set, exceptions will be
+//	/// thrown on invalid values.
+//	fIgnoreInvalidValue = (1 << 4),
+//	/// Post warning when an invalid value is ignored (no effect
+//	/// if fIgnoreInvalidValue is not set).
+//	fWarnOnInvalidValue = (1 << 5),
+//	
+//	/// Allow to ignore separator between the argument's name and value.
+//	/// Usual ' ' or '=' separators can still be used with the argument.
+//	/// The following restrictions apply to a no-separator argument:
+//	///   - the argument must be a key (including optional or default);
+//	///   - the argument's name must be a single char;
+//	///   - no other argument's name can start with the same char,
+//	///     unless fOptionalSeparatorAllowConflict is also specified.
+//	fOptionalSeparator = (1 << 6),
+//	/// For arguments with fOptionalSeparator flag, allow
+//	/// other arguments which names begin with the same char.
+//	fOptionalSeparatorAllowConflict = (1 << 9),
+//	
+//	/// Require '=' separator
+//	fMandatorySeparator = (1 << 7),
+//	
+//	/// Hide it in Usage
+//	fHidden = (1 << 10),
+//	
+//	/// Confidential argument
+//	/// Such arguments can be read from command line, from file, or from
+//	/// console.
+//	/// On command line, they can appear in one of the following forms:
+//	///   -key                 -- read value from console, with automatically
+//	///                           generated prompt
+//	///   -key-file fname      -- read value from file 'fname',
+//	///                           if 'fname' equals '-',  read value from
+//	///                           standard input (stdin) without any prompt
+//	///   -key-verbatim value  -- read value from the command line, as is
+//	fConfidential  = (1 << 13)
+//};
+
+
+// -- old POD 
+struct TArgDefinition
+{
+	enum EArgCategory
+	{
+		eKey,
+		ePos,	//Positional
+		eOpenPos,	//Opening positional
+		eFlag,
+		eNegFlag
+	};
+	static const char EMPTYSTR[];
+	
+	const char * name;
+	EArgCategory cat;
+	ncbi::CArgDescriptions::EType type;
+	const char * descr;
+	bool optional;	//with eFlag, this field serve as enum EFlagValue {eFlagHasValueIfMissed = 0, eFlagHasValueIfSet = 1}
+	const char * synopsis;
+	const char * alias;
+	ncbi::CArgDescriptions::TFlags flags;	//flags
+	const char * val_env;	//environment contains the value
+	const char * def_val;	//default value for optional arguments
+	ncbi::CArgAllow * constraint;
+	ncbi::CArgDescriptions::EConstraintNegate neg_constraint;
+};
+
+struct TExtraArg
+{
+	unsigned int n_mandatory;
+	unsigned int n_optional;
+	const char * descr;
+	ncbi::CArgDescriptions::EType type;
+	ncbi::CArgDescriptions::TFlags flags;	//flags	
+};
+
+template <typename TEnumLitType>
+ncbi::CArgAllow * AllowEnumLits()
+{
+	if (0 == TEnumLitType::eEnumStop) return nullptr;
+	
+	ncbi::CArgAllow_Strings * pAllowed = new ncbi::CArgAllow_Strings;
+	for (int i = 0; i < TEnumLitType::eEnumStop; ++i)
+		pAllowed->AllowValue(TEnumLitType::dimLits[i]);
+	
+	return pAllowed;
+}
+// -- binname = the binary name, usually argv[0]
+
+
+//enum EMiscFlags
+//{
+//	fNoUsage        = 1 << 0,  ///< Do not print USAGE on argument error.
+//	fUsageIfNoArgs  = 1 << 1,  ///< Force printing USAGE (and then exit)
+//	                           ///< if no command line args are present.
+//	fUsageSortArgs  = 1 << 2,  ///< Sort args when printing USAGE.
+//	fDupErrToCerr   = 1 << 3,  ///< Print arg error to both log and cerr.
+//	
+//	fMisc_Default   = 0
+//};
+
+ncbi:: CArgDescriptions * ProcessArgDefinitions(const std::string &binname, const std::string &usage, const std::string &descr, const TArgDefinition *pDefs, size_t ndef, const TExtraArg *pExtra = nullptr, size_t nextra = 0, ncbi::CArgDescriptions::EMiscFlags miscflgs = ncbi::CArgDescriptions::fMisc_Default);
+#endif
+/*************************************************************************
+*	Sample code for apps using this setup
+// ***********************************************************************
+#include <CArgWrapper/cargwrapper.hpp>
+//customize Argument definition
+static const char *PROGRAM_USAGE = "...";
+static const char *PROGRAM_DESCRIPTION =	//multiline
+"..."
+"..."
+"...";
+
+static constexpr const struct TVER
+{
+	int major;
+	int minor;
+	int patch_level;
+} VER = {0, 0, 1};
+
+
+// -- give argument index names
+enum EArgIndice: unsigned int
+{
+	// -- name-indice here. C++ standard, if no value explicitly assigned, enumerators start from 0 and increase by 1
+	argName,
+	argAge,
+	....
+	// ------------------------
+	TOTALARGS	//This natually as arg count.
+};
+
+static TArgDefinition dimValidArgs[] = 
+{
+	// -- define your valid arguments
+	// -- do not use nullptr. use EMPTYSTR as empty string
+	{
+		"name",	//switch
+		TArgDefinition::eKey,	//enum TArgDefinition::EArgCategory(argument type: eKey, ePos, eOpenPos, eFlag, eNegFlag)
+		ncbi::CArgDescriptions::eString,	//ncbi::CArgDescriptions::EType(process type)
+		"Specify user name",	//string (description)
+		true,	//if optional
+		TArgDefinition::EMPTYSTR,	//Synopsis (short description)
+		TArgDefinition::EMPTYSTR,	//alias (can be used to specify at command line but not indexed in program
+		0,	//ncbi::CArgDescriptions::EFlags
+		TArgDefinition::EMPTYSTR,	//value environment var (read arg value from this environment variable)
+		"anyone",	//Default Value
+		nullptr,	//ncbi::CArgAllow * , constraint
+		ncbi::CArgDescriptions::eConstraint	//ncbi::CArgDescriptions::EConstraintNegate, eConstraint or eConstraintInvert
+	},
+	{
+		"age",	//switch
+		TArgDefinition::eKey,	//enum TArgDefinition::EArgCategory(argument type: eKey, ePos, eOpenPos, eFlag, eNegFlag)
+		ncbi::CArgDescriptions::eInteger,	//ncbi::CArgDescriptions::EType(process type)
+		"Specify user age",	//string (description)
+		true,	//if optional
+		TArgDefinition::EMPTYSTR,	//Synopsis (short description)
+		TArgDefinition::EMPTYSTR,	//alias (can be used to specify at command line but not indexed in program
+		0,	//ncbi::CArgDescriptions::EFlags
+		TArgDefinition::EMPTYSTR,	//value environment var (read arg value from this environment variable)
+		"28",	//Default Value
+		nullptr,	//ncbi::CArgAllow * , constraint
+		ncbi::CArgDescriptions::eConstraint	//ncbi::CArgDescriptions::EConstraintNegate, eConstraint or eConstraintInvert
+	},
+	//......
+};
+
+// -- positional arguments
+static const size_t TOTALEXTRAARGS = 1;
+static TExtraArg dimValidExtraArgs[] = 
+{
+	{0, kMax_UInt, "Files that contain genomic sequence data. If none specified, read sequence data from stdin.", ncbi::CArgDescriptions::eInputFile, 0}
+};
+
+string bin_name;
+
+class CMyApp: public CNcbiApplication
+{
+public:
+	CMyApp(void);
+	virtual void Init(void);
+	virtual int Run(void);
+	virtual void Exit(void);
+private:
+	string m_bin_loc;
+	string m_bin_name;
+	CNcbiRegistry m_reg;
+};
+
+CMyApp::CMyApp(void): CNcbiApplication(), m_bin_loc(), m_bin_name(), m_reg()
+{
+	size_t lastslash = m_bin_loc.rfind('/');
+	m_bin_loc = bin_name.substr(0, lastslash);
+	m_bin_name = bin_namesubstr(lastslash + 1);
+	SetVersion(CVersionInfo(VER.major, VER.minor, VER.patch_level));
+}
+
+void CMyApp::Init(void)
+{
+	// -- first
+	CNcbiApplication::Init();
+	SetupArgDescriptions(ProcessArgDefinitions(bin_name, PROGRAM_USAGE, PROGRAM_DESCRIPTION, dimValidArgs, TOTALARGS, dimValidExtraArgs, TOTALEXTRAARGS));
+}
+
+int CMyApp::Run(void)
+{
+	int retVal = 0;
+	const CArgs & args = GetArgs();
+	
+	const CArgValue
+		&AV_name = args[dimValidArgs[argName].name],
+		&AV_age = args[dimValidArgs[argAge].name],
+	
+labelReturn:
+	return retVal;
+}
+
+void CMyApp::Exit(void)
+{
+	
+	// -- last
+	CNcbiApplication::Exit();
+}
+
+
+int main(int argc, char * argv[])
+{
+	bin_name = CDirEntry::CreateAbsolutePath(argv[0], CDirEntry::eRelativeToExe);
+	return CMyApp().AppMain(argc, argv);
+}
+
+
+*************************************************************************/
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/atomic.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/atomic.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/atomic.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/atomic.hpp	2018-03-13 14:39:35.312802000 -0400
@@ -0,0 +1,15 @@
+#if !defined(__STD_STOMIC__)
+#define __STD_STOMIC__
+
+#include <atomic>
+#include "normbase.hpp"
+
+//std::atomic guarantees whatever alignment is necessary
+typedef INT64 TAtomicCounterValueType;
+typedef std::atomic<TAtomicCounterValueType> TAtomicCounterType;
+	
+
+
+
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/basealgo.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/basealgo.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/basealgo.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/basealgo.cpp	2018-03-13 14:39:35.214067000 -0400
@@ -0,0 +1,822 @@
+#include "basealgo.hpp"
+#include <cstdarg>
+#include <cstring>
+using namespace std;
+
+void TrimString(string &ori) noexcept
+{
+	size_t pos0 = 0, pos1 = ori.size(), len = pos1;
+	while (pos0 < pos1)
+	{
+		if (ori[pos0] > ' ')
+			break;
+		++pos0;
+	}
+	
+	while (pos1 > pos0)
+	{
+		if (ori[pos1 - 1] > ' ')
+			break;
+		--pos1;
+	}
+	
+	if (pos1 - pos0 < len)
+		ori = ori.substr(pos0, pos1 - pos0);
+}
+
+string TrimString(string &&ori) noexcept
+{
+	TrimString(ori);
+	return move(ori);
+}
+
+void LTrimString(string &ori) noexcept
+{
+	size_t pos = 0, len = ori.size();
+	while (pos < len)
+	{
+		if (ori[pos] > ' ')
+			break;
+		++pos;
+	}
+	
+	if (pos > 0)
+		ori = ori.substr(pos);
+}
+
+string LTrimString(string &&ori) noexcept
+{
+	LTrimString(ori);
+	return move(ori);
+}
+
+void RTrimString(string &ori) noexcept
+{
+	size_t pos = ori.size(), len = pos;
+	while (pos > 0)
+	{
+		if (ori[pos - 1] > ' ')
+			break;
+		--pos;
+	}
+	
+	if (pos < len)
+		ori = ori.substr(0, pos);
+}
+
+string RTrimString(string &&ori) noexcept
+{
+	RTrimString(ori);
+	return move(ori);
+}
+
+
+char* StrCat(const char* lpszFirst...)
+{
+	if (nullptr == lpszFirst) return nullptr;
+	va_list pArgs;
+	va_start(pArgs, lpszFirst);
+	unsigned int uiSize = 0;
+	const char *lpszOneStr = lpszFirst;
+	do
+	{
+		uiSize += strlen(lpszOneStr);	//calculate
+	}while (nullptr != (lpszOneStr = va_arg(pArgs, char*)));	//deal with it until nullptr
+	
+	char *lpszResult = new char[uiSize + 1];	//allocate
+	lpszOneStr = lpszFirst;
+	char *pDest = lpszResult;
+	
+	// -- second time loop -- copy strings
+	va_start(pArgs, lpszFirst);
+	do	//deal with it until nullptr
+	{
+		while ((*pDest++ = *lpszOneStr++));
+		pDest--;
+	}while (nullptr != (lpszOneStr = va_arg(pArgs, char*)));
+	va_end(pArgs);
+	return lpszResult;
+}
+
+void StrCatBuf(char * buf, const char* lpszFirst...)
+{
+	if (nullptr == lpszFirst) return;
+	char * pDest = buf;
+	va_list pArgs;
+	va_start(pArgs, lpszFirst);
+	const char *lpszOneStr = lpszFirst;
+	do
+	{
+		while ((*pDest++ = *lpszOneStr++));
+		pDest--;
+
+	}while (nullptr != (lpszOneStr = va_arg(pArgs, char*)));	//deal with it until nullptr
+
+	va_end(pArgs);
+}
+
+size_t StrToUpper(string &dst)
+{
+	size_t count = 0;
+	
+	for (string::iterator iter = dst.begin(), iterEnd = dst.end(); iterEnd != iter; ++iter)
+	{
+		*iter = toupper(*iter);
+		++count;
+	}
+	return count;
+}
+
+size_t StrToLower(string &dst)
+{
+	size_t count = 0;
+	
+	for (string::iterator iter = dst.begin(), iterEnd = dst.end(); iterEnd != iter; ++iter)
+	{
+		*iter = tolower(*iter);
+		++count;
+	}
+	return count;
+}
+
+
+size_t StringReplace(string& rText, const string& rOld, const string& rNew)
+{
+	size_t counter = 0;
+	size_t old_len = rOld.length(), new_len = rNew.length();
+	
+	size_t pos = rText.find(rOld);
+	while (string::npos != pos)	//found instance
+	{
+		++counter;	//counting
+		rText.replace(pos, old_len, rNew);
+		pos = rText.find(rOld, pos + new_len);	//skip rNew. will not replace instance inside rNew
+	}
+	return counter;
+}
+
+
+
+
+void CStringTokenizer::SplitString(const string& rSrcStr, const string& rToken, vector<string>& container)
+{
+	container.clear();
+	if (rSrcStr.empty()) return;
+	
+	size_t total = rSrcStr.size(), token_len = rToken.size(), last_pos = 0;
+	
+labelNext:
+	size_t pos = rSrcStr.find(rToken, last_pos);
+	if (pos == string::npos)
+	{
+		container.emplace_back(rSrcStr.substr(last_pos));
+		return;
+	}
+	
+	container.emplace_back(rSrcStr.substr(last_pos, pos - last_pos));
+	last_pos = pos + token_len;
+	goto labelNext;
+}
+
+
+void CStringTokenizer::SplitString(const string& rSrcStr, char tk, vector<string>& container)
+{
+	container.clear();
+	if (rSrcStr.empty()) return;
+	
+	size_t total = rSrcStr.size(), last_pos = 0;
+	
+labelNext:
+	size_t pos = rSrcStr.find(tk, last_pos);
+	if (pos == string::npos)
+	{
+		container.emplace_back(rSrcStr.substr(last_pos));
+		return;
+	}
+	
+	container.emplace_back(rSrcStr.substr(last_pos, pos - last_pos));
+	last_pos = pos + 1;
+	goto labelNext;
+}
+
+
+
+CStringTokenizer::CStringTokenizer(const string &str, const string & tk):
+	m_src(&str), m_token(tk), m_len(m_src->size()), m_tklen(m_token.size()), m_pos(0)
+{}
+
+
+CStringTokenizer::CStringTokenizer(const std::string &str, std::string && tk):
+	m_src(&str), m_token(move(tk)), m_len(m_src->size()), m_tklen(m_token.size()), m_pos(0)
+{}
+
+CStringTokenizer::CStringTokenizer(const string &str, char tk):
+	m_src(&str), m_token(1, tk), m_len(m_src->size()), m_tklen(m_token.size()), m_pos(0)
+{}
+
+void CStringTokenizer::Reset(const string &str, const string & tk)
+{
+	m_src = &str;
+	m_token = tk;
+	m_len = m_src->size();
+	m_tklen = m_token.size();
+	m_pos = 0;
+}
+
+void CStringTokenizer::Reset(const string &str, string && tk)
+{
+	m_src = &str;
+	m_token = move(tk);
+	m_len = m_src->size();
+	m_tklen = m_token.size();
+	m_pos = 0;
+}
+
+void CStringTokenizer::Reset(const string &str, char tk)
+{
+	m_src = &str;
+	m_token.clear();
+	m_token.push_back(tk);
+	m_len = m_src->size();
+	m_tklen = 1;
+	m_pos = 0;
+}
+
+string CStringTokenizer::get(void) const
+{
+	if (m_pos >= m_len) throw 0;
+	size_t pos1 = m_src->find(m_token, m_pos);
+	if (string::npos == pos1)	//last one
+		pos1 = m_len;
+	size_t tp0 = m_pos;
+	m_pos = pos1 + m_tklen;
+	return m_src->substr(tp0, pos1 - tp0);
+}
+
+
+
+
+
+char * B64Encode(const void * blob, size_t &bytes)
+{
+	static char baseTable[65] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
+	
+	if (0 == bytes || nullptr == blob) return nullptr;
+	
+	ldiv_t grp_info = ldiv((long)bytes, 3);
+	
+	
+	unsigned char *pBlob = (unsigned char *)blob;
+	
+	char * result = new char [(grp_info.quot + 1) * 4];
+	memset(result, 0, sizeof(unsigned char) * (grp_info.quot + 1) * 4);
+	
+	char * dest = result;
+	
+	
+	for (long i = 0; i < grp_info.quot; ++i)
+	{
+		dest[0] = baseTable[pBlob[0] >> 2];
+		dest[1] = baseTable[((pBlob[0] & 0x3) << 4) + (pBlob[1] >> 4)];
+		dest[2] = baseTable[((pBlob[1] & 0xf) << 2) + (pBlob[2] >> 6)];
+		dest[3] = baseTable[pBlob[2] & 0x3f];
+		dest += 4;
+		pBlob += 3;
+	}
+	
+	// -- at this point pBlob already pointed to the rest bytes
+	
+	if (grp_info.rem > 0)
+	{
+		unsigned char remainder[3];
+		remainder[0] = remainder[1] = remainder[2] = 0;
+		for (long i = 0; i < grp_info.rem; ++i) remainder[i] = pBlob[i];
+		
+		dest[0] = baseTable[remainder[0] >> 2];
+		
+		if (1 == grp_info.rem)
+		{
+			dest[1] = baseTable[((remainder[0] & 0x3) << 4) + (remainder[1] >> 4)];
+			dest[2] = dest[3] = '=';
+			
+		}
+		else if (2 == grp_info.rem)
+		{
+			dest[1] = baseTable[((remainder[0] & 0x3) << 4) + (remainder[1] >> 4)];
+			dest[2] = baseTable[((remainder[1] & 0xf) << 2) + (remainder[2] >> 6)];
+			dest[3] = '=';
+		}
+		
+		++grp_info.quot;
+	}
+	
+	bytes = grp_info.quot * 4;
+	
+	return result;
+}
+
+unsigned char __B64BitValue(char c)
+{
+	if ('+' == c) return 62;
+	if ('/' == c) return 63;
+	if ('#' == c) return 0;
+	if (c <= '9') return c - '0' + 52;
+	if (c <= 'Z') return c - 'A';
+	return c - 'a' + 26;
+}
+
+unsigned char * B64Decode(const char * src, size_t &bytes)
+{
+	if (nullptr == src || 0 == bytes) return nullptr;
+	const char * src_end = src + bytes;
+		
+	size_t grps = bytes / 4;
+	size_t dst_len = grps * 3;
+	
+	
+	unsigned char *buf = new unsigned char [dst_len];
+	memset(buf, 0, dst_len * sizeof(unsigned char));
+	
+	const char * src_idx = src;
+	unsigned char * dst_idx = buf;
+	
+	char src_grp[4];
+	int src_grp_idx = 0;
+	
+	int pad_idx = -1;
+	
+	while (src_idx < src_end)
+	{
+		if (isalnum(*src_idx) || '+' == *src_idx || '/' == *src_idx)	//skip invalid chars
+		{
+			if (pad_idx >= 0)	//error: normal characters after '='
+				goto error_return;
+			src_grp[src_grp_idx++] = *src_idx;
+		}
+		else if ('=' == *src_idx)
+		{
+			if (src_grp_idx < 2)	//invalid situation. error in src string
+				goto error_return;
+			if (pad_idx < 0) pad_idx = src_grp_idx;
+			src_grp[src_grp_idx++] = *src_idx;
+		}
+		
+		if (src_grp_idx >= 4)	//do decoding for one group
+		{
+			
+			
+
+			unsigned char v0 = __B64BitValue(src_grp[0]);
+			unsigned char v1 = __B64BitValue(src_grp[1]);
+			unsigned char v2 = __B64BitValue(src_grp[2]);
+			unsigned char v3 = __B64BitValue(src_grp[3]);
+			
+			
+			dst_idx[0] = (v0 << 2) + (v1 >> 4);
+			dst_idx[1] = ((v1 & 0xf) << 4) + (v2 >> 2);
+			dst_idx[2] = ((v2 & 0x3) << 6) + v3;
+			
+			dst_idx += 3;
+			src_grp_idx = 0;
+			
+			if (pad_idx >= 0) break;
+		}
+		++src_idx;
+	}
+
+	
+	if (src_grp_idx > 0) goto error_return;//incomplete set, error
+	
+	switch (pad_idx)
+	{
+		case -1:
+			bytes = dst_idx - buf;
+			break;
+		case 2:
+			bytes = dst_idx - buf - 2;
+			break;
+		case 3:
+			bytes = dst_idx - buf - 1;
+			break;
+		default:
+			goto error_return;
+	}
+	
+	return buf;
+	
+error_return:
+	delete [] buf;
+	bytes = 0;
+	return nullptr;
+	
+}
+
+
+struct _xMD5Implement
+{
+	static constexpr const size_t U32ChunkSize = 16;
+	static constexpr const size_t ByteChunkSize = 4 * U32ChunkSize;
+	static constexpr const size_t BLOCKSIZE = 64;
+	static const UINT32 s[BLOCKSIZE];
+	
+	
+	
+	inline
+	static UINT32 rotl (UINT32 x, UINT32 w)
+	{
+    return (x << w) | (x >> (32 - w));
+  };
+	_xMD5Implement(void);	//just initialize
+	
+	UINT32 m_K[BLOCKSIZE];
+	
+	UINT32 a, b, c, d;
+	
+	void DigestChunk(const UINT32 *mblock);
+	
+	string GetHexString(void) const;
+  
+};
+
+const UINT32 _xMD5Implement::s[]
+{
+	7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,
+	5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,
+	4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,
+	6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21
+};
+
+string _xMD5Implement::GetHexString(void) const
+{
+
+	char dimBuf[33];
+	char *pidx = dimBuf;
+	
+	UINT32 byte_mask = 0xff, nib_mask = 0xf;
+	
+	UINT32 _a = a, _b = b, _c = c, _d = d;
+	
+	BYTE bt = (BYTE) (_a & byte_mask);
+
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_a >>= 8;
+	bt = (BYTE) (_a & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_a >>= 8;
+	bt = (BYTE) (_a & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_a >>= 8;
+	bt = (BYTE) (_a & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	
+	bt = (BYTE) (_b & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_b >>= 8;
+	bt = (BYTE) (_b & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_b >>= 8;
+	bt = (BYTE) (_b & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_b >>= 8;
+	bt = (BYTE) (_b & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	
+	bt = (BYTE) (_c & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_c >>= 8;
+	bt = (BYTE) (_c & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_c >>= 8;
+	bt = (BYTE) (_c & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_c >>= 8;
+	bt = (BYTE) (_c & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	
+	bt = (BYTE) (_d & byte_mask);
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_d >>= 8;
+	bt = (BYTE) (_d & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_d >>= 8;
+	bt = (BYTE) (_d & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	_d >>= 8;
+	bt = (BYTE) (_d & byte_mask);
+
+	*pidx++ = Nib2Char(bt >> 4);
+	*pidx++ = Nib2Char(bt & nib_mask);
+	
+	*pidx = '\0';
+	return string(dimBuf);
+}
+
+_xMD5Implement::_xMD5Implement(void):
+	m_K
+	{
+		0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,
+		0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,
+		0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,
+		0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,
+		0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,
+		0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,
+		0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,
+		0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,
+		0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,
+		0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,
+		0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,
+		0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,
+		0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,
+		0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,
+		0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,
+		0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391
+	},
+	a{0x67452301},
+	b{0xefcdab89},
+	c{0x98badcfe},
+	d{0x10325476}
+	
+{}
+
+void _xMD5Implement::DigestChunk(const UINT32 *mblock)
+{
+
+	UINT32 A = a, B = b, C = c, D = d;
+	UINT32 F = 0, g = 0;
+	
+	for (size_t i = 0; i < 16; ++i)
+	{
+		F = (B & C) | ((~B) & D);
+		g = i;
+		
+		F = F + A + m_K[i] + mblock[g];
+    A = D;
+    D = C;
+    C = B;
+    B = B + _xMD5Implement::rotl(F, _xMD5Implement::s[i]);
+	}
+	
+	for (size_t i = 16; i < 32; ++i)
+	{
+		F = (D & B) | ((~D) & C);
+		g = (5 * i + 1) % 16;
+		
+		F = F + A + m_K[i] + mblock[g];
+    A = D;
+    D = C;
+    C = B;
+    B = B + _xMD5Implement::rotl(F, _xMD5Implement::s[i]);
+	}
+	
+	for (size_t i = 32; i < 48; ++i)
+	{
+		F = B ^ C ^ D;
+		g = (3 * i + 5) % 16;
+		
+		F = F + A + m_K[i] + mblock[g];
+    A = D;
+    D = C;
+    C = B;
+    B = B + _xMD5Implement::rotl(F, _xMD5Implement::s[i]);
+	}
+	
+	for (size_t i = 48; i < 64; ++i)
+	{
+		F = C ^ (B | (~D));
+		g = (7 * i) % 16;
+		
+		F = F + A + m_K[i] + mblock[g];
+    A = D;
+    D = C;
+    C = B;
+    B = B + _xMD5Implement::rotl(F, _xMD5Implement::s[i]);
+	}
+	
+	a += A;
+	b += B;
+	c += C;
+	d += D;
+}
+
+
+string MD5Digest(const void* bytes, UINT64 n)
+{
+	UINT64 ori_total_bits = n << 3;
+	
+	UINT32 msg_chunk[_xMD5Implement::U32ChunkSize];
+	
+	_xMD5Implement md5dev;
+
+	UINT64 chars_left = n;
+	const BYTE * psrc = (const BYTE*)bytes;
+	
+	while (chars_left >= _xMD5Implement::ByteChunkSize)
+	{
+		//memset(msg_chunk, 0, _xMD5Implement::U32ChunkSize * sizeof(UINT32));
+		for (size_t i = 0; i < _xMD5Implement::U32ChunkSize; ++i)
+		{
+			msg_chunk[i] = (UINT32)(*psrc++);
+			msg_chunk[i] |= (UINT32)(*psrc++) << 8;
+			msg_chunk[i] |= (UINT32)(*psrc++) << 16;
+			msg_chunk[i] |= (UINT32)(*psrc++) << 24;
+		}
+		
+		md5dev.DigestChunk(msg_chunk);
+		chars_left -= _xMD5Implement::ByteChunkSize;
+	}
+	
+	BYTE patch[_xMD5Implement::ByteChunkSize];
+	memset(patch, 0, _xMD5Implement::ByteChunkSize);
+	
+	if (chars_left > 0)
+		memcpy(patch, psrc, chars_left);
+	
+	BYTE *pp = patch + chars_left;
+	*pp = 128;
+	pp = patch;
+	if (chars_left >= _xMD5Implement::ByteChunkSize - 8)	//not enough space for patching, must add additional chunk
+	{
+		//memset(msg_chunk, 0, _xMD5Implement::U32ChunkSize * sizeof(UINT32));
+		for (size_t i = 0; i < _xMD5Implement::U32ChunkSize; ++i)
+		{
+			msg_chunk[i] = (UINT32)(*pp++);
+			msg_chunk[i] |= (UINT32)(*pp++) << 8;
+			msg_chunk[i] |= (UINT32)(*pp++) << 16;
+			msg_chunk[i] |= (UINT32)(*pp++) << 24;
+		}
+		
+		md5dev.DigestChunk(msg_chunk);
+		
+		// -- next chunk will all be 0 except last 8 bytes
+		memset(msg_chunk, 0, (_xMD5Implement::U32ChunkSize - 2) * sizeof(UINT32));
+	}
+	else	//finish in this 
+	{
+		//memset(msg_chunk, 0, _xMD5Implement::U32ChunkSize * sizeof(UINT32));
+		
+		for (size_t i = 0; i < _xMD5Implement::U32ChunkSize - 2; ++i)
+		{
+			msg_chunk[i] = (UINT32)(*pp++);
+			msg_chunk[i] |= (UINT32)(*pp++) << 8;
+			msg_chunk[i] |= (UINT32)(*pp++) << 16;
+			msg_chunk[i] |= (UINT32)(*pp++) << 24;
+		}
+	}
+	// -- all little endian, but switch the hi-32 bit and lo 32bit
+	msg_chunk[_xMD5Implement::U32ChunkSize - 2] = ori_total_bits & 0xffffffff;
+	msg_chunk[_xMD5Implement::U32ChunkSize - 1] = ori_total_bits >> 32;
+	md5dev.DigestChunk(msg_chunk);
+	
+	return md5dev.GetHexString();
+	
+}
+
+string MD5Digest(const string & msg)
+{
+	return MD5Digest(msg.data(), msg.size());
+}
+
+// -- unknown size at first
+// -- istr must open as binary
+string MD5Digest(istream &istr)
+{
+	if (!istr.good())
+		THROW_SIMPLE("Input stream error: Cannot read");
+		
+	UINT64 total_bytes = 0;
+	BYTE byte_buf[_xMD5Implement::ByteChunkSize];
+	UINT32 msg_chunk[_xMD5Implement::U32ChunkSize];
+	_xMD5Implement md5dev;
+	
+	istr.read(reinterpret_cast< char * > (byte_buf), _xMD5Implement::ByteChunkSize);
+	
+	// -- read full _xMD5Implement::ByteChunkSize bytes as expected
+	while (istr.good())
+	{
+		//memset(msg_chunk, 0, _xMD5Implement::U32ChunkSize * sizeof(UINT32));
+		const BYTE *psrc = byte_buf;
+		for (size_t i = 0; i < _xMD5Implement::U32ChunkSize; ++i)
+		{
+			msg_chunk[i] = (UINT32)(*psrc++);
+			msg_chunk[i] |= (UINT32)(*psrc++) << 8;
+			msg_chunk[i] |= (UINT32)(*psrc++) << 16;
+			msg_chunk[i] |= (UINT32)(*psrc++) << 24;
+		}
+		md5dev.DigestChunk(msg_chunk);
+		total_bytes += _xMD5Implement::ByteChunkSize;
+		istr.read(reinterpret_cast< char * > (byte_buf), _xMD5Implement::ByteChunkSize);
+	}
+	
+	UINT64 last_read_bcount = istr.gcount();
+	total_bytes = (total_bytes + last_read_bcount) << 3;	//turn to total bits
+	
+	BYTE *pp = byte_buf + last_read_bcount;
+	// -- reset the rest buffer
+	memset(byte_buf + last_read_bcount, 0, _xMD5Implement::ByteChunkSize - last_read_bcount);
+	*pp = 128;	//append 1
+	pp = byte_buf;
+	if (last_read_bcount >= _xMD5Implement::ByteChunkSize - 8)	// not enough space for patching. must 
+	{
+		for (size_t i = 0; i < _xMD5Implement::U32ChunkSize; ++i)
+		{
+			msg_chunk[i] = (UINT32)(*pp++);
+			msg_chunk[i] |= (UINT32)(*pp++) << 8;
+			msg_chunk[i] |= (UINT32)(*pp++) << 16;
+			msg_chunk[i] |= (UINT32)(*pp++) << 24;
+		}
+		md5dev.DigestChunk(msg_chunk);	//handle this chunk
+		
+		// -- prepare for next (the last) chunk: all UNIT32 but the last two must be 0
+		// -- the last two are for total bit length
+		memset(msg_chunk, 0, (_xMD5Implement::U32ChunkSize - 2) * sizeof(UINT32));
+	}
+	else	//there is enough space for patching
+	{
+		// -- fill all UNIT32 but the last two
+		for (size_t i = 0; i < _xMD5Implement::U32ChunkSize - 2; ++i)
+		{
+			msg_chunk[i] = (UINT32)(*pp++);
+			msg_chunk[i] |= (UINT32)(*pp++) << 8;
+			msg_chunk[i] |= (UINT32)(*pp++) << 16;
+			msg_chunk[i] |= (UINT32)(*pp++) << 24;
+		}
+	}
+	
+	// -- all little endian, but switch the hi-32 bit and lo 32bit
+	msg_chunk[_xMD5Implement::U32ChunkSize - 2] = total_bytes & 0xffffffff;
+	msg_chunk[_xMD5Implement::U32ChunkSize - 1] = total_bytes >> 32;
+	md5dev.DigestChunk(msg_chunk);
+	
+	return md5dev.GetHexString();
+	
+
+}
+
+inline
+unsigned int helpsrand(void) noexcept
+{
+	unsigned int rs = time(0);
+	srand(rs);
+	return rs;
+}
+
+int GetRandInt(int max)
+{
+	static unsigned int rs = helpsrand();
+	
+	int r = rand();
+	if (max < RAND_MAX)
+		r %= (max + 1);
+	return r;
+}
+
+string GetRandomString(void)
+{
+	int rn = GetRandInt();
+	return MD5Digest(&rn, sizeof(int));
+}
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/basealgo.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/basealgo.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/basealgo.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/basealgo.hpp	2018-03-13 14:39:35.220945000 -0400
@@ -0,0 +1,255 @@
+#if !defined(__BASE_ALGO__)
+#define __BASE_ALGO__
+
+#include "normbase.hpp"
+
+#include <list>
+#include <vector>
+#include <algorithm>
+/**********************************************************************
+*	Very basic string operations
+**********************************************************************/
+// -- trim both ends
+void TrimString(std::string &ori) noexcept;
+std::string TrimString(std::string &&ori) noexcept;
+// -- trim start
+void LTrimString(std::string &ori) noexcept;
+std::string LTrimString(std::string &&ori) noexcept;
+// -- trim end
+void RTrimString(std::string &ori) noexcept;
+std::string RTrimString(std::string &&ori) noexcept;
+
+
+// -- string to upper or to lower: user std::transform:
+// -- std::transform(str.begin(), str.end(), ::toupper)
+
+char * StrCat(const char* lpszFirst...);
+// -- caller must guarantee the buf is big enough
+void StrCatBuf(char * buf, const char* lpszFirst...);
+
+size_t StrToUpper(std::string &dst);
+size_t StrToLower(std::string &dst);
+
+size_t StringReplace(std::string& rText, const std::string& rOld, const std::string& rNew);
+
+// -- nib: value between 0 - 15
+inline
+char Nib2Char(BYTE nib)
+{
+	return nib > 9 ? (nib - 10 + 'a') : (nib + '0');
+}
+
+class CStringTokenizer
+{
+public:
+	
+	static void SplitString(const std::string& rSrcStr, const std::string& rToken, std::vector<std::string>& container);
+	static void SplitString(const std::string& rSrcStr, char tk, std::vector<std::string>& container);
+	
+	
+	CStringTokenizer(const std::string &str, const std::string & tk);
+	CStringTokenizer(const std::string &str, std::string && tk);
+	CStringTokenizer(const std::string &str, char tk);
+	
+	void Reset(const std::string &str, const std::string & tk);
+	void Reset(const std::string &str, std::string && tk);
+	void Reset(const std::string &str, char tk);
+	
+	// -- will throw integer 0 when done
+	std::string get(void) const;
+	
+private:
+	const std::string *m_src;
+	std::string m_token;
+	size_t m_len, m_tklen;
+	mutable size_t m_pos;
+};
+
+// *******************************************************************/
+	
+/**********************************************************************
+*	Algorithms based on sorted vector. For total data load, use CCompactStore class
+**********************************************************************/
+// -- target vector assumed to be ascendingly ordered and TDataType must have operator < () and operator == defined
+// -- return true if found, pos contains the position. Otherwise return false with pos unchanged
+template <typename TDataType>
+bool BinSearchData(const std::vector<TDataType> & src, const TDataType& data, size_t &pos)
+{
+	size_t rbegin = 0, rend = src.size(), dist = rend - rbegin;
+	
+	while (dist > 0)
+	{
+		size_t rmid = rbegin + (dist >> 1);
+		if (src[rmid] == data)
+		{
+			pos = rmid;
+			return true;
+		}
+		else if (src[rmid] < data) rbegin = rmid + 1;
+		else rend = rmid;
+		dist = rend - rbegin;
+	}
+	
+	return false;
+}
+
+
+
+// -- same as above, but use a user-defined object to compare.
+// -- the user object must have
+// -- int operator () (const TDataType &v1, const TDataType &v2) const
+// -- return 0: two values of TDataType are equivalent
+// -- return -1: means v1 < v2
+// -- return 1: means v1 > v2
+// -- defined.
+
+template <typename TDataType, typename TComp>
+bool BinSearchData(const std::vector<TDataType> & src, const TDataType& data, size_t &pos, TComp comp)
+{
+	size_t rbegin = 0, rend = src.size(), dist = rend - rbegin;
+	
+	while (dist > 0)
+	{
+		size_t rmid = rbegin + (dist >> 1);
+		int ord = comp(src[rmid], data);
+		if (0 == ord)
+		{
+			pos = rmid;
+			return true;
+		}
+		else if (ord < 0) rbegin = rmid + 1;
+		else rend = rmid;
+		dist = rend - rbegin;
+	}
+	return false;
+}
+
+// -- search against a key, usually a member of TDataType if TDataType is a structure
+// -- TComp must provide compare operator(const TKeyType &, const TDataType &)
+template <typename TKeyType, typename TDataType, typename TComp>
+bool BinSearchData(const TKeyType &key, const std::vector<TDataType> & src, size_t &pos, TComp comp)
+{
+	size_t rbegin = 0, rend = src.size(), dist = rend - rbegin;
+	
+	while (dist > 0)
+	{
+		size_t rmid = rbegin + (dist >> 1);
+		int ord = comp(src[rmid], key);
+		if (0 == ord)
+		{
+			pos = rmid;
+			return true;
+		}
+		else if (ord < 0) rbegin = rmid + 1;
+		else rend = rmid;
+		dist = rend - rbegin;
+	}
+	return false;
+}
+
+template<typename TDataType>
+size_t SortAndDeDup(std::vector<TDataType> &dst)
+{
+	std::sort (dst.begin(), dst.end());
+
+	size_t ulTotalNonRedund = 0;
+	
+	typename std::vector <TDataType> :: iterator iter1 = dst.begin();
+	
+	if (dst.end() != iter1)
+	{
+		++ulTotalNonRedund;	//at least one
+		typename std::vector<TDataType>::iterator iter2 = iter1;
+		++iter2;
+		while (dst.end() != iter2)
+		{
+			if (!(*iter2 == *iter1))
+			{
+				++iter1;
+				*iter1 = *iter2;
+				++ulTotalNonRedund;
+			}
+			++iter2;
+		}
+		++iter1;
+		dst.erase(iter1, dst.end());
+	}
+	return ulTotalNonRedund;
+}
+
+template<typename TDataType, typename TComp>
+size_t SortAndDeDup(std::vector<TDataType> &dst, TComp cmp)
+{
+	auto ltop = [cmp] (const TDataType &a, const TDataType &b)->bool {return (cmp(a, b) < 0);};
+	
+	sort(dst.begin(), dst.end(), ltop);
+	size_t ulTotalNonRedund = 0;
+	
+	
+	typename std::vector <TDataType> :: iterator iter1 = dst.begin();
+	
+	if (dst.end() != iter1)
+	{
+		++ulTotalNonRedund;	//at least one
+		typename std::vector<TDataType>::iterator iter2 = iter1;
+		++iter2;
+		while (dst.end() != iter2)
+		{
+			if (0 != cmp(*iter2, *iter1))
+			{
+				++iter1;
+				*iter1 = *iter2;
+				++ulTotalNonRedund;
+			}
+			++iter2;
+		}
+		++iter1;
+		dst.erase(iter1, dst.end());
+	}
+	return ulTotalNonRedund;
+	
+}
+
+// -- usually it's faster to construct the vector and sort, but sometimes it's convenient to insert/remove on the fly
+template<typename TDataType, typename TValueType>
+bool InsertDataUnique(std::vector<TDataType> &dst, TValueType &&data, size_t &pos)
+{
+	bool found = BinSearchData(dst, data, pos);
+	if (!found)
+		dst.emplace(dst.begin() + pos, std::forward<TValueType> (data));
+	
+	return !found;
+}
+
+template<typename TDataType, typename TValueType>
+bool InsertDataUnique(std::vector<TDataType> &dst, TValueType &&data)
+{
+	size_t pos = 0;
+	return InsertDataUnique(dst, std::forward<TValueType> (data), pos);
+}
+
+// *******************************************************************/
+
+/**********************************************************************
+*	Commonly used routines
+**********************************************************************/
+
+char * B64Encode(const void * blob, size_t &bytes);	//bytes will return the size of char*
+BYTE * B64Decode(const char * src, size_t &bytes);
+
+std::string MD5Digest(const void* bytes, UINT64 n);
+std::string MD5Digest(const std::string &msg);
+std::string MD5Digest(std::istream &istr);
+// *******************************************************************/
+
+	
+/**********************************************************************
+*	misc
+**********************************************************************/
+// -- must use simple modular if msx < RANDMAX
+int GetRandInt(int max = RAND_MAX);
+// -- this is just to get a random number and compute the MD5 out of it
+std::string GetRandomString(void);
+
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/cdalignproc_base.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/cdalignproc_base.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/cdalignproc_base.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/cdalignproc_base.cpp	2018-03-13 14:39:35.373539000 -0400
@@ -0,0 +1,885 @@
+#include "cdalignproc_base.hpp"
+
+USING_NCBI_SCOPE;
+
+
+const int TDomSrcCount::MAXCOUNTS[] = {1, 1, 1, 1, 1, 1, 1};
+const char * TDomSrcCount::DOMSRCSIGS[] = {"CD", "PFAM", "TIGR", "COG", "KOG", "SMART", "PRK", "CHL", "MTH", "PHA", "PLN", "PTZ"};
+
+TDomSrcCount::ESrcIdx TDomSrcCount::DomAccType(const string &acxn)
+{
+	size_t iSig = 0, iChar = 0, iAccChar = 0, acclen = acxn.size();
+	
+
+	while (iSig < TOTALSIGS && 0 != DOMSRCSIGS[iSig][iChar] && iAccChar < acclen)
+	{
+		char accChar = acxn[iAccChar];
+		if ('a' <= accChar && 'z' >= accChar) accChar -= 0x20;	//to uppercase
+		if (accChar == DOMSRCSIGS[iSig][iChar])
+		{
+			++iAccChar;
+			++iChar;
+		}
+		else
+		{
+
+			++iSig;
+			iChar = 0;
+			iAccChar = 0;
+		}
+	}
+/**************************************************************************************
+Besides Pfam, CDD, TIGRFAM, COGs, SMART, PRK, we still have these type of accessions:
+"CHL", "MTH", "PHA", "PLN", "PTZ"
+All of these should be grouped together with the PRK as PRK models
+***************************************************************************************/
+
+	if (iSig < ePRK)
+		return static_cast<ESrcIdx> (iSig);
+	else if (iSig < TOTALSIGS)
+		return ePRK;
+	else
+		return TOTALSRCS;
+}
+
+bool TDomSrcCount::CountSrc(const std::string &acxn)
+{
+	ESrcIdx srctype = DomAccType(acxn);
+	if (TOTALSRCS == srctype) return true;	//unknown src always enter.
+	
+	map<ESrcIdx, int> :: iterator iter = m_SrcCounter.emplace(srctype, 0).first;
+
+	if (iter->second >= MAXCOUNTS[srctype]) return false;
+	++iter->second;
+	return true;
+}
+
+
+
+
+SeqLen_t CCdAlignProcessor::SortReadingFrames(vector<size_t> rfIndice[READINGFRAME::TOTAL_RFS], const TDomQuery &rSrc)
+{
+	// -- to calculate minus strand reading frame, we need the length of query sequence
+
+	SeqLen_t qlen = 0;
+	if (rSrc.m_uiSeqLen > 0)
+		qlen = rSrc.m_uiSeqLen;
+	else if (!rSrc.m_strSeqData.empty())
+		qlen = rSrc.m_strSeqData.size();
+	
+	
+	if (qlen > 0)	//calculate
+		for (size_t idx = 0, len = rSrc.m_vecAlignments.size(); idx < len; ++idx)
+		{
+			//int alignedLen = rSrc.m_vecAlignments[idx].m_iReadingFrame >> 2;
+			//int rfidx = rSrc.m_vecAlignments[idx].m_iReadingFrame & RF_SIZE;
+			//if (alignedLen > 0)
+			//	rfidx = (qlen - 1 - (alignedLen * RF_SIZE + rfidx)) % RF_SIZE + RF_SIZE;
+      //
+			//rfIndices[rfidx].emplace_back(idx);
+			rfIndice[rSrc.m_vecAlignments[idx].GetRFIdx(qlen)].emplace_back(idx);
+		}
+	else	//should not happen
+		THROW_SIMPLE("Cannot sort reading frames - query sequence length unknown"); 
+	return qlen;
+}
+
+
+void CCdAlignProcessor::Calculate(vector<TDomSeqAlignment> &aligns, const vector<size_t> &selIdx, TDomSeqAlignIndex &dst, vector<PssmId_t> &missed) const
+{
+
+	vector <CSegSet> vecGaps;
+	vecGaps.emplace_back(CSegSet());	//sentinel
+	size_t gapIdx = 0;
+	vector <TDomAlignFacility> vecPrivileged, vecNonMulti, vecLongMultiDom, vecMultiDom, vecConcise, vecSDs;
+	// -- added 12/6/2016: Concise view now should always include curated models (if available).
+	if (!selIdx.empty())
+	{
+		TDomAlignFacility pholder;
+		TDomAlignOrderByEValue sortingEV;
+			
+		vector<size_t> alignIdx;
+		vector<size_t> missedIdx;
+		
+		for (vector<size_t> :: const_iterator iterIdx = selIdx.begin(), iterIdxEnd = selIdx.end(); iterIdx != iterIdxEnd; ++iterIdx)
+		{
+			TDomSeqAlignment &rAlign = aligns[*iterIdx];
+
+			if (rAlign.m_vecSStarts.empty()) continue;	//somehow live blast search contains empty aligns.
+			const TDomain *pCdInfo = nullptr;
+#if defined(_MT)			
+			{{
+				CReadLockGuard rlck(m_mtxDomClusterIdx);
+#endif
+				pCdInfo = m_pDomSrc->FindCdInfo(rAlign.m_uiPssmId);
+#if defined(_MT)
+			}}
+#endif
+			if (nullptr == pCdInfo)	//unrecognized CD
+			{
+				missed.emplace_back(rAlign.m_uiPssmId);
+				missedIdx.emplace_back(*iterIdx);
+				//alignIdx.emplace_back(*iterIdx);
+				continue;
+			}
+			rAlign.m_dSeqIdentity = (double)(rAlign.m_iNumIdent) / (double)(pCdInfo->m_uiLength) * 100.0;
+			
+			int iNMissing = *(rAlign.m_vecSStarts.begin());
+			int iCMissing = pCdInfo->m_uiLength - (*(rAlign.m_vecSStarts.rbegin()) + *(rAlign.m_vecLens.rbegin()) - 1);
+			
+			rAlign.m_dNMissing = (double)(iNMissing) / (double)(pCdInfo->m_uiLength);
+			rAlign.m_dCMissing = (double)(iCMissing) / (double)(pCdInfo->m_uiLength);
+			rAlign.m_uiAlignedLen = pCdInfo->m_uiLength - iNMissing - iCMissing;
+			rAlign.m_dAlignedPct = (double)(rAlign.m_uiAlignedLen) / (double)(pCdInfo->m_uiLength) * 100.0;
+			rAlign.m_bSpecQualified = (rAlign.m_dBitScore >= pCdInfo->m_dMinBitScore);
+			// -- sorting
+			
+			pholder.pAlign = &(rAlign);
+			pholder.ulIdx = *iterIdx;
+			pholder.pCdInfo = pCdInfo;
+			pholder.ulGapsIdx = string::npos;
+			
+			rAlign.CalcMasterGaps(TDomSeqAlignment::GAP_THRESHOLD, vecGaps[gapIdx]);
+			if (!vecGaps[gapIdx].IsEmpty())
+			{
+				pholder.ulGapsIdx = gapIdx;
+				++gapIdx;
+				vecGaps.emplace_back(CSegSet());
+			}
+		
+			if (pCdInfo->m_bIsStructDom)
+			{
+				rAlign.m_iRepClass = 0x2;
+				vecSDs.emplace_back(pholder);
+			}
+			else if (pCdInfo->m_bCurated || !pCdInfo->m_bMultiDom)	//curated or non-multi are mixed together
+			{
+				rAlign.m_iRepClass = 0;
+				vecNonMulti.emplace_back(pholder);
+			}
+			else
+			{
+				rAlign.m_iRepClass = 1;
+				vecMultiDom.emplace_back(pholder);
+			}
+		}
+		
+		// -- online version may need to handle missed and load from cdtrack PssmId2Bioseq
+		if (!missed.empty())
+		{
+			x_LoadMissingDomains(missed);
+			for (size_t i = 0, ie = missed.size(); i < ie; ++i)
+			{
+				const TDomain *pCdInfo = nullptr;
+#if defined(_MT)
+				{{
+					CReadLockGuard rlck(m_mtxDomClusterIdx);
+#endif
+					pCdInfo = m_pDomSrc->FindCdInfo(missed[i]); 
+#if defined(_MT)
+				}}
+#endif
+
+				if (nullptr != pCdInfo)
+				{
+					TDomSeqAlignment &rAlign = aligns[missedIdx[i]];
+					rAlign.m_dSeqIdentity = (double)(rAlign.m_iNumIdent) / (double)(pCdInfo->m_uiLength) * 100.0;
+					int iNMissing = *(rAlign.m_vecSStarts.begin());
+					int iCMissing = pCdInfo->m_uiLength - (*(rAlign.m_vecSStarts.rbegin()) + *(rAlign.m_vecLens.rbegin()) - 1);
+					
+					rAlign.m_dNMissing = (double)(iNMissing) / (double)(pCdInfo->m_uiLength);
+					rAlign.m_dCMissing = (double)(iCMissing) / (double)(pCdInfo->m_uiLength);
+					rAlign.m_uiAlignedLen = pCdInfo->m_uiLength - iNMissing - iCMissing;
+					rAlign.m_dAlignedPct = (double)(rAlign.m_uiAlignedLen) / (double)(pCdInfo->m_uiLength) * 100.0;
+					rAlign.m_bSpecQualified = (rAlign.m_dBitScore >= pCdInfo->m_dMinBitScore);
+					// -- sorting
+			
+					pholder.pAlign = &(rAlign);
+					pholder.ulIdx = missedIdx[i];
+					pholder.pCdInfo = pCdInfo;
+					pholder.ulGapsIdx = string::npos;
+					
+					rAlign.CalcMasterGaps(TDomSeqAlignment::GAP_THRESHOLD, vecGaps[gapIdx]);
+					if (!vecGaps[gapIdx].IsEmpty())
+					{
+						pholder.ulGapsIdx = gapIdx;
+						++gapIdx;
+						vecGaps.emplace_back(CSegSet());
+					}
+		  		
+					if (pCdInfo->m_bIsStructDom)
+					{
+						rAlign.m_iRepClass = 0x2;
+						vecSDs.emplace_back(pholder);
+					}
+					else if (pCdInfo->m_bCurated || !pCdInfo->m_bMultiDom)	//curated or non-multi are mixed together
+					{
+						rAlign.m_iRepClass = 0;
+						vecNonMulti.emplace_back(pholder);
+					}
+					else
+					{
+						rAlign.m_iRepClass = 1;
+						vecMultiDom.emplace_back(pholder);
+					}		
+				}
+			}
+		}
+	  map<int, TDomSrcCount> dimAccTypeCount, dimAccTypeCount_multi;	//one for single doms and one for multi-doms
+	  // -- sort
+		sort(vecNonMulti.begin(), vecNonMulti.end(), sortingEV);
+		for (vector <TDomAlignFacility>::const_iterator iter = vecNonMulti.begin(), iterEnd = vecNonMulti.end(); iterEnd != iter; ++iter)
+		{
+
+			CSegSet s_overlaps;	// to calculate combined overlap region
+			
+			CSegSet thisSegs;
+			thisSegs.AddSeg(iter->pAlign->m_iFrom, iter->pAlign->m_iTo);
+			if (string::npos != iter->ulGapsIdx)
+				thisSegs.Clip(vecGaps[iter->ulGapsIdx]);
+			
+			int iThisLength = (int)thisSegs.GetTotalResidues();
+			double dThisLength = (double)iThisLength;
+
+			for (vector <TDomAlignFacility>::const_iterator iterRep = vecConcise.begin(), iterRepEnd = vecConcise.end(); iterRepEnd != iterRep; ++iterRep)
+			{
+				CSegSet repSegs;
+				repSegs.AddSeg(iterRep->pAlign->m_iFrom, iterRep->pAlign->m_iTo);
+				
+				if (string::npos != iterRep->ulGapsIdx)
+					repSegs.Clip(vecGaps[iterRep->ulGapsIdx]);
+				
+				int iRepLength = (int)repSegs.GetTotalResidues();
+				double dRepLength = (double)iRepLength;
+				
+				// -- find gaps. any gap >= half of the domain model length are considered a gap and excluded from overlapping
+				
+				CSegSet olSegs(thisSegs);
+				olSegs.Cross(repSegs);
+				
+				int iOverlapLen = (int)olSegs.GetTotalResidues();
+				double dOverlapLen = (double)iOverlapLen;
+				
+				if (dOverlapLen > 0)
+				{
+
+					if (dOverlapLen / dThisLength > 0.5 || (dOverlapLen / dRepLength > 0.5 && iter->pCdInfo->m_uiClusterPssmId == iterRep->pCdInfo->m_uiClusterPssmId))	//mutually overlap > 0.5
+					//if (dOverlapLen / dThisLength + dOverlapLen / dRepLength > 1.0)	//mutually overlap > 0.5
+					{
+						iter->pAlign->m_iRegionIdx = iterRep->pAlign->m_iRegionIdx;
+						iter->pAlign->m_bRep = false;
+						
+						goto labelNextNonMulti;
+					}
+				}
+				s_overlaps.Merge(olSegs);
+
+			}
+			
+			if ((iter->pAlign->m_bRep = (((double)(s_overlaps.GetTotalResidues()) / dThisLength) < 0.5)))	//new region
+			{
+				iter->pAlign->m_iRegionIdx = vecConcise.size();
+
+				vecConcise.emplace_back(*iter);
+
+			}
+		labelNextNonMulti:
+			
+			map<int, TDomSrcCount> :: iterator iterSrcCounter = dimAccTypeCount.emplace(iter->pAlign->m_iRegionIdx, TDomSrcCount()).first;
+
+			if (iterSrcCounter->second.CountSrc(iter->pCdInfo->m_strAccession))
+			{
+				if (iter->pCdInfo->m_bCurated)
+				{
+					dst.m_vecQualifiedFeatIndice.emplace_back(iter->ulIdx);
+				}
+				dst.m_vecStdIndice.emplace_back(iter->ulIdx);
+				iter->pAlign->m_bRep = true;
+			}
+			
+			dst.m_vecSortedIndice.emplace_back(iter->ulIdx);
+		}
+		
+		// -- When done, convert setup dst.m_vecConciseIndice
+		size_t ttlWinners = vecConcise.size();
+		if (ttlWinners > 0)
+		{
+			dst.m_vecConciseIndice.reserve(ttlWinners);
+			for (size_t i = 0; i < ttlWinners; ++i)
+				dst.m_vecConciseIndice.emplace_back(vecConcise[i].ulIdx);
+		}
+		vecPrivileged.clear();
+		sort(vecMultiDom.begin(), vecMultiDom.end(), sortingEV);
+		for (vector <TDomAlignFacility>::const_iterator iter = vecMultiDom.begin(), iterEnd = vecMultiDom.end(); iterEnd != iter; ++iter)
+		{
+			CSegSet s_overlaps;	// to calculate combined overlap region
+			CSegSet m_overlaps;
+			
+			double dSOverlap = 0.0;	//put here for scope reason
+			double dMOverlap = 0.0;
+			
+			CSegSet thisSegs;
+			thisSegs.AddSeg(iter->pAlign->m_iFrom, iter->pAlign->m_iTo);
+			if (string::npos != iter->ulGapsIdx)
+				thisSegs.Clip(vecGaps[iter->ulGapsIdx]);
+			
+			int iThisLength = (int)thisSegs.GetTotalResidues();
+			double dThisLength = (double)iThisLength;
+			
+			//double dThisLength = (double)(iter->pAlign->m_iTo - iter->pAlign->m_iFrom + 1);
+			for (vector <TDomAlignFacility>::const_iterator iterRep = vecConcise.begin(), iterRepEnd = vecConcise.end(); iterRepEnd != iterRep; ++iterRep)
+			{
+				if (!(iterRep->pAlign->m_iFrom > iter->pAlign->m_iTo || iterRep->pAlign->m_iTo < iter->pAlign->m_iFrom))	//overlap
+				{
+					CSegSet repSegs;
+					repSegs.AddSeg(iterRep->pAlign->m_iFrom, iterRep->pAlign->m_iTo);
+					
+					if (string::npos != iterRep->ulGapsIdx)
+						repSegs.Clip(vecGaps[iterRep->ulGapsIdx]);
+					
+					int iRepLength = (int)repSegs.GetTotalResidues();
+					double dRepLength = (double)iRepLength;
+					
+					// -- find gaps. any gap >= half of the domain model length are considered a gap and excluded from overlapping
+					
+					CSegSet olSegs(thisSegs);
+					olSegs.Cross(repSegs);
+					
+					int iOverlapLen = (int)olSegs.GetTotalResidues();
+					
+					double dOverlapLen = (double)iOverlapLen;
+					
+					if (0 == iterRep->pAlign->m_iRepClass)	//single
+					{
+						s_overlaps.Merge(olSegs);
+					}
+					else	//multi
+					{
+						if (dOverlapLen / dThisLength + dOverlapLen / dRepLength > 1.0)	//mutually overlap > 0.5
+						{
+							iter->pAlign->m_iRegionIdx = iterRep->pAlign->m_iRegionIdx;
+							iter->pAlign->m_bRep = false;
+							goto labelNextMulti;
+						}
+						m_overlaps.Merge(olSegs);
+					}
+				}
+			}
+			
+			
+			for (vector <TDomAlignFacility>::const_iterator iterRep = vecPrivileged.begin(), iterRepEnd = vecPrivileged.end(); iterRepEnd != iterRep; ++iterRep)
+			{
+				if (!(iterRep->pAlign->m_iFrom > iter->pAlign->m_iTo || iterRep->pAlign->m_iTo < iter->pAlign->m_iFrom))	//overlap
+				{
+					
+					CSegSet repSegs;
+					repSegs.AddSeg(iterRep->pAlign->m_iFrom, iterRep->pAlign->m_iTo);
+					
+					if (string::npos != iterRep->ulGapsIdx)
+						repSegs.Clip(vecGaps[iterRep->ulGapsIdx]);
+					
+					int iRepLength = (int)repSegs.GetTotalResidues();
+					double dRepLength = (double)iRepLength;
+					
+					// -- find gaps. any gap >= half of the domain model length are considered a gap and excluded from overlapping
+					
+					CSegSet olSegs(thisSegs);
+					olSegs.Cross(repSegs);
+					
+					int iOverlapLen = (int)olSegs.GetTotalResidues();
+					
+					double dOverlapLen = (double)iOverlapLen;
+					
+					if (dOverlapLen / dThisLength + dOverlapLen / dRepLength > 1.0)	//mutually overlap > 0.5
+					{
+						iter->pAlign->m_iRegionIdx = iterRep->pAlign->m_iRegionIdx;
+						iter->pAlign->m_bRep = false;
+						goto labelNextMulti;
+					}
+					m_overlaps.Merge(olSegs);
+				}
+			}
+			
+			dSOverlap = (double)(s_overlaps.GetTotalResidues()) / dThisLength;
+			dMOverlap = (double)(m_overlaps.GetTotalResidues()) / dThisLength;
+
+			if (dMOverlap <= 0.5)	//new multi-dom region
+			{
+				if ((dSOverlap <= 0.5 && iter->pAlign->m_dAlignedPct > 50.0) || iter->pAlign->m_bSpecQualified)	//rep!
+				{
+					iter->pAlign->m_iRegionIdx = dst.m_vecConciseIndice.size() + vecPrivileged.size();
+					iter->pAlign->m_bRep = true;
+					
+					dst.m_vecConciseIndice.emplace_back(iter->ulIdx);
+					vecConcise.emplace_back(*iter);
+				}
+				vecPrivileged.emplace_back(*iter);
+			}
+		labelNextMulti:
+			
+			map<int, TDomSrcCount> :: iterator iterSrcCounter = dimAccTypeCount_multi.emplace(iter->pAlign->m_iRegionIdx, TDomSrcCount()).first;
+			if (iterSrcCounter->second.CountSrc(iter->pCdInfo->m_strAccession))
+				dst.m_vecStdIndice.emplace_back(iter->ulIdx);
+			
+			dst.m_vecSortedIndice.emplace_back(iter->ulIdx);
+		
+		}
+		// -- to avoid empty concise
+		
+		if (!dst.m_vecSortedIndice.empty())
+		{
+			if (dst.m_vecConciseIndice.empty())
+			{
+				size_t iEnd = vecPrivileged.size();
+				dst.m_vecConciseIndice.reserve(iEnd);
+				for (size_t i = 0; i < iEnd; ++i)
+				{
+					dst.m_vecConciseIndice.emplace_back(vecPrivileged[i].ulIdx);
+					vecPrivileged[i].pAlign->m_bRep = true;
+				}
+			}
+			
+			if (dst.m_vecStdIndice.empty())
+			{
+				dst.m_vecStdIndice = dst.m_vecSortedIndice;
+			}
+		}
+		
+		// -- finally calculate SDs
+		// -- SDs: models are sorted according to evalues, each model reserve their regions on the query sequence. that would need to change the from/to and the aligned segments. Features are 
+		// -- then mapped to the query from these regions -- to guarantee non-redundency. Proposed by Aron.
+		// -- implementation: calculate a restriction segset for SD models, which will be used later to trim the sites first
+		if (!vecSDs.empty())
+		{
+			sort(vecSDs.begin(), vecSDs.end(), sortingEV);
+			//vecConcise.clear();
+			dst.m_vecSDIndice.clear();
+			dst.m_vecSDIndice.reserve(vecSDs.size());
+			CSegSet covered_regions;
+			
+			for (vector <TDomAlignFacility>::const_iterator iter = vecSDs.begin(), iterEnd = vecSDs.end(); iterEnd != iter; ++iter)
+			{
+
+				CSegSet sdSegSet;
+				sdSegSet.AddSeg(0, iter->pCdInfo->m_uiLength - 1);
+
+				iter->pAlign->MapSegSet(sdSegSet);
+				
+				sdSegSet.Clip(covered_regions);
+				
+				if (!sdSegSet.IsEmpty())
+				{
+					iter->pAlign->m_ClipSet.Clear();
+					const CSegSet::TSegs& sdSegs = sdSegSet.GetSegs();
+					
+					for (CSegSet::TSegs::const_iterator iterSeg = sdSegs.begin(), iterSegEnd = sdSegs.end(); iterSegEnd != iterSeg; ++iterSeg)
+					{
+						iter->pAlign->m_ClipSet.AddSeg(iterSeg->ori_from, sdSegSet.GetOriTo(iterSeg));
+					}
+					covered_regions.Merge(sdSegSet);
+					dst.m_vecSDIndice.emplace_back(iter->ulIdx);
+				}
+			}
+		}
+	}
+}
+
+void CCdAlignProcessor::Calculate(vector<TDomSeqAlignment> &aligns, TDomSeqAlignIndex &dst, vector<PssmId_t> &missed) const
+{
+	size_t ttl = aligns.size();
+	vector<size_t> selIdx(ttl);
+	for (size_t i = 0; i < ttl; ++i)
+		selIdx[i] = i;
+	Calculate(aligns, selIdx, dst, missed);
+}
+
+
+
+string GetNameString(const TDomClusterIndexIfx &domInfo, const TDomSeqAlignIndex::__TCdAlignRecordBase& rec)
+{
+	if (rec.pAlign->m_bSpecQualified || rec.pCdInfo->m_iClusterId <= 0)
+		return rec.pCdInfo->m_strShortName;
+	else
+	{
+		const TCluster * pClstInfo = domInfo.FindClusterInfo(rec.pCdInfo->m_iClusterId);
+		if (nullptr != pClstInfo)
+			return pClstInfo->m_strShortName;
+	}
+
+	return k_strEmptyString;
+}
+
+void _TArchNameCols::clear()
+{
+	name.clear();
+	label.clear();
+	nameevds.clear();
+	labelevds.clear();
+	
+}
+
+
+void CreateSpArchName(const TDomClusterIndexIfx &domInfo, const TDomSeqAlignIndex &indice, const vector<TDomSeqAlignment> &aligns, _TArchNameCols &cols, string &remark)
+{
+	constexpr static const char evddelim = ' ';
+
+	cols.clear();
+	remark.clear();
+	
+	const vector<size_t> &conciseIdx = indice.m_vecConciseIndice;
+	
+	size_t ttlConcise = conciseIdx.size();
+	// -- check for hits
+	
+
+	if (ttlConcise > 0)
+	{
+		//TDomSeqAlignIndex::__TCdAlignRecord rec;
+		vector<TDomSeqAlignIndex::__TCdAlignRecord> namingRecs;
+		namingRecs.reserve(ttlConcise);
+		
+		TDomSeqAlignIndex::__TCdAlignRecord rec;
+		size_t iidx = 0;
+		// -- always push in the first.
+		while (iidx < ttlConcise)
+		{
+			rec.pAlign = &aligns[conciseIdx[iidx]];
+			rec.pCdInfo = domInfo.FindCdInfo(rec.pAlign->m_uiPssmId);
+			if (nullptr != rec.pCdInfo)
+			{
+				if (rec.pCdInfo->m_iClusterId > 0)
+					rec.pClst = domInfo.FindClusterInfo(rec.pCdInfo->m_iClusterId);
+				namingRecs.emplace_back(rec);
+				++iidx;
+				goto labelGotOne;
+			}
+			++iidx;
+		}
+		return;
+		
+	labelGotOne:
+		if (0 == rec.pAlign->m_iRepClass)
+		{
+			while (iidx < ttlConcise)
+			{
+				rec.pAlign = &aligns[conciseIdx[iidx]];
+				if (rec.pAlign->m_iRepClass > 0) break;
+				rec.pCdInfo = domInfo.FindCdInfo(rec.pAlign->m_uiPssmId);
+				rec.pClst = nullptr;
+				if (nullptr != rec.pCdInfo)
+				{
+					if (rec.pCdInfo->m_iClusterId > 0)
+						rec.pClst = domInfo.FindClusterInfo(rec.pCdInfo->m_iClusterId);
+					
+					namingRecs.emplace_back(rec);
+				}
+				++iidx;
+			}
+			
+			if (namingRecs.size() > 1)
+				goto labelMultiHit;
+		}
+
+		switch (TDomSrcCount::DomAccType(namingRecs[0].pCdInfo->m_strAccession))
+		{
+		case TDomSrcCount::eTIGRFam:
+		case TDomSrcCount::eCOG:
+		case TDomSrcCount::ePRK:
+			cols.name = cols.label = namingRecs[0].pCdInfo->m_strShortName + " family protein";
+			cols.nameevds = cols.labelevds = namingRecs[0].pCdInfo->m_strAccession;
+			NStr::NumericToString<double>(remark, namingRecs[0].pAlign->m_dAlignedPct);
+			remark.push_back('\t');
+			remark.append(namingRecs[0].pCdInfo->m_strAccession);
+
+			return;
+		default:
+			if (namingRecs[0].pAlign->m_iRepClass > 0)
+				return;	//no multidom hit
+			break;
+		}
+	labelMultiHit:
+		
+		vector<TDomSeqAlignIndex::__TCdAlignRecord> amends;
+		indice.CreateConciseAmends(aligns, domInfo, namingRecs, amends);
+		
+		if (!amends.empty())
+		{
+			size_t je = amends.size();
+
+
+			for (size_t i = 0, ie = namingRecs.size(); i < ie; ++i)
+			{
+				size_t j = 0;
+				while (j < je)
+				{
+					if (namingRecs[i].pAlign->m_iRegionIdx == amends[j].pAlign->m_iRegionIdx)
+					{
+
+						namingRecs[i] = amends[j];
+						amends.erase(amends.begin() + j);
+						//VecRemoveData<TDomSeqAlignIndex::__TCdAlignRecord> (amends, j);
+
+						--je;
+
+						break;
+					}
+					++j;
+
+				}
+			}
+		}
+			// -- get rid of dups
+		size_t nrecs = namingRecs.size();
+		
+		size_t curr = nrecs - 1;
+		while (curr > 0)
+		{
+			size_t cmp = curr;
+			while (cmp > 0)
+			{
+				if ((namingRecs[cmp - 1].pCdInfo == namingRecs[curr].pCdInfo))	//equivalent, no name
+				{
+					if (namingRecs[curr].pAlign->m_bSpecQualified && !namingRecs[cmp - 1].pAlign->m_bSpecQualified)
+					{
+						//VecRemoveData<TDomSeqAlignIndex::__TCdAlignRecord> (namingRecs, cmp - 1);
+						namingRecs.erase(namingRecs.begin() + (cmp - 1));
+						goto labelNext;
+					}
+					else
+					{
+						//VecRemoveData<TDomSeqAlignIndex::__TCdAlignRecord> (namingRecs, curr);
+						namingRecs.erase(namingRecs.begin() + curr);
+						goto labelNext;
+					}
+
+
+					
+
+					
+				}
+				--cmp;
+			}
+			
+			
+		labelNext:;
+			--curr;
+		
+
+		}
+		
+		vector<TDomSeqAlignIndex::__TCdAlignRecordBase> vecSpecNaming, vecNonSpecNaming;
+		vecSpecNaming.reserve(nrecs);
+		vecNonSpecNaming.reserve(nrecs);
+		
+		nrecs = namingRecs.size();
+		for (size_t i = 0; i < nrecs; ++i)
+			((namingRecs[i].pAlign->m_bSpecQualified) ? vecSpecNaming : vecNonSpecNaming).emplace_back(namingRecs[i]);
+
+		if (!vecSpecNaming.empty())	//must have spec hits to generate a spArchName
+		{
+			char sep[2] = {0, 0};
+			
+			// -- naming protein from domain names
+			size_t sphits = vecSpecNaming.size(), clshits = vecNonSpecNaming.size();
+			if (sphits < 4)
+			{
+				size_t amend = 4 - sphits;
+				if (clshits < amend) amend = clshits;
+				//-- borrow it
+				clshits = 0;
+				while (clshits < amend) vecSpecNaming.emplace_back(vecNonSpecNaming[clshits++]);
+			}
+			else if (sphits > 4)
+			{
+				size_t extra = sphits - 4;
+				while (extra > 0)
+				{
+					vecSpecNaming.pop_back();
+					--extra;
+				}
+			}
+			sphits = vecSpecNaming.size();
+			if (sphits > 2)	//name and label are different
+			{
+				sep[0] = evddelim;
+				vecNonSpecNaming.clear();	//use to hold name
+				vecNonSpecNaming.emplace_back(vecSpecNaming[0]);
+				vecNonSpecNaming.emplace_back(vecSpecNaming[1]);
+				
+				sort(vecNonSpecNaming.begin(), vecNonSpecNaming.end(), TDomSeqAlignIndex::TSortByFromObj());
+				cols.name = GetNameString(domInfo, vecNonSpecNaming[0]);
+				cols.nameevds = vecNonSpecNaming[0].pCdInfo->m_strAccession + sep + vecNonSpecNaming[1].pCdInfo->m_strAccession;
+				
+				string name2 = GetNameString(domInfo, vecNonSpecNaming[1]);
+				
+				if (!NStr::EqualNocase(cols.name, name2))
+					cols.name += " and " + name2;
+					
+				cols.name += " domain-containing protein";
+      	
+				sort(vecSpecNaming.begin(), vecSpecNaming.end(), TDomSeqAlignIndex::TSortByFromObj());
+				
+				vector<string> snames;
+				snames.reserve(sphits);
+				
+				cols.label = "protein containing domain";
+				
+				sep[0] = 0;
+				for (clshits = 0; clshits < sphits; ++clshits)
+				{
+					string alabel = GetNameString(domInfo, vecSpecNaming[clshits]);
+					cols.labelevds.append(sep);
+					cols.labelevds.append(vecSpecNaming[clshits].pCdInfo->m_strAccession);
+					sep[0] = evddelim;
+					for (size_t j = snames.size(); j > 0; --j)
+						if (NStr::EqualNocase(alabel, snames[j - 1]))
+							goto labelSkipThis;
+					snames.emplace_back(move(alabel));
+				labelSkipThis:;
+				}
+				
+				clshits = 0, sphits = snames.size();
+				
+				if (sphits > 1)
+					cols.label.append("s ");
+				else
+					cols.label.push_back(' ');
+				
+				cols.label.append(snames[clshits]);
+				++clshits;
+				if (clshits < sphits)
+				{
+					while (clshits < sphits - 1)
+					{
+						cols.label.append(", ");
+						cols.label.append(snames[clshits]);
+						++clshits;
+					}
+					// -- last one
+					cols.label.append(", and ");
+					cols.label.append(snames[clshits]);
+				}
+				
+			}
+			else if (sphits > 0)
+			{
+				sort(vecSpecNaming.begin(), vecSpecNaming.end(), TDomSeqAlignIndex::TSortByFromObj());
+				clshits = 0;
+				string snames(GetNameString(domInfo, vecSpecNaming[clshits]));
+				cols.nameevds = cols.labelevds = vecSpecNaming[clshits].pCdInfo->m_strAccession;
+				
+				++clshits;
+				
+				if (clshits < sphits)
+				{
+					sep[0] = evddelim;
+					string alabel = GetNameString(domInfo, vecSpecNaming[clshits]);
+					cols.nameevds.append(sep);
+					cols.nameevds.append(vecSpecNaming[clshits].pCdInfo->m_strAccession);
+					cols.labelevds.append(sep);
+					cols.labelevds.append(vecSpecNaming[clshits].pCdInfo->m_strAccession);
+					if (!NStr::EqualNocase(alabel, snames))
+					{
+						snames.append(" and ");
+						snames.append(alabel);
+					}
+				}
+				
+				cols.name = cols.label = snames + " domain-containing protein";
+				//cols.label = "protein containing " + ((sphits > 1 ? "domains " : "domain ") + snames);
+			}
+		}
+	}
+	else
+	{
+		cols.name = cols.label = NODOMPROT;
+	}
+}
+
+void CreateArchStrings(const TDomClusterIndexIfx &domInfo, const vector<size_t> &conciseIdx, const vector<TDomSeqAlignment> &aligns, string &archStr, string &spArchStr)
+{
+	archStr.clear();
+	spArchStr.clear();
+	
+	size_t ttlConcise = conciseIdx.size();
+
+	if (ttlConcise > 0)
+	{
+		vector<TDomSeqAlignIndex::__TCdAlignRecordBase> vecSortByFrom;
+		vecSortByFrom.reserve(ttlConcise);
+		for (size_t i = 0; i < ttlConcise; ++i)
+		{
+			TDomSeqAlignIndex::__TCdAlignRecordBase recBase;
+			recBase.pAlign = &(aligns[conciseIdx[i]]);
+			
+			if (recBase.pAlign->m_iRepClass > 0) break;
+			recBase.pCdInfo = domInfo.FindCdInfo(recBase.pAlign->m_uiPssmId);
+
+			if (nullptr != recBase.pCdInfo && recBase.pCdInfo->m_iClusterId > 0)
+			//if (nullptr != recBase.pCdInfo)
+				vecSortByFrom.emplace_back(recBase);
+		}
+		
+		ttlConcise = vecSortByFrom.size();
+
+		if (ttlConcise > 0)	//has
+		{
+			// -- sort by position
+			sort(vecSortByFrom.begin(), vecSortByFrom.end(), TDomSeqAlignIndex::TSortByFromObj());
+			
+			const TDomain *pLastCdInfo = nullptr;
+			bool lastSpec = false, hasSpec = false;
+			int lastClstId = 0;
+			
+			
+			char dimSep0[2] = {0, 0};
+			char dimSep1[2] = {0, 0};
+			char dimBuf[16];
+			
+			for (size_t i = 0; i < ttlConcise; ++i)
+			{
+
+				if (vecSortByFrom[i].pAlign->m_bSpecQualified)
+				{
+					if (!lastSpec || vecSortByFrom[i].pCdInfo != pLastCdInfo)	//filter out tandem repeat
+					{
+						spArchStr.append(dimSep1);
+						spArchStr.append(vecSortByFrom[i].pCdInfo->m_strAccession);
+						dimSep1[0] = ARCH_STRING_DELIM;
+					}
+					lastSpec = true;
+					hasSpec = true;
+				}
+				else if (INVALIDCLUSTERID != vecSortByFrom[i].pCdInfo->m_iClusterId)
+				{
+					if (lastSpec || vecSortByFrom[i].pCdInfo->m_iClusterId != lastClstId)	//non-spec hit
+					{
+						sprintf(dimBuf, "cl%05d", vecSortByFrom[i].pCdInfo->m_iClusterId);
+						spArchStr.append(dimSep1);
+						spArchStr.append(dimBuf);
+						dimSep1[0] = ARCH_STRING_DELIM;
+					}
+					lastSpec = false;
+				}
+
+				pLastCdInfo = vecSortByFrom[i].pCdInfo;
+				
+				// -- regular arch string
+				// -- for historical reason, the regular (superfamily) arch string needs to be in reverse order, ie, from C- to N- terminal.
+				if (INVALIDCLUSTERID != vecSortByFrom[i].pCdInfo->m_iClusterId && vecSortByFrom[i].pCdInfo->m_iClusterId != lastClstId)
+				{
+					sprintf(dimBuf, "%d%s", vecSortByFrom[i].pCdInfo->m_iClusterId, dimSep0);
+					archStr = dimBuf + archStr;
+					//archStr.append(dimSep0);
+					//archStr.append(dimBuf);
+					dimSep0[0] = ARCH_STRING_DELIM;
+				}
+				
+				lastClstId = vecSortByFrom[i].pCdInfo->m_iClusterId;
+			}
+			// -- if no specific hit, clear spArchStr
+			if (!hasSpec) spArchStr.clear();
+		}
+	}
+}
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/cdalignproc_base.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/cdalignproc_base.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/cdalignproc_base.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/cdalignproc_base.hpp	2018-03-13 14:39:35.379393000 -0400
@@ -0,0 +1,151 @@
+#if !defined(__CDALIGNPROC_BASE__)
+#define __CDALIGNPROC_BASE__
+
+#if defined(__DB_OFFLINE__)
+#include "offldata.hpp"
+#include "envdef.hpp"
+#else
+#include <DataUtils/offldata.hpp>
+#include <NcbiBase/envdef.hpp>
+#endif
+#if defined(_MT)
+#include <corelib/ncbimtx.hpp>
+#endif
+#include <map>
+
+constexpr const char ARCH_STRING_DELIM = ' ';
+constexpr const char * NODOMPROT = "Protein with no known domain";
+
+struct TDomSrcCount
+{
+	enum ESrcIdx
+	{
+		eCDD,
+		ePFam,
+		eTIGRFam,
+		eCOG,
+		eKOG,
+		eSMART,
+		ePRK,
+		TOTALSRCS
+	};
+	
+	//static const size_t TOTALSRCS = ePRK + 1;
+	static const size_t TOTALSIGS = 12;
+	static const char * DOMSRCSIGS[TOTALSIGS];
+	static const int MAXCOUNTS[TOTALSRCS];
+	static ESrcIdx DomAccType(const std::string &acxn);
+	
+	
+	std::map<ESrcIdx, int> m_SrcCounter;
+	// -- return true: counted. false: src already full, so not counted
+	bool CountSrc(const std::string &acxn);
+};
+
+
+
+// -- base class
+class CCdAlignProcessor
+{
+public:
+	// -- sorting facilities
+	struct TDomAlignFacility
+	{
+		TDomSeqAlignment *pAlign;
+		size_t ulIdx;
+		
+		// -- added 12/03/2013 for sorting modification
+		const TDomain *pCdInfo;
+		size_t ulGapsIdx;
+		
+		
+		TDomAlignFacility(void): pAlign(nullptr), ulIdx(0), pCdInfo(nullptr), ulGapsIdx(std::string::npos) {};
+	};
+	
+	struct TDomAlignOrderByEValue
+	{
+		bool operator () (const TDomAlignFacility &p1, const TDomAlignFacility &p2)
+		{
+			if (p1.pAlign->m_dEValue < p2.pAlign->m_dEValue) return true;
+			else if (p1.pAlign->m_dEValue > p2.pAlign->m_dEValue) return false;
+			else return (p1.pAlign->m_dBitScore > p2.pAlign->m_dBitScore);
+		}
+	};
+	
+	// -- return seuqence length, for convenience
+	static SeqLen_t SortReadingFrames(std::vector<size_t> rfIndice[READINGFRAME::TOTAL_RFS], const TDomQuery &rSrc);
+	
+	CCdAlignProcessor(const TDomClusterIndexIfx *dom_src = nullptr): m_mtxDomClusterIdx(), m_pDomSrc(dom_src) {} ;
+	
+	
+	virtual ~CCdAlignProcessor(void) {};
+	
+	inline
+	const TDomClusterIndexIfx * GetMap(void) const {return m_pDomSrc;}
+	
+	
+	//virtual const TDomain* FindCdInfo(unsigned int pssmid) const = 0;
+	//virtual const TShluClusterInfo* FindClusterInfo(int clusterid) const = 0;
+	
+	
+	// -- just a public interface for calculation
+	//void Calculate(TShluCdQuery &rTarget, std::map<unsigned int, TDomain> &missed) const;
+	
+	// -- two set of calculated std::vector<TDomSeqAlignment> merged together, recalculate the four index sets. 
+	// -- TDomSeqAlignment fields are assumed to be calculated/filled already so no need to calculate again
+	// -- only need to calculate m_bRep and m_iRegionIdx
+	//void MergeCalc(std::vector<TDomSeqAlignment> &aligns, TShluAlignIndice &dst, std::map<unsigned int, TDomain> &missed) const;
+	//void MergeCalc(std::vector<TDomSeqAlignment> &aligns, const std::vector<size_t> &selIdx, TShluAlignIndice &dst, std::map<unsigned int, TDomain> &missed) const;
+	void Calculate(std::vector<TDomSeqAlignment> &aligns, const std::vector<size_t> &selIdx, TDomSeqAlignIndex &dst, std::vector<PssmId_t> &missed) const;
+	void Calculate(std::vector<TDomSeqAlignment> &aligns, TDomSeqAlignIndex &dst, std::vector<PssmId_t> &missed) const;
+protected:
+#if defined(_MT)
+	mutable ncbi::CRWLock m_mtxDomClusterIdx;
+#endif
+	const TDomClusterIndexIfx *m_pDomSrc;
+	
+	// -- get missed pssms. 
+	virtual void x_LoadMissingDomains(const std::vector<PssmId_t> &missed) const {};
+	// -- added missed pssmid collector, for those not in dart but in cdtrack
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	
+	//void x_Calculate(std::vector<TDomSeqAlignment> &aligns, TShluAlignIndice &dst, std::map<unsigned int, TDomain> &missed) const;
+	
+	
+	// -- take seqid, return pssmid (pseudo or not)
+	
+	//virtual unsigned int x_CollectDomain(const ncbi::objects::CSeq_id &rCdSeqId, int iFlags) = 0;
+	
+	
+	//static void LoadCuratedClusterInfo(void);
+	//static void MergeCuratedClusterInfo(std::map<int, TShluClusterInfo> & tgt);
+	//static std::map<int, TCuratedClusterInfo> m_mapCuratedClusterInfo;
+};
+
+struct _TArchNameCols
+{
+	std::string name;
+	std::string label;
+	std::string nameevds;
+	std::string labelevds;
+	
+	_TArchNameCols(void):
+		name(k_strEmptyString), label(k_strEmptyString), nameevds(k_strEmptyString), labelevds(k_strEmptyString) {};
+	void clear(void);
+};
+
+
+
+void CreateArchStrings(const TDomClusterIndexIfx &domInfo, const std::vector<size_t> &conciseIdx, const std::vector<TDomSeqAlignment> &aligns, std::string &archStr, std::string &spArchStr);
+
+
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/combistream.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/combistream.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/combistream.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/combistream.cpp	2018-03-13 14:39:35.226197000 -0400
@@ -0,0 +1,111 @@
+#include "combistream.hpp"
+#include <cstring>
+using namespace std;
+
+CCombFileBuf::CCombFileBuf(size_t bsize, size_t pbsize):
+	m_buffer(new streambuf::char_type[bsize]),
+	m_bufend(m_buffer + bsize),
+	m_backsize(pbsize),
+	m_effpbsize(0),
+	m_files(),
+	m_currIstream(),
+	m_istream(nullptr),
+	m_mode(ios::in | ios::binary)
+{}
+
+CCombFileBuf::~CCombFileBuf(void)
+{
+	delete []m_buffer;
+	delete m_istream;
+}
+
+void CCombFileBuf::AppendFile(const string &path)
+{
+	if (!path.empty()) m_files.emplace_back(path);
+}
+
+istream * CCombFileBuf::OpenStream(ios::openmode mode)
+{
+	m_mode = (mode & ios::binary | ios::in);
+	if (nullptr == m_istream)
+	{
+		m_istream = new istream(this);
+		setg(m_buffer, m_buffer, m_buffer);
+	}
+
+
+	return m_istream;
+}
+
+streambuf::int_type CCombFileBuf::underflow(void)
+{
+	streambuf::char_type *_gptr = gptr();
+
+
+	if (_gptr < egptr())
+		return streambuf::traits_type::to_int_type(*_gptr);
+			
+	streambuf::char_type *_new_bufend = m_buffer + m_effpbsize;
+	_gptr = _new_bufend;
+	
+
+	while (!m_files.empty())
+	{
+		if (!m_currIstream.is_open())	//previously read
+		{
+
+			m_currIstream.open(m_files.front().c_str(), m_mode);
+		}
+		if (m_currIstream.good())
+		{
+
+			m_currIstream.read(_new_bufend, (m_bufend - _new_bufend) * sizeof(streambuf::char_type));
+
+			if (m_currIstream.good())	//complete read 
+			{
+				// -- set _new_bufend as the end -- if incomplete read after all, _new_bufend will be the position after the last char
+				_new_bufend = m_bufend;
+				break;
+			}
+
+			// -- read failed. go to next file
+			_new_bufend += m_currIstream.gcount();
+
+		}
+
+		m_currIstream.close();
+		m_files.pop_front();
+	}
+	
+	// -- calculate next effective putback size
+	m_effpbsize = _new_bufend - _gptr;
+	if (m_effpbsize > m_backsize) m_effpbsize = m_backsize;
+
+
+	// -- here, just check if ok. 
+	if (_gptr < _new_bufend)
+	{
+		setg(m_buffer, _gptr, _new_bufend);	//_new_bufend play as the buffer end
+		return streambuf::traits_type::to_int_type(*_gptr);
+	}
+	else
+		return streambuf::traits_type::eof();
+	
+}
+
+
+streambuf::int_type CCombFileBuf::pbackfail(streambuf::int_type c)
+{
+	streambuf::char_type * _gptr = gptr();
+
+	if (_gptr > m_buffer)
+	{
+		--_gptr;
+		*_gptr = (streambuf::char_type)c;
+		setg(m_buffer, _gptr, egptr());
+		return c;
+	}
+
+	return streambuf::traits_type::eof();
+	
+}
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/combistream.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/combistream.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/combistream.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/combistream.hpp	2018-03-13 14:39:35.231312000 -0400
@@ -0,0 +1,41 @@
+#if !defined(__COMB_STREAM__)
+#define __COMB_STREAM__
+
+/********************************************************************
+*	A streambuf drivative that combines multiple input files together. 
+*********************************************************************/
+#include <fstream>
+#include <iostream>
+#include <vector>
+#include <string>
+#include <list>
+
+class CCombFileBuf: public std::streambuf
+{
+public:
+	typedef std::list<std::string> FileList;
+	static constexpr const size_t DEFBUFSIZE = 4096;
+	static constexpr const size_t PUTBACKSIZE = 16;
+	CCombFileBuf(size_t bsize = DEFBUFSIZE, size_t pbsize = PUTBACKSIZE);
+	virtual ~CCombFileBuf(void);
+	void AppendFile(const std::string &path);
+	size_t NLeft(void) const {return m_files.size();}
+	std::istream * OpenStream(std::ios_base::openmode mode = std::ios_base::binary);	//only binary accepted
+	
+private:
+	virtual std::streambuf::int_type underflow(void) override;
+	virtual std::streambuf::int_type pbackfail(std::streambuf::int_type c = std::streambuf::traits_type::eof()) override;
+	std::streambuf::char_type *m_buffer, *m_bufend;
+	size_t m_backsize;
+	size_t m_effpbsize;	//depends on how many actually read
+	FileList m_files;
+	std::ifstream m_currIstream;
+	std::istream *m_istream;
+	std::ios_base::openmode m_mode;
+};
+
+
+
+
+
+#endif
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/compactstore.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/compactstore.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/compactstore.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/compactstore.hpp	2018-03-13 14:39:35.258400000 -0400
@@ -0,0 +1,412 @@
+#if !defined(__COMPACT_STORE__)
+#define __COMPACT_STORE__
+
+#include "data_construct.hpp"
+#include "normbase.hpp"
+#include <cstring>
+#include <type_traits>
+#include <vector>
+// -- helper class
+// -- memory block contains n * _Td type data
+template<typename _Td, size_t _n>
+struct TDATABLOCK
+{
+	typedef _Td TDATA;
+	struct TDATABLOCK *m_pNext;
+	BYTE m_bytes[_n];
+	
+	TDATA * GetTypePtr (void) {return static_cast<TDATA* >(static_cast<void* > (m_bytes));}
+	const TDATA * GetTypePtr (void) const {return static_cast< const TDATA* >(static_cast< const void* > (m_bytes));}
+	
+	TDATABLOCK(void): m_pNext(nullptr) {memset(m_bytes, 0, _n);}
+	~TDATABLOCK(void) {delete m_pNext;}	//delete is delete the whole chain
+};
+
+
+
+/**********************************************************************
+*	A template class for high-efficiency storage of data. It does not support
+* ramdom delete of elements, just keep adding in or Reset to clear everything.
+*	It allocates memories in big chunks, by default is exactly 64MB, but will
+*	adjust according to sizeof(TDATATYPE)
+**********************************************************************/
+
+template<typename TDATATYPE, size_t BLOCKSIZE = 16777216 >	//16 MB exactly.
+class CCompactStore
+{
+	static constexpr const size_t SIZEOFDATA = sizeof(TDATATYPE);
+	static constexpr const size_t OBJS_PER_BLK = (BLOCKSIZE / SIZEOFDATA + (BLOCKSIZE % SIZEOFDATA > (SIZEOFDATA >> 1) ? 1 : 0));
+	static constexpr const size_t EFF_BLK_SIZE = OBJS_PER_BLK * SIZEOFDATA;
+	typedef TDATABLOCK<TDATATYPE, EFF_BLK_SIZE> TDATASTORE;
+	typedef TDATATYPE *DATA_PTR;
+	typedef const TDATATYPE *CONST_DATA_PTR;
+	
+public:
+	CCompactStore(void);
+	~CCompactStore(void);
+	
+	CCompactStore(const CCompactStore& other) = delete;
+	CCompactStore& operator=(const CCompactStore&) = delete;
+	// -- get pointers to all elements added, in that order
+	// -- should be called after all elements are added
+	// -- this will clear the dst vector before fill.
+	void CreatePtrVector(std::vector<DATA_PTR> &dst);
+	void CreatePtrVector(std::vector<CONST_DATA_PTR> &dst) const;
+	
+	// -- add one element
+	template<typename... Args>
+	DATA_PTR Append(Args&&...  args);
+	
+	// -- add n identical elements
+	// -- this does not clear ptr_vec, just append onto it. Caller's responsibility to clean it
+	template<typename SUBTYPE, typename... Args>
+	void Append(size_t n, std::vector< SUBTYPE* > &ptr_vec, Args&&...  args);
+		
+	// -- add a range of elements
+	// -- this does not clear ptr_vec, just append onto it. Caller's responsibility to clean it
+	template<typename SUBTYPE, typename FWD_ITER>
+	void Append(std::vector< SUBTYPE* > &ptr_vec, FWD_ITER it_from, FWD_ITER it_end);	//insert [*it_from, *it_to)
+
+	
+	// -- clear out objects, but does not release extra memories
+	void Clear(void);
+	// -- clear out objects and release extra memory blocks, only leave one sentinel block.
+	void Reset(void);
+	
+	size_t Size(void) const {return m_total_objects;}
+	bool IsEmpty(void) const {return 0 == m_total_objects;}
+	
+	// -- access
+	DATA_PTR GetElem(size_t idx);
+	CONST_DATA_PTR GetElem(size_t idx) const;
+	
+	TDATATYPE & operator [] (size_t idx);
+	const TDATATYPE & operator [] (size_t idx) const;
+	
+	std::vector< DATA_PTR > GetPointers(void); 	//to create new index, if needed
+	
+private:
+	TDATASTORE * x_find_tail(size_t &ofs) const;
+	TDATASTORE * x_find_data(size_t idx, size_t &ofs) const;
+	
+	
+	// -- memory block: first sizeof(MEM_PTR) bytes are the pointer to next block. the rest are TDATATYPE array
+	TDATASTORE *m_pHeader;
+	size_t m_total_objects;
+	
+};
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+void CCompactStore<TDATATYPE, BLOCKSIZE> :: CreatePtrVector(std::vector<typename CCompactStore<TDATATYPE, BLOCKSIZE> :: DATA_PTR> &dst)
+{
+	dst.clear();
+	TDATASTORE *pstore = m_pHeader;
+	
+	size_t leftover = m_total_objects;
+	dst.reserve(m_total_objects);
+	
+	while (leftover > 0)
+	{
+		size_t batch = OBJS_PER_BLK;
+		if (batch > leftover)
+			batch = leftover;
+		
+		DATA_PTR pd = pstore->GetTypePtr();
+		
+		for (size_t i = 0; i < batch; ++i)
+			dst.emplace_back(pd + i);
+			
+		leftover -= batch;
+		pstore = pstore->m_pNext;
+	}
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+void CCompactStore<TDATATYPE, BLOCKSIZE> :: CreatePtrVector(std::vector<typename CCompactStore<TDATATYPE, BLOCKSIZE> :: CONST_DATA_PTR> &dst) const
+{
+	dst.clear();
+	const TDATASTORE *pstore = m_pHeader;
+	
+	size_t leftover = m_total_objects;
+	dst.reserve(m_total_objects);
+	
+	while (leftover > 0)
+	{
+		size_t batch = OBJS_PER_BLK;
+		if (batch > leftover)
+			batch = leftover;
+		
+		CONST_DATA_PTR pd = pstore->GetTypePtr();
+		
+		for (size_t i = 0; i < batch; ++i)
+			dst.emplace_back(pd + i);
+			
+		leftover -= batch;
+		pstore = pstore->m_pNext;
+	}
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+TDATATYPE & CCompactStore<TDATATYPE, BLOCKSIZE> :: operator [] (size_t idx)
+{
+	size_t ofs = 0;
+	TDATASTORE *pstore = x_find_data(idx, ofs);
+	if (nullptr == pstore)
+		throw CSimpleException(__FILE__, __LINE__, "Index out of boundary");
+	
+	return *(pstore->GetTypePtr() + ofs);
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+const TDATATYPE & CCompactStore<TDATATYPE, BLOCKSIZE> :: operator [] (size_t idx) const
+{
+	size_t ofs = 0;
+	const TDATASTORE *pstore = x_find_data(idx, ofs);
+	if (nullptr == pstore)
+		throw CSimpleException(__FILE__, __LINE__, "Index out of boundary");
+	
+	return *(pstore->GetTypePtr() + ofs);
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+template<typename... Args>
+typename CCompactStore<TDATATYPE, BLOCKSIZE> :: DATA_PTR CCompactStore<TDATATYPE, BLOCKSIZE> :: Append(Args&&... args)
+{
+	size_t ofs = 0;
+	TDATASTORE *pstore = x_find_tail(ofs);
+	if (OBJS_PER_BLK == ofs)
+	{
+		if (nullptr == pstore->m_pNext)
+			pstore->m_pNext = new TDATASTORE;
+
+		pstore = pstore->m_pNext;
+		ofs = 0;
+	}
+	TDATATYPE *pd = pstore->GetTypePtr() + ofs;
+	_construct_(pd, std::forward<Args>(args)...);
+	++m_total_objects;
+	return pd;
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+template<typename SUBTYPE, typename... Args>
+void CCompactStore<TDATATYPE, BLOCKSIZE> :: Append(size_t n, std::vector< SUBTYPE* > &ptr_vec, Args&&... args)
+{
+	if (n > 0)
+	{
+		size_t ofs = 0;
+		TDATASTORE *pstore = x_find_tail(ofs);
+		size_t leftover = n;
+		while (leftover > 0)
+		{
+			size_t batch = OBJS_PER_BLK - ofs;
+			if (0 == batch)	//this block happened to be full.
+			{
+
+				if (nullptr == pstore->m_pNext)
+					pstore->m_pNext = new TDATASTORE;
+
+				pstore = pstore->m_pNext;
+				ofs = 0;
+				batch = OBJS_PER_BLK;
+			}
+
+			if (batch > leftover) batch = leftover;
+			// -- order, order!
+			leftover -= batch;
+			TDATATYPE *pd = pstore->GetTypePtr() + ofs;
+			ofs += batch;
+			
+
+			while (batch > 0)
+			{
+				_construct_(pd, std::forward<Args>(args)...);
+				
+				++m_total_objects;
+				ptr_vec.emplace_back(dynamic_cast< SUBTYPE* > (pd));
+				++pd;
+				--batch;
+			}
+		}
+	}
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+template<typename SUBTYPE, typename FWD_ITER>
+void CCompactStore<TDATATYPE, BLOCKSIZE> :: Append(std::vector< SUBTYPE* > &ptr_vec, FWD_ITER it_from, FWD_ITER it_end)	//insert [*it_from, *it_to)
+{
+	if (it_from != it_end)
+	{
+		size_t ofs = 0;
+		TDATASTORE *pstore = x_find_tail(ofs);
+		
+		TDATATYPE *pd = pstore->GetTypePtr() + ofs;
+		while (it_from != it_end)
+		{
+			if (ofs == OBJS_PER_BLK)	//this block happened to be full.
+			{
+				if (nullptr == pstore->m_pNext)
+					pstore->m_pNext = new TDATASTORE;
+
+				pstore = pstore->m_pNext;
+				ofs = 0;
+				pd = pstore->GetTypePtr();
+			}
+			
+			_construct_(pd, std::forward<TDATATYPE>(*it_from));
+			ptr_vec.emplace_back(dynamic_cast< SUBTYPE* > (pd));
+			++pd;
+			++ofs;	//just for count
+			
+			++it_from;
+		}
+	}
+}
+
+
+
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+CCompactStore<TDATATYPE, BLOCKSIZE> :: CCompactStore(void):
+	m_pHeader(new TDATASTORE), m_total_objects(0)
+{}
+
+
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+CCompactStore<TDATATYPE, BLOCKSIZE> :: ~CCompactStore(void)
+{
+	Clear();
+	delete m_pHeader;
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+void CCompactStore<TDATATYPE, BLOCKSIZE> :: Clear(void)
+{
+	TDATASTORE *p = m_pHeader;
+	size_t leftover = m_total_objects;
+	
+	while (leftover > 0 && nullptr != p)
+	{
+		size_t batch = leftover;
+		if (batch > OBJS_PER_BLK)
+			batch = OBJS_PER_BLK;
+		
+		DATA_PTR pd = p->GetTypePtr();
+		for (size_t i = 0; i < batch; ++i)
+		{
+
+			_destroy_call_ < std::is_trivial<TDATATYPE>::value > :: __call_destructor__ (pd);
+			++pd;
+		}
+		memset(p->m_bytes, 0, EFF_BLK_SIZE);
+		
+		leftover -= batch;
+		p = p->m_pNext;
+	}
+	
+	m_total_objects = 0;
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+void CCompactStore<TDATATYPE, BLOCKSIZE> :: Reset(void)
+{
+	Clear();
+	if (nullptr != m_pHeader)
+	{
+		delete m_pHeader->m_pNext;
+		m_pHeader->m_pNext = nullptr;
+	}
+}
+
+// -- could return nullptr if data ends at the end of last block.
+template<typename TDATATYPE, size_t BLOCKSIZE >
+typename CCompactStore<TDATATYPE, BLOCKSIZE> :: TDATASTORE * CCompactStore<TDATATYPE, BLOCKSIZE> :: x_find_tail(size_t &ofs) const
+{
+	TDATASTORE *p = m_pHeader;
+	ofs = m_total_objects;
+	while (ofs > OBJS_PER_BLK)
+	{
+		p = p->m_pNext;
+		ofs -=	OBJS_PER_BLK;
+	}
+	
+	return p;
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+typename CCompactStore<TDATATYPE, BLOCKSIZE> :: TDATASTORE * CCompactStore<TDATATYPE, BLOCKSIZE> :: x_find_data(size_t idx, size_t &ofs) const
+{
+	if (idx >= m_total_objects)
+	{
+		ofs = 0;
+		return nullptr;
+	}
+	
+	TDATASTORE *p = m_pHeader;
+	ofs = idx;
+	while (ofs >= OBJS_PER_BLK)
+	{
+		p = p->m_pNext;
+		ofs -=	OBJS_PER_BLK;
+	}
+	
+	return p;
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+typename CCompactStore<TDATATYPE, BLOCKSIZE> :: DATA_PTR CCompactStore<TDATATYPE, BLOCKSIZE> :: GetElem(size_t idx)
+{
+	size_t ofs = 0;
+	TDATASTORE *pstore = x_find_data(idx, ofs);
+
+	if (nullptr == pstore)
+		return nullptr;
+	
+	return pstore->GetTypePtr() + ofs;
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+typename CCompactStore<TDATATYPE, BLOCKSIZE> :: CONST_DATA_PTR CCompactStore<TDATATYPE, BLOCKSIZE> :: GetElem(size_t idx) const
+{
+
+	size_t ofs = 0;
+	const TDATASTORE *pstore = x_find_data(idx, ofs);
+
+	if (nullptr == pstore)
+		return nullptr;
+	
+	return pstore->GetTypePtr() + ofs;
+}
+
+template<typename TDATATYPE, size_t BLOCKSIZE >
+std::vector<typename CCompactStore<TDATATYPE, BLOCKSIZE> :: DATA_PTR> CCompactStore<TDATATYPE, BLOCKSIZE> :: GetPointers(void)
+{
+	std::vector<DATA_PTR> ptrvec;
+	ptrvec.reserve(m_total_objects);
+	
+	TDATASTORE *p = m_pHeader;
+	size_t leftover = m_total_objects;
+	
+	DATA_PTR pIdx = p->GetTypePtr();
+	while (leftover > OBJS_PER_BLK)
+	{
+		for (size_t i = 0; i < OBJS_PER_BLK; ++i)
+			ptrvec.emplace_back(pIdx + i);
+		p = p->m_pNext;
+		pIdx = p->GetTypePtr();
+		leftover -=	OBJS_PER_BLK;
+	}
+	
+	for (size_t i = 0; i < leftover; ++i)
+		ptrvec.emplace_back(pIdx + i);
+	
+	
+	return ptrvec;
+}
+
+
+
+// *******************************************************************/
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/data_construct.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/data_construct.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/data_construct.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/data_construct.hpp	2018-03-13 14:39:35.317580000 -0400
@@ -0,0 +1,40 @@
+#if !defined(__DATA_CONSTRUCTION__)
+#define __DATA_CONSTRUCTION__
+
+#include <utility>
+
+template<typename __T, typename...  __Args>
+inline
+void _construct_(__T* _p, __Args&&... args)
+{
+	::new (static_cast<void*>(_p)) __T(std::forward<__Args>(args)...);
+}
+
+template<typename __T>
+inline
+void _destroy_(__T* _p)
+{
+	_p->__T::~__T();
+}
+
+template<bool>
+struct _destroy_call_
+{
+	template<typename __T>
+	static void __call_destructor__(__T *_p)
+	{
+		_destroy_<__T>(_p);
+	};
+};
+
+// -- specialize for true: if trivial, do nothing
+template<>
+struct _destroy_call_<true>
+{
+	template<typename __T>
+	static void __call_destructor__(__T *_p) {};
+};
+
+
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/datanode.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/datanode.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/datanode.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/datanode.cpp	2018-03-13 14:39:35.245310000 -0400
@@ -0,0 +1,39 @@
+#include "datanode.hpp"
+using namespace std;
+
+TAtomicCounterValueType CRefCounter::operator ++(void)
+{
+	return 1 + m_count.fetch_add(1, memory_order_relaxed);
+}
+
+TAtomicCounterValueType CRefCounter::operator ++(int)
+{
+	return m_count.fetch_add(1, memory_order_relaxed);
+}
+
+TAtomicCounterValueType CRefCounter::operator --(void)
+{
+	return m_count.fetch_sub(1, memory_order_acq_rel) - 1;
+}
+
+TAtomicCounterValueType CRefCounter::operator --(int)
+{
+	return m_count.fetch_sub(1, memory_order_acq_rel);
+}
+
+
+
+CDocNodeBase::CDocNodeBase(void):
+	m_counter(0)
+{}
+
+void CDocNodeBase::x_IncRef(void)
+{
+	++m_counter;
+}
+void CDocNodeBase::x_DecRef(void)
+{	
+	TAtomicCounterValueType c = --m_counter;
+	if (0 == c)
+		delete this;
+}
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/datanode.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/datanode.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/datanode.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/datanode.hpp	2018-03-13 14:39:35.250281000 -0400
@@ -0,0 +1,161 @@
+#if !defined(__DATA_NODE__)
+#define __DATA_NODE__
+
+//#include <corelib/ncbiexpt.hpp>
+//#include <corelib/ncbidiag.hpp>
+//#include <corelib/ncbicntr.hpp>
+//#include <corelib/ncbiatomic.hpp>
+//#include <exception>
+
+#include "normbase.hpp"
+#include "basealgo.hpp"
+#include "atomic.hpp"
+
+
+class CRefCounter
+{
+public:
+	
+	CRefCounter(TAtomicCounterValueType ini = 0):
+		m_count(ini)
+	{};
+	
+	TAtomicCounterValueType operator ++(void);
+	TAtomicCounterValueType operator ++(int);
+	
+	
+	TAtomicCounterValueType operator --(void);
+	TAtomicCounterValueType operator --(int);
+	
+private:
+	TAtomicCounterType m_count;
+};
+
+
+// -- reference counter, base class for all data nodes
+class CDocNodeBase
+{
+	template <typename NODETYPE>
+	friend class CDocNodeRef;
+protected:
+	CDocNodeBase(void);
+	// -- just to make sure derived classes will have a virtual destructor
+	virtual ~CDocNodeBase(void) {};
+private:
+	void x_IncRef(void);
+	void x_DecRef(void);
+	CRefCounter m_counter;
+};
+
+
+template <typename NODETYPE>
+class CDocNodeRef
+{
+public:
+	typedef std::atomic< NODETYPE* > _TNodePtr;
+	CDocNodeRef(void);
+	CDocNodeRef(NODETYPE *node);
+	CDocNodeRef(const CDocNodeRef &src);
+	~CDocNodeRef(void);
+	CDocNodeRef & operator = (const CDocNodeRef &src);
+	
+	inline
+	NODETYPE * GetPointer(void) {return m_nodeptr.load(std::memory_order_acquire);}
+	inline
+	const NODETYPE * GetPointer(void) const {return m_nodeptr.load(std::memory_order_acquire);}
+	
+	bool operator == (const CDocNodeRef &src) const;
+	
+	
+	NODETYPE * operator -> (void) {return GetPointer();}
+	const NODETYPE * operator -> (void) const {return GetPointer();}
+	
+	NODETYPE & operator * (void);
+	const NODETYPE & operator * (void) const;
+	
+	
+	bool IsNull(void) const {return nullptr == m_nodeptr;}
+	
+	void Release(void);
+	
+	
+	
+protected:
+	NODETYPE * AtomicSwap(NODETYPE *pNewNode)
+	{
+		return m_nodeptr.exchange(pNewNode, std::memory_order_acq_rel);
+	}
+	_TNodePtr m_nodeptr;
+};
+
+template <typename NODETYPE>
+CDocNodeRef<NODETYPE> ::CDocNodeRef(void):
+	m_nodeptr(nullptr)
+{}
+
+template <typename NODETYPE>
+CDocNodeRef<NODETYPE> ::CDocNodeRef(NODETYPE *node):
+	m_nodeptr(node)
+{
+	NODETYPE *p = GetPointer();
+	if (nullptr != p) p->x_IncRef();
+}
+
+template <typename NODETYPE>
+CDocNodeRef<NODETYPE> ::CDocNodeRef(const CDocNodeRef<NODETYPE> &src):
+	m_nodeptr(src.m_nodeptr.load(std::memory_order_acquire))
+{
+	NODETYPE *p = GetPointer();
+	if (nullptr != p) p->x_IncRef();
+}
+
+template <typename NODETYPE>
+CDocNodeRef<NODETYPE> ::~CDocNodeRef(void)
+{
+	NODETYPE *p = GetPointer();
+	if (nullptr != p) p->x_DecRef();
+}
+
+template <typename NODETYPE>
+CDocNodeRef<NODETYPE> & CDocNodeRef<NODETYPE> ::operator = (const CDocNodeRef<NODETYPE> &src)
+{
+	NODETYPE * p = GetPointer();
+	if (nullptr != p)
+		p->x_IncRef();
+	NODETYPE *old = AtomicSwap(p);
+	if (nullptr != old) old->x_DecRef();
+	return *this;
+}
+
+template <typename NODETYPE>
+NODETYPE & CDocNodeRef<NODETYPE> :: operator * (void)
+{
+	NODETYPE * p = GetPointer();
+	if (nullptr == p)
+		throw CSimpleException(__FILE__, __LINE__, "Try to dereference nullptr");
+	return *p;
+}
+
+template <typename NODETYPE>
+const NODETYPE & CDocNodeRef<NODETYPE> :: operator * (void) const
+{
+	const NODETYPE * p = GetPointer();
+	if (nullptr == p)
+		throw CSimpleException(__FILE__, __LINE__, "Try to dereference nullptr");
+	return *p;
+}
+
+template <typename NODETYPE>
+bool CDocNodeRef<NODETYPE> ::operator == (const CDocNodeRef<NODETYPE> &src) const
+{
+	return m_nodeptr == src.m_nodeptr;
+}
+
+template <typename NODETYPE>
+void CDocNodeRef<NODETYPE> ::Release(void)
+{
+	NODETYPE *old = AtomicSwap(nullptr);
+	if (nullptr != old) old->x_DecRef();
+}
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/enumlit.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/enumlit.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/enumlit.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/enumlit.hpp	2018-03-13 14:39:35.281237000 -0400
@@ -0,0 +1,88 @@
+#if !defined(__ENUM_LIT__)
+#define __ENUM_LIT__
+#include <string>
+
+typedef size_t TENUMIDX;
+
+/*****************************************************
+Enumerated const char * values
+
+// -- declare
+struct TMyLits
+{
+	enum EIndex: TENUMIDX
+	{
+		eEnumStart = 0,
+		e_name1 = eEnumStart,
+		e_name2 = e_name1 + 1,
+		...
+		//
+		eEnumStop = e_namen + 1
+	};
+	
+	static const EIndex eDefault = e_name1;
+	static const char* dimLits[eEnumEnd - eEnumStart];
+	static const char* dimDisplay[eEnumEnd - eEnumStart];
+};
+
+
+// -- define
+const char* TMyLits::dimLits[] = {"name1", "name2", ...};
+const char* TMyLits::dimDisplay[] = {"Name 1", "Name 2", ...};
+******************************************************/
+
+
+template<class EnumLitType>
+const char* GetLits(TENUMIDX iIdx)
+{
+	if (iIdx < EnumLitType::eEnumStart || iIdx >= EnumLitType::eEnumStop) return EnumLitType::dimLits[EnumLitType::eDefault - EnumLitType::eEnumStart];
+	else return EnumLitType::dimLits[iIdx - EnumLitType::eEnumStart];
+}
+
+template<class EnumLitType>
+const char* GetLits2(TENUMIDX iIdx)
+{
+	if (iIdx < EnumLitType::eEnumStart || iIdx >= EnumLitType::eEnumStop) return nullptr;
+	else return EnumLitType::dimLits[iIdx - EnumLitType::eEnumStart];
+}
+
+template<class EnumLitType>
+const char* GetDisplay(TENUMIDX iIdx)
+{
+	if (iIdx < EnumLitType::eEnumStart || iIdx >= EnumLitType::eEnumStop) return EnumLitType::dimLits[EnumLitType::eDefault - EnumLitType::eEnumStart];
+	else return EnumLitType::dimDisplay[iIdx - EnumLitType::eEnumStart];
+}
+
+template<class EnumLitType>
+const char* GetDisplay2(TENUMIDX iIdx)
+{
+	if (iIdx < EnumLitType::eEnumStart || iIdx >= EnumLitType::eEnumStop) return nullptr;
+	else return EnumLitType::dimDisplay[iIdx - EnumLitType::eEnumStart];
+}
+
+// -- return eDefault if not found
+template<class EnumLitType>
+TENUMIDX GetIdx(const std::string& strLit)
+{
+	for (TENUMIDX i = EnumLitType::eEnumStart; i < EnumLitType::eEnumStop; ++i)
+	{
+		if (strLit == EnumLitType::dimLits[i - EnumLitType::eEnumStart]) return i;
+	}
+	
+	return EnumLitType::eDefault;
+}
+
+// -- return eEnumStop (invalid) if not found
+template<class EnumLitType>
+TENUMIDX GetIdx2(const std::string& strLit)
+{
+	for (TENUMIDX i = EnumLitType::eEnumStart; i < EnumLitType::eEnumStop; ++i)
+	{
+		if (strLit == EnumLitType::dimLits[i - EnumLitType::eEnumStart]) return i;
+	}
+	
+	return EnumLitType::eEnumStop;
+}
+
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/envdef.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/envdef.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/envdef.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/envdef.hpp	2018-03-13 14:39:35.419875000 -0400
@@ -0,0 +1,28 @@
+#if !defined(__ENV_DEF__)
+#define __ENV_DEF__
+#if defined(__DB_OFFLINE__)
+#include "normbase.hpp"
+#else
+#include <BasicUtils/normbase.hpp>
+#endif
+/**********************************************************************
+*	Basic Typedefs
+***********************************************************************/
+
+#include <corelib/ncbimisc.hpp>
+#include <corelib/ncbiobj.hpp>
+#include <corelib/ncbitype.h>
+
+#include <sstream>
+
+typedef ncbi::TGi GI_t;
+typedef ncbi::TSeqPos SeqLen_t;
+typedef ncbi::TSignedSeqPos SeqPos_t;
+
+typedef ncbi::TUintId PssmId_t, PIG_t, ArchId_t;
+typedef UINT32 Flags_t;
+typedef ncbi::TIntId TaxId_t, ClusterId_t, PrefTaxId_t;
+
+const SeqPos_t RESIDUE_DISPLAY_OFFSET = 1;
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ljson.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ljson.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ljson.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ljson.cpp	2018-03-13 14:39:35.468358000 -0400
@@ -0,0 +1,2288 @@
+#include "ljson.hpp"
+#include <stdio.h>
+#include <stdlib.h>
+#include <cstring>
+#include <stack>
+#include <sstream>
+#include <cmath>
+#include <limits>
+#include <cctype>
+
+
+
+//#include <memory.h>
+using namespace std;
+
+namespace LJSON
+{
+	// -- tokens in USTRING
+	static const UCHAR UC_OBJSTART('{');
+	static const UCHAR UC_OBJEND('}');
+	static const UCHAR UC_ARRAYSTART('[');
+	static const UCHAR UC_ARRAYEND(']');
+	static const UCHAR UC_JSONPSTART('(');
+	static const USTRING US_JSONPEND(");");
+	static const UCHAR UC_QUOT('"');
+	static const UCHAR UC_APOS('\'');
+	static const UCHAR UC_BKSLASH('\\');
+	static const UCHAR UC_SLASH('/');
+	static const UCHAR UC_WHITESP(' ');
+	static const UCHAR UC_COLON(':');
+	static const UCHAR UC_TAB('\t');
+	static const UCHAR UC_NEWLINE('\n');
+	static const UCHAR UC_COMMA(',');
+	
+	
+	static const USTRING US_JSUNDEF("undefined");
+	static const USTRING US_JSNULL("null");
+	static const USTRING US_JSFALSE("false");
+	static const USTRING US_JSTRUE("true");
+	static const USTRING US_COMMA(",");
+	
+	// -- number
+	static const UCHAR UC_PLUS('+');
+	static const UCHAR UC_MINUS('-');
+	static const UCHAR UC_UEXP('E');
+	static const UCHAR UC_LEXP('e');
+	static const UCHAR UC_DOT('.');
+	static const UCHAR UC_UNICODE('u');
+	// -- escape
+	
+	
+	
+	//static const size_t TOTAL_ENTITIES = 35;
+	//POD_STATICMAP PREDEF_ENTITIES[TOTAL_ENTITIES] = 
+	TEscapeSeqs MAP_ENTITIES =
+	{
+		{UC_BKSLASH, {UC_ESCAPE, UC_BKSLASH}},
+		{UC_QUOT, {UC_ESCAPE, UC_QUOT}},
+		{UC_SLASH, {UC_ESCAPE, UC_SLASH}},
+		{0x00, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('0')}},
+		{0x01, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('1')}},
+		{0x02, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('2')}},
+		{0x03, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('3')}},
+		{0x04, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('4')}},
+		{0x05, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('5')}},
+		{0x06, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('6')}},
+		{0x07, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('7')}},
+		{0x08, {UC_ESCAPE, UCHAR('b')}},
+		{0x09, {UC_ESCAPE, UCHAR('t')}},
+		{0x0a, {UC_ESCAPE, UCHAR('n')}},
+		{0x0b, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('b')}},
+		{0x0c, {UC_ESCAPE, UCHAR('f')}},
+		{0x0d, {UC_ESCAPE, UCHAR('r')}},
+		{0x0e, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('e')}},
+		{0x0f, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('0'), UCHAR('f')}},
+		{0x10, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('0')}},
+		{0x11, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('1')}},
+		{0x12, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('2')}},
+		{0x13, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('3')}},
+		{0x14, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('4')}},
+		{0x15, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('5')}},
+		{0x16, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('6')}},
+		{0x17, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('7')}},
+		{0x18, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('8')}},
+		{0x19, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('9')}},
+		{0x1a, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('a')}},
+		{0x1b, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('b')}},
+		{0x1c, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('c')}},
+		{0x1d, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('d')}},
+		{0x1e, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('e')}},
+		{0x1f, {UC_ESCAPE, UCHAR('u'), UCHAR('0'), UCHAR('0'), UCHAR('1'), UCHAR('f')}}
+	};
+	
+	//TEscapeSeqs MAP_ENTITIES =
+	//{
+	//	{UC_BKSLASH, USTRING("\\\\")},
+	//	{UC_QUOT, USTRING("\\\"")},
+	//	{UCHAR('/'), USTRING("\\/")},
+	//	// -- control chars are always escaped
+	//	{(UCHAR)0x00, USTRING("\\u0000")},
+	//	{(UCHAR)0x01, USTRING("\\u0001")},
+	//	{(UCHAR)0x02, USTRING("\\u0002")},
+	//	{(UCHAR)0x03, USTRING("\\u0003")},
+	//	{(UCHAR)0x04, USTRING("\\u0004")},
+	//	{(UCHAR)0x05, USTRING("\\u0005")},
+	//	{(UCHAR)0x06, USTRING("\\u0006")},
+	//	{(UCHAR)0x07, USTRING("\\u0007")},
+	//	//
+	//	{(UCHAR)0x08, USTRING("\\b")},
+	//	//{(UCHAR)0x09, USTRING("\\u0009")},
+	//	{(UCHAR)0x09, USTRING("\\t")},
+	//	//{(UCHAR)0x0a, USTRING("\\u000a")},
+	//	{(UCHAR)0x0a, USTRING("\\n")},
+	//	{(UCHAR)0x0b, USTRING("\\u000b")},
+	//	//{(UCHAR)0x0c, USTRING("\\u000c")},
+	//	{(UCHAR)0x0c, USTRING("\\f")},
+	//	//{(UCHAR)0x0d, USTRING("\\u000d")},
+	//	{(UCHAR)0x0d, USTRING("\\r")},
+	//	{(UCHAR)0x0e, USTRING("\\u000e")},
+	//	{(UCHAR)0x0f, USTRING("\\u000f")},
+	//	{(UCHAR)0x10, USTRING("\\u0010")},
+	//	{(UCHAR)0x11, USTRING("\\u0011")},
+	//	{(UCHAR)0x12, USTRING("\\u0012")},
+	//	{(UCHAR)0x13, USTRING("\\u0013")},
+	//	{(UCHAR)0x14, USTRING("\\u0014")},
+	//	{(UCHAR)0x15, USTRING("\\u0015")},
+	//	{(UCHAR)0x16, USTRING("\\u0016")},
+	//	{(UCHAR)0x17, USTRING("\\u0017")},
+	//	{(UCHAR)0x18, USTRING("\\u0018")},
+	//	{(UCHAR)0x19, USTRING("\\u0019")},
+	//	{(UCHAR)0x1a, USTRING("\\u001a")},
+	//	{(UCHAR)0x1b, USTRING("\\u001b")},
+	//	{(UCHAR)0x1c, USTRING("\\u001c")},
+	//	{(UCHAR)0x1d, USTRING("\\u001d")},
+	//	{(UCHAR)0x1e, USTRING("\\u001e")},
+	//	{(UCHAR)0x1f, USTRING("\\u001f")}
+	//};
+	// -- predefined escape sequences
+	//TEscapeSeqs MAP_ENTITIES;
+	
+	const char * errMsgs[eEndOfErrors] =
+	{
+		"",
+		"Undefined variable",
+		"Operation unsupported by this type of value",
+		"Input stream broken, incomplete data",
+		"Parse error: Invalid JSON data",
+		"Index beyond array boundary",
+		"Property not found",
+		"Unknown error"
+	};
+	
+	class CJSNullObj: public JSValue
+	{
+	public:
+		virtual EDataType ValueType(void) const {return eNull;}
+
+	private:
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type = eUndefined) const;
+	};
+	
+	class CJSBoolObj: public JSValue
+	{
+	public:
+		typedef JSBoolValue TValueType;
+		virtual EDataType ValueType(void) const {return eBoolean;}
+		
+		CJSBoolObj(TValueType val = false): JSValue(), m_val(val)
+		{};
+		
+		const TValueType &GetValue(void) const {return m_val;}
+		TValueType & SetValue(void) {return m_val;}
+		
+	private:
+		
+		
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type = eUndefined) const;
+		
+		TValueType m_val;
+	};
+	
+	class CJSIntObj: public JSValue
+	{
+	public:
+		typedef JSIntValue TValueType;
+		virtual EDataType ValueType(void) const {return eInteger;}
+		
+		const TValueType &GetValue(void) const {return m_val;}
+		
+		TValueType & SetValue(void) {return m_val;}
+		
+		CJSIntObj(TValueType val = 0L): JSValue(), m_val(val) {};
+		
+	private:
+		
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type = eUndefined) const;
+		
+		TValueType m_val;
+	};
+	
+	class CJSRealObj: public JSValue
+	{
+	public:
+		typedef JSRealValue TValueType;
+		virtual EDataType ValueType(void) const {return eReal;}
+		
+		CJSRealObj(TValueType val = 0.0L): JSValue(), m_val(val) {};
+			
+		const TValueType &GetValue(void) const {return m_val;}
+		TValueType & SetValue(void) {return m_val;}
+		
+	private:
+		
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type = eUndefined) const;
+		
+		TValueType m_val;
+	};
+	
+	class CJSStringObj: public JSValue
+	{
+	public:
+		typedef JSStringValue TValueType;
+		virtual EDataType ValueType(void) const {return eString;}
+		
+		CJSStringObj(const TValueType &val = k_ustrEmptyUSTRING): JSValue(), m_val(val) {};
+		const TValueType &GetValue(void) const {return m_val;}
+		TValueType & SetValue(void) {return m_val;}
+	private:
+		
+		
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type = eUndefined) const;
+		
+		TValueType m_val;
+	};
+	
+	class CJSArrayObj: public JSValue
+	{
+	public:
+		typedef JSArrayValue TValueType;
+		virtual EDataType ValueType(void) const {return eArray;}
+		
+		CJSArrayObj(void): JSValue(), m_val() {};
+		CJSArrayObj(const TValueType &val): JSValue(), m_val(val) {};
+		
+		const TValueType &GetValue(void) const {return m_val;}
+		TValueType & SetValue(void) {return m_val;}
+	private:
+		
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type = eUndefined) const;
+		
+		TValueType m_val;
+	};
+	
+	class CJSObjectObj: public JSValue
+	{
+	public:
+		typedef JSObjectValue TValueType;
+		virtual EDataType ValueType(void) const {return eObject;}
+		
+		CJSObjectObj(void): JSValue(), m_val()
+		{};
+		CJSObjectObj(const TValueType &val): JSValue(), m_val(val)
+		{};
+		
+		const TValueType &GetValue(void) const {return m_val;}
+		TValueType & SetValue(void) {return m_val;}
+	private:
+		
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type = eUndefined) const;
+		
+		TValueType m_val;
+	};
+
+
+
+	// -- array only, otherwise throw
+	template <>
+	const LJSON::JSVar & LJSON::JSVar::operator [] (size_t i) const
+	{
+		if (nullptr != m_nodeptr)
+		{
+			const CJSArrayObj * p = dynamic_cast< const CJSArrayObj * > (GetPointer());
+			if (nullptr != p)
+			{
+				const JSArrayValue &array = p->GetValue();
+				size_t ttl = array.size();
+				if (i < ttl)
+					return array[i];
+				throw JSONExcept(eOutOfArrayBoundary, errMsgs[eOutOfArrayBoundary], i);
+			}
+		}
+		throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eUndefined);
+	}
+	
+	template <>
+	const LJSON::JSVar & LJSON::JSVar::operator [] (int i) const
+	{
+		return this->LJSON::JSVar::operator [] ((size_t)i);
+	}
+	
+	template <>
+	const LJSON::JSVar & LJSON::JSVar::operator [] (unsigned int i) const
+	{
+		return this->LJSON::JSVar::operator [] ((size_t)i);
+	}
+	
+	template <>
+	const LJSON::JSVar & LJSON::JSVar::operator [] (long i) const
+	{
+		return this->LJSON::JSVar::operator [] ((size_t)i);
+	}
+	
+	template <>
+	LJSON::JSVar & LJSON::JSVar::operator [] (size_t i)
+	{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": template<size_t>" << endl;
+#endif
+// ***********************************************************/
+
+		if (nullptr != m_nodeptr)
+		{
+			CJSArrayObj * p = dynamic_cast< CJSArrayObj * > (GetPointer());
+			if (nullptr != p)
+			{
+				JSArrayValue &array = p->SetValue();
+				size_t ttl = array.size();
+				
+				if (i >= ttl)
+					array.insert(array.end(), i - ttl + 1, JSVar());
+				return array[i];
+			}
+		}
+		throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eUndefined);
+	}
+	
+	template <>
+	LJSON::JSVar & LJSON::JSVar::operator [] (int i)
+	{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": template<int>" << endl;
+#endif
+// ***********************************************************/
+
+		return this->LJSON::JSVar::operator [] ((size_t)i);
+	}
+	
+	template <>
+	LJSON::JSVar & LJSON::JSVar::operator [] (unsigned int i)
+	{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": template<unsigned>" << endl;
+#endif
+// ***********************************************************/
+
+		return this->LJSON::JSVar::operator [] ((size_t)i);
+	}
+	
+	template <>
+	LJSON::JSVar & LJSON::JSVar::operator [] (long int i)
+	{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": template<long>" << endl;
+#endif
+// ***********************************************************/
+		return this->LJSON::JSVar::operator [] ((size_t)i);
+	}
+	
+	template <>
+	LJSON::JSVar & LJSON::JSVar::operator [] (const char * key)
+	{
+		USTRING t(key);
+		return this->LJSON::JSVar::operator [] (t);
+	}
+
+	// -- read ustring lit from CUTFIstream, translate escape sequence as well
+	// -- return how many uchars read, including the last UC_QUOT
+	//size_t ReadUSTRINGLit(CUTFIstream &is, USTRING_base &dst, UCHAR endToken);
+	size_t ReadUSTRINGLit(CUTFIstream &is, USTRING &dst, UCHAR endToken);
+	JSVar ParseNumberLit(const USTRING &buf);
+	
+	// -- static 
+	JSVar null(eNull);
+	JSVar jsTrue(true);
+	JSVar jsFalse(false);
+	
+};
+
+using namespace LJSON;
+
+//struct TJSONINIT
+//{
+//	TJSONINIT(void);
+//} x_init_obj;
+//
+//TJSONINIT::TJSONINIT(void)
+//{
+//	CreateEscMap(PREDEF_ENTITIES, TOTAL_ENTITIES, MAP_ENTITIES);
+//}
+
+
+
+
+// -- JSONDoc
+LJSON::JSONDoc::JSONDoc(JSVar root, const USTRING &jsonp, int enc):
+	m_root(root), m_jsonp(jsonp), m_enc(enc)
+{}
+
+void LJSON::JSONDoc::Print(ostream &os) const
+{
+	CUTFOstream tokenos(os, m_enc), dataos(os, m_enc, &MAP_ENTITIES);
+	if (E_UTF8 != m_enc) tokenos.PrintBOM();
+	if (!m_jsonp.empty())
+	{
+		tokenos << m_jsonp << UC_JSONPSTART;
+		m_root.Print(tokenos, dataos);
+		tokenos << US_JSONPEND;
+	}
+	else
+		m_root.Print(tokenos, dataos);
+	
+}
+void LJSON::JSONDoc::Print(ostream &os, int lvl) const
+{
+	USTRING ind(k_ustrEmptyUSTRING);
+	ind.append(lvl, UC_TAB);
+	
+	CUTFOstream tokenos(os, m_enc), dataos(os, m_enc, &MAP_ENTITIES);
+	if (E_UTF8 != m_enc) tokenos.PrintBOM();
+	
+	if (!m_jsonp.empty())
+	{
+		tokenos << ind << m_jsonp << UC_JSONPSTART << UC_NEWLINE;
+		m_root.Print(tokenos, dataos, lvl + 1);
+		tokenos << ind << US_JSONPEND;
+	}
+	else
+		m_root.Print(tokenos, dataos, lvl);
+}
+
+
+LJSON::JSVar::JSVar (EDataType t):
+	TParent ()
+{
+	switch (t)
+	{
+	default:
+		break;
+	case eNull:
+		if (nullptr == LJSON::null.m_nodeptr)	//null is not initialized, this is the first init
+		{
+			LJSON::null.TParent :: operator = (new CJSNullObj);
+		}
+		else
+		{
+			this->TParent::operator = (LJSON::null);
+		}
+		break;
+	case eBoolean:
+		//if (nullptr == jsFalse.m_nodeptr)	//null is not initialized, this is the first init
+		//	jsFalse = new CJSBoolObj(false);
+		//else
+			this->TParent::operator = (jsFalse);
+		//m_nodeptr = new CJSBoolObj;
+		break;
+	case eInteger:
+		this->TParent::operator = (new CJSIntObj);
+		break;
+	case eReal:
+		this->TParent::operator = (new CJSRealObj);
+		break;
+	case eString:
+		this->TParent::operator = (new CJSStringObj);
+		break;
+	case eArray:
+		this->TParent::operator = (new CJSArrayObj);
+		break;
+	case eObject:
+		this->TParent::operator = (new CJSObjectObj);
+		break;
+	}
+}
+
+
+LJSON::JSVar::JSVar(const JSVar &src):
+	TParent (src)
+{}
+
+LJSON::JSVar::JSVar (JSBoolValue val):
+	TParent ()
+{
+	if (val)	//true
+	{
+		if (nullptr == jsTrue.m_nodeptr)
+			jsTrue.TParent :: operator = (new CJSBoolObj(true));
+		else
+			this->TParent::operator = (jsTrue);
+	}
+	else
+	{
+		if (nullptr == jsFalse.m_nodeptr)
+			jsFalse.TParent :: operator = (new CJSBoolObj(false));
+		else
+			this->TParent::operator = (jsFalse);
+	}
+}
+
+LJSON::JSVar::JSVar(const JSIntValue & val):
+	TParent (new CJSIntObj((JSIntValue)val))
+{}
+
+LJSON::JSVar::JSVar(long val):
+	TParent (new CJSIntObj((JSIntValue)val))
+{}
+
+LJSON::JSVar::JSVar(unsigned long val):
+	TParent (new CJSIntObj((JSIntValue)val))
+{}
+
+LJSON::JSVar::JSVar(int val):
+	TParent (new CJSIntObj((JSIntValue)val))
+{}
+
+LJSON::JSVar::JSVar(unsigned int val):
+	TParent (new CJSIntObj((JSIntValue)val))
+{}
+
+LJSON::JSVar::JSVar(short val):
+	TParent (new CJSIntObj((JSIntValue)val))
+{}
+
+LJSON::JSVar::JSVar(unsigned short val):
+	TParent (new CJSIntObj((JSIntValue)val))
+{}
+
+
+LJSON::JSVar::JSVar(const JSRealValue & val):
+	TParent (new CJSRealObj(val))
+{}
+
+LJSON::JSVar::JSVar(double val):
+	TParent (new CJSRealObj((JSRealValue)val))
+{}
+
+LJSON::JSVar::JSVar (const JSStringValue & val):
+	TParent (new CJSStringObj(val))
+{}
+
+LJSON::JSVar::JSVar (const std::string & utf8):
+	TParent (new CJSStringObj (USTRING(utf8)))
+{}
+
+
+LJSON::JSVar::JSVar (const char * utf8):
+	TParent (new CJSStringObj (USTRING(utf8)))
+{}
+
+LJSON::JSVar::JSVar(const JSArrayValue & val):
+	TParent (new CJSArrayObj(val))
+{}
+
+LJSON::JSVar::JSVar(const JSObjectValue & val):
+	TParent (new CJSObjectObj(val))
+{}
+
+
+
+
+
+
+//const JSVar & LJSON::JSVar::operator = (const JSVar &src)
+//{
+//	TParent::operator = (src);
+//	return *this;
+//}
+
+JSBoolValue LJSON::JSVar::GetBoolValue(void) const
+{
+	if (nullptr != m_nodeptr)
+	{
+		const CJSBoolObj * p = dynamic_cast< const CJSBoolObj * > (GetPointer());
+		if (nullptr != p)
+			return p->GetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eBoolean);
+}
+
+const JSIntValue & LJSON::JSVar::GetIntValue(void) const
+{
+	if (nullptr != m_nodeptr)
+	{
+		const CJSIntObj * p = dynamic_cast< const CJSIntObj * > (GetPointer());
+		if (nullptr != p)
+			return p->GetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eInteger);
+}
+
+const JSRealValue & LJSON::JSVar::GetRealValue(void) const
+{
+	if (nullptr != m_nodeptr)
+	{
+		const CJSRealObj * p = dynamic_cast< const CJSRealObj * > (GetPointer());
+		if (nullptr != p)
+			return p->GetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eReal);
+}
+
+const JSStringValue & LJSON::JSVar::GetStringValue(void) const
+{
+	if (nullptr != m_nodeptr)
+	{
+		const CJSStringObj * p = dynamic_cast< const CJSStringObj * > (GetPointer());
+		if (nullptr != p)
+			return p->GetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eString);
+}
+
+const JSArrayValue & LJSON::JSVar::GetArrayValue(void) const
+{
+	if (nullptr != m_nodeptr)
+	{
+		const CJSArrayObj * p = dynamic_cast< const CJSArrayObj * > (GetPointer());
+		if (nullptr != p)
+			return p->GetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eArray);
+}
+
+const JSObjectValue & LJSON::JSVar::GetObjectValue(void) const
+{
+	if (nullptr != m_nodeptr)
+	{
+		const CJSObjectObj * p = dynamic_cast< const CJSObjectObj * > (GetPointer());
+		if (nullptr != p)
+			return p->GetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eObject);
+}
+
+
+//JSBoolValue & LJSON::JSVar::SetBoolValue(void)
+//{
+//	if (nullptr != m_nodeptr)
+//	{
+//		CJSBoolObj * p = dynamic_cast< CJSBoolObj * > (m_nodeptr);
+//		if (nullptr != p)
+//			return p->SetValue();
+//	}
+//	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eBoolean);
+//}
+
+JSIntValue & LJSON::JSVar::SetIntValue(void)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSIntObj * p = dynamic_cast< CJSIntObj * > (GetPointer());
+		if (nullptr != p)
+			return p->SetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eInteger);
+}
+
+JSRealValue & LJSON::JSVar::SetRealValue(void)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSRealObj * p = dynamic_cast< CJSRealObj * > (GetPointer());
+		if (nullptr != p)
+			return p->SetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eReal);
+}
+
+JSStringValue & LJSON::JSVar::SetStringValue(void)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSStringObj * p = dynamic_cast< CJSStringObj * > (GetPointer());
+		if (nullptr != p)
+			return p->SetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eString);
+}
+
+JSArrayValue & LJSON::JSVar::SetArrayValue(void)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSArrayObj * p = dynamic_cast< CJSArrayObj * > (GetPointer());
+		if (nullptr != p)
+			return p->SetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eArray);
+}
+
+JSObjectValue & LJSON::JSVar::SetObjectValue(void)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSObjectObj * p = dynamic_cast< CJSObjectObj * > (GetPointer());
+		if (nullptr != p)
+			return p->SetValue();
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eObject);
+}
+
+
+//void LJSON::JSVar::SetBoolValue(JSBoolValue val)
+//{
+//	if (nullptr != m_nodeptr)
+//	{
+//		CJSBoolObj * p = dynamic_cast< CJSBoolObj * > (m_nodeptr);
+//		if (nullptr != p)
+//		{
+//			p->SetValue() = val;
+//			return;
+//		}
+//	}
+//	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eBoolean);
+//}
+
+void LJSON::JSVar::SetIntValue(const JSIntValue & val)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSIntObj * p = dynamic_cast< CJSIntObj * > (GetPointer());
+		if (nullptr != p)
+		{
+			p->SetValue() = val;
+			return;
+		}
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eInteger);
+}
+
+void LJSON::JSVar::SetRealValue(const JSRealValue & val)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSRealObj * p = dynamic_cast< CJSRealObj * > (GetPointer());
+		if (nullptr != p)
+		{
+			p->SetValue() = val;
+			return;
+		}
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eReal);
+}
+
+void LJSON::JSVar::SetStringValue(const JSStringValue & val)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSStringObj * p = dynamic_cast< CJSStringObj * > (GetPointer());
+		if (nullptr != p)
+		{
+			p->SetValue() = val;
+			return;
+		}
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eString);
+}
+
+void LJSON::JSVar::SetArrayValue(const JSArrayValue & val)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSArrayObj * p = dynamic_cast< CJSArrayObj * > (GetPointer());
+		if (nullptr != p)
+		{
+			p->SetValue() = val;
+			return;
+		}
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eArray);
+}
+
+void LJSON::JSVar::SetObjectValue(const JSObjectValue & val)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSObjectObj * p = dynamic_cast< CJSObjectObj * > (GetPointer());
+		if (nullptr != p)
+		{
+			p->SetValue() = val;
+			return;
+		}
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eObject);
+}
+
+void LJSON::JSVar::Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+	if (nullptr == m_nodeptr)
+		tokenos << US_JSNULL;
+	else
+		GetPointer()->x_Print(tokenos, dataos);
+}
+
+void LJSON::JSVar::Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type) const
+{
+	if (nullptr == m_nodeptr)
+	{
+		switch (p_type)
+		{
+		case eObject:
+			tokenos << UC_WHITESP;
+		default:
+			tokenos << US_JSNULL;
+			break;
+		case eArray:	//	array member
+			{
+				USTRING ind(k_ustrEmptyUSTRING);
+				ind.append(lvl, UC_TAB);
+				tokenos << UC_NEWLINE << ind << US_JSNULL;
+			}
+			break;
+		}
+	}
+	else
+		GetPointer()->x_Print(tokenos, dataos, lvl, p_type);
+}
+
+EDataType LJSON::JSVar::ValueType(void) const
+{
+	if (nullptr == m_nodeptr) return eUndefined;
+	return GetPointer()->ValueType();
+}
+
+
+size_t LJSON::JSVar::length(void) const
+{
+	EDataType dt = eUndefined;
+	if (nullptr != m_nodeptr)
+	{
+		dt = GetPointer()->ValueType();
+		
+		switch (dt)
+		{
+		case eArray:
+			{
+				const CJSArrayObj * pValObj = dynamic_cast< const CJSArrayObj* > (GetPointer());
+				if (nullptr != pValObj)
+				{
+					return pValObj->GetValue().size();
+				}
+			}
+			break;
+		case eObject:
+			{
+				const CJSObjectObj * pValObj = dynamic_cast< const CJSObjectObj* > (GetPointer());
+				if (nullptr != pValObj)
+				{
+					return pValObj->GetValue().size();
+				}
+			}
+			break;
+		default:;
+		}
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], dt);
+}
+
+LJSON::JSVar & LJSON::JSVar::push(const LJSON::JSVar &src)
+{
+	if (nullptr != m_nodeptr)
+	{
+		CJSArrayObj * p = dynamic_cast< CJSArrayObj * > (GetPointer());
+		if (nullptr != p)
+		{
+			JSArrayValue &array = p->SetValue();
+			array.push_back(src);
+			return array.back();
+		}
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eUndefined);
+}
+
+
+// -- object only. 
+const LJSON::JSVar & LJSON::JSVar::operator [] (const USTRING & key) const
+{
+	if (nullptr != m_nodeptr || key.empty())
+	{
+		const CJSObjectObj * p = dynamic_cast< const CJSObjectObj * > (GetPointer());
+		if (nullptr != p)
+		{
+			const JSObjectValue &obj = p->GetValue();
+			JSObjectValue::const_iterator iter = obj.find(key);
+			if (obj.end() != iter)	//found
+				return iter->second;
+			throw JSONExcept(ePropNameNotFound, std::string(errMsgs[ePropNameNotFound]) + " -- " + (std::string)key);
+		}
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eUndefined);
+}
+
+const LJSON::JSVar & LJSON::JSVar::operator [] (const string & key) const
+{
+	USTRING t(key);
+	return this-> LJSON::JSVar::operator [] (t);
+}
+
+const LJSON::JSVar & LJSON::JSVar::operator [] (const char * key) const
+{
+	USTRING t(key);
+	return this-> LJSON::JSVar::operator [] (t);
+}
+
+const LJSON::JSVar & LJSON::JSVar::operator [] (char * key) const
+{
+	return this-> LJSON::JSVar::operator [] ((const char*)key);
+}
+	
+	
+
+LJSON::JSVar & LJSON::JSVar::operator [] (const USTRING & key)
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": key = " << key << ", m_nodeptr = " << (void*)m_nodeptr << endl;
+#endif
+// ***********************************************************/
+
+	if (nullptr != m_nodeptr || key.empty())
+	{
+		CJSObjectObj * p = dynamic_cast< CJSObjectObj * > (GetPointer());
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": p = " << (void*)p << endl;
+#endif
+// ***********************************************************/
+
+		if (nullptr != p)
+		{
+			JSObjectValue &obj = p->SetValue();
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": obj.size() = " << obj.size() << endl;
+#endif
+// ***********************************************************/
+
+			JSObjectValue::iterator iter = obj.find(key);
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": obj.end() == iter is " << (obj.end() == iter) << endl;
+#endif
+// ***********************************************************/
+
+			if (obj.end() == iter)	//not found
+			{
+				pair<JSObjectValue::iterator, bool> insertResult = obj.insert(std::pair<USTRING, JSVar> (key, JSVar()));
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": insertResult.second = " << insertResult.second << ", obj.size() = " << obj.size() << endl;
+#endif
+// ***********************************************************/
+
+				iter = insertResult.first;
+			}
+			return iter->second;
+		}
+	}
+	throw JSONExcept(eUnsupportedOperation, errMsgs[eUnsupportedOperation], eUndefined);
+}
+
+LJSON::JSVar & LJSON::JSVar::operator [] (const string & key)
+{
+	USTRING t(key);
+	return this-> LJSON::JSVar::operator [] (t);
+}
+
+LJSON::JSVar & LJSON::JSVar::operator [] (const char * key)
+{
+
+	USTRING t(key);
+	return this-> LJSON::JSVar::operator [] (t);
+}
+
+
+LJSON::JSVar & LJSON::JSVar::operator [] (char * key)
+{
+	return this-> LJSON::JSVar::operator [] ((const char*)key);
+}
+
+
+// -- implements of actual value object methods
+
+void LJSON::CJSNullObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+	tokenos << US_JSNULL;
+}
+
+void LJSON::CJSNullObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type) const
+{
+	switch (p_type)
+	{
+	case eObject:
+		tokenos << UC_WHITESP;
+	default:
+		x_Print(tokenos, dataos);
+		break;
+	case eArray:	//	array member
+		{
+			USTRING ind(k_ustrEmptyUSTRING);
+			ind.append(lvl, UC_TAB);
+			tokenos << UC_NEWLINE << ind;
+			x_Print(tokenos, dataos);
+		}
+		break;
+	}
+}
+
+void LJSON::CJSBoolObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+	tokenos << (m_val ? US_JSTRUE : US_JSFALSE);
+}
+
+void LJSON::CJSBoolObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type) const
+{
+	switch (p_type)
+	{
+	case eObject:
+		tokenos << UC_WHITESP;
+	default:
+		x_Print(tokenos, dataos);
+		break;
+	case eArray:	//	array member
+		{
+			USTRING ind(k_ustrEmptyUSTRING);
+			ind.append(lvl, UC_TAB);
+			tokenos << UC_NEWLINE << ind;
+			x_Print(tokenos, dataos);
+		}
+		break;
+	}
+}
+
+
+void LJSON::CJSIntObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+	char dimBuf[3 * sizeof(TValueType)];
+	sprintf(dimBuf, "%lld", m_val);
+	tokenos << USTRING(dimBuf);
+}
+
+void LJSON::CJSIntObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type) const
+{
+	switch (p_type)
+	{
+	case eObject:
+		tokenos << UC_WHITESP;
+	default:
+		x_Print(tokenos, dataos);
+		break;
+	case eArray:	//	array member
+		{
+			USTRING ind(k_ustrEmptyUSTRING);
+			ind.append(lvl, UC_TAB);
+			tokenos << UC_NEWLINE << ind;
+			x_Print(tokenos, dataos);
+		}
+		break;
+	}
+}
+
+void LJSON::CJSRealObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+	char dimBuf[128];
+	sprintf(dimBuf, "%.10Lg", m_val);
+	tokenos << USTRING(dimBuf);
+}
+
+void LJSON::CJSRealObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type) const
+{
+	switch (p_type)
+	{
+	case eObject:
+		tokenos << UC_WHITESP;
+	default:
+		x_Print(tokenos, dataos);
+		break;
+	case eArray:	//	array member
+		{
+			USTRING ind(k_ustrEmptyUSTRING);
+			ind.append(lvl, UC_TAB);
+			tokenos << UC_NEWLINE << ind;
+			x_Print(tokenos, dataos);
+		}
+		break;
+	}
+}
+
+void LJSON::CJSStringObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+	tokenos << UC_QUOT;
+	dataos << m_val;
+	tokenos << UC_QUOT;
+}
+
+void LJSON::CJSStringObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type) const
+{
+	switch (p_type)
+	{
+	case eObject:
+	tokenos << UC_WHITESP;
+	default:
+		x_Print(tokenos, dataos);
+		break;
+	case eArray:	//	array member
+		{
+			USTRING ind(k_ustrEmptyUSTRING);
+			ind.append(lvl, UC_TAB);
+			tokenos << UC_NEWLINE << ind;
+			x_Print(tokenos, dataos);
+		}
+		break;
+	}
+}
+
+void LJSON::CJSArrayObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+	const USTRING *dimSep = &k_ustrEmptyUSTRING;
+	tokenos << UC_ARRAYSTART;
+	
+	for (TValueType :: const_iterator iter = m_val.begin(), iterEnd = m_val.end(); iterEnd != iter; ++iter)
+	{
+		tokenos << *dimSep;
+		iter->Print(tokenos, dataos);
+		dimSep = &US_COMMA;
+	}
+	tokenos << UC_ARRAYEND;
+}
+
+void LJSON::CJSArrayObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type) const
+{
+	USTRING ind(k_ustrEmptyUSTRING);
+	ind.append(lvl, UC_TAB);
+	
+	if (m_val.empty())
+	{
+		switch (p_type)
+		{
+		case eObject:
+			tokenos << UC_WHITESP;
+		default:
+			tokenos << UC_ARRAYSTART << UC_ARRAYEND;
+			break;
+		case eArray:
+			tokenos << UC_NEWLINE << ind << UC_ARRAYSTART << UC_ARRAYEND;
+			break;
+		}
+	}
+	else
+	{
+		const USTRING *dimSep = &k_ustrEmptyUSTRING;
+		tokenos << UC_NEWLINE << ind << UC_ARRAYSTART;
+		for (TValueType :: const_iterator iter = m_val.begin(), iterEnd = m_val.end(); iterEnd != iter; ++iter)
+		{
+			tokenos << *dimSep;
+			iter->Print(tokenos, dataos, lvl + 1, eArray);
+			dimSep = &US_COMMA;
+		}
+		tokenos << UC_NEWLINE << ind << UC_ARRAYEND;
+	}
+}
+
+
+void LJSON::CJSObjectObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Entering void LJSON::CJSObjectObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const, m_val.size() = " << m_val.size() << endl;
+#endif
+// ***********************************************************/
+
+	const USTRING *dimSep = &k_ustrEmptyUSTRING;
+	tokenos << UC_OBJSTART;
+	
+	for (TValueType :: const_iterator iter = m_val.begin(), iterEnd = m_val.end(); iterEnd != iter; ++iter)
+	{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": iter->first = " << iter->first << endl;
+#endif
+// ***********************************************************/
+
+		tokenos << *dimSep << UC_QUOT;
+		dataos << iter->first;	//key
+		tokenos << UC_QUOT << UC_COLON;
+		iter->second.Print(tokenos, dataos);
+		
+		dimSep = &US_COMMA;
+	}
+	tokenos << UC_OBJEND;
+}
+
+void LJSON::CJSObjectObj::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type) const
+{
+	USTRING ind(k_ustrEmptyUSTRING);
+	ind.append(lvl, UC_TAB);
+	
+	if (m_val.empty())
+	{
+		switch (p_type)
+		{
+		case eObject:
+			tokenos << UC_WHITESP;
+		default:
+			tokenos << UC_OBJSTART << UC_OBJEND;
+			break;
+		case eArray:
+			tokenos << UC_NEWLINE << ind << UC_OBJSTART << UC_OBJEND;
+			break;
+		}
+	}
+	else
+	{
+		const USTRING *dimSep = &k_ustrEmptyUSTRING;
+		tokenos << UC_NEWLINE << ind << UC_OBJSTART;
+		for (TValueType :: const_iterator iter = m_val.begin(), iterEnd = m_val.end(); iterEnd != iter; ++iter)
+		{
+			tokenos << *dimSep << UC_NEWLINE << ind << UC_TAB << UC_QUOT;
+			dataos << iter->first;
+			tokenos << UC_QUOT << UC_COLON << UC_WHITESP;
+			
+			iter->second.Print(tokenos, dataos, lvl + 1, eObject);
+			dimSep = &US_COMMA;
+		}
+		tokenos << UC_NEWLINE << ind << UC_OBJEND;
+	}
+}
+
+// -- will not clear dst, just append
+// -- endToken should be '"' or '\''
+//size_t LJSON::ReadUSTRINGLit(CUTFIstream &is, USTRING_base &dst, UCHAR endToken)
+size_t LJSON::ReadUSTRINGLit(CUTFIstream &is, USTRING &dst, UCHAR endToken)
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Entering ReadUSTRINGLit, endToken = " << (char)endToken << endl;
+#endif
+// ***********************************************************/
+
+	static const size_t UNICHARS = 5;
+	size_t uc_count = 0;
+	UCHAR uc = 0;
+	
+	bool bInEscape = false;
+	size_t UniIdx = UNICHARS;
+	char dimUniBuf[UNICHARS + 1] = {0, 0, 0, 0, 0};
+	
+	
+	while(is.ReadUC(uc))
+	{
+		++uc_count;
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": UCAHR read = " << uc_count << ", current uc = ";
+if (uc >= 0x20 && uc <= 127) cerr << (char)uc;
+else cerr << hex << uc << dec;
+cerr << endl;
+#endif
+// ***********************************************************/
+
+		switch (uc)
+		{
+		case UC_BKSLASH:	//backslash, escape sequence
+			if (bInEscape)
+			{
+				if (UniIdx >= UNICHARS)	//not in unicode
+				{
+					dst.push_back(uc);
+					bInEscape = false;
+				}
+				else	//in partial unicode, treat as invalid unicode sequence and push everything as individual chars
+				{
+					dst.push_back(UC_UNICODE);
+					for (size_t i = 0; i < UniIdx; ++i)
+						dst.push_back(dimUniBuf[i]);
+					UniIdx = UNICHARS;	//turn unicode off
+					// -- suppose the previous \u has been treated as u, bInEscape should be off, then this \\ will turn it back on, so keep bInEscape as true
+				}
+			}
+			else
+				bInEscape = true;
+			break;
+		case UC_UNICODE:	//u
+			if (bInEscape)
+			{
+				if (UniIdx >= UNICHARS)	//not in unicode)
+					UniIdx = 0;	//turn on unicode 
+				else	//in unicode mode, u is an invalid char. So invalidate the unicode sequence and treat all chars as normal chars
+				{
+					dst.push_back(UC_UNICODE);
+					for (size_t i = 0; i < UniIdx; ++i)
+						dst.push_back(dimUniBuf[i]);
+					UniIdx = UNICHARS;	//turn unicode off
+					dst.push_back(UC_UNICODE);
+					bInEscape = false;
+					// -- suppose the previous \u has been treated as u, bInEscape should be off, then this \\ will turn it back on, so keep bInEscape as true
+				}
+			}
+			else
+				dst.push_back(uc);	//normal char
+			break;
+		//case endToken:	//" or ', end of string
+		//	if (bInEscape)
+		//	{
+		//		if (UniIdx < UNICHARS)	//in unicode, invalidate it
+		//		{
+		//			dst.push_back(UC_UNICODE);
+		//			for (size_t i = 0; i < UniIdx; ++i)
+		//				dst.push_back(dimUniBuf[i]);
+		//			// -- done here
+		//			goto labelDone; 
+		//		}
+		//		else	//normal char
+		//		{
+		//			dst.push_back(uc);	//normal char
+		//			bInEscape = false;
+		//		}
+		//	}
+		//	else
+		//		goto labelDone;
+		//	break;
+		
+		default:
+			if (bInEscape)
+			{
+				if (UniIdx < UNICHARS)	//unicode, only accept hex digits
+				{
+					if ((uc >= '0' && uc <= '9') || (uc >= 'a' && uc <= 'f') || (uc >= 'A' && uc <= 'F'))	//valid
+					{
+						dimUniBuf[UniIdx++] = (char)uc;
+						if (UniIdx == UNICHARS)	//sequence complete
+						{
+							uc = 0;
+							sscanf(dimUniBuf, "%4x", &uc);
+							dst.push_back(uc);
+							bInEscape = false;
+						}
+					}
+					else	//invalid unicode char
+					{
+						dst.push_back(UC_UNICODE);
+						for (size_t i = 0; i < UniIdx; ++i)
+							dst.push_back(dimUniBuf[i]);
+						UniIdx = UNICHARS;	//turn unicode off
+						
+						if (uc == endToken)	//end
+							goto labelDone;
+						dst.push_back(uc);
+						bInEscape = false;
+					}
+				}
+				else	//not in unicode
+				{
+					switch (uc)
+					{
+					case 'b':	//backspace
+						dst.push_back(0x8);
+						break;
+					case 'f':	//formfead
+						dst.push_back(0xc);
+						break;
+					case 'n':	//newline
+						dst.push_back(UC_NEWLINE);
+						break;
+					case 'r':	//Carriage return
+						dst.push_back(0xd);
+						break;
+					case 't':	//tab
+						dst.push_back(UC_TAB);
+						break;
+					default:
+						dst.push_back(uc);
+						break;
+					}
+					
+					bInEscape = false;
+				}
+			}
+			else	//end
+			{
+				if (uc == endToken)
+					goto labelDone;
+				dst.push_back(uc);
+			}
+		}
+	}
+	
+	// -- unexpected end of stream
+	throw JSONExcept(eStreamBroken, errMsgs[eStreamBroken], uc_count);
+	
+labelDone:	
+	return uc_count;
+}
+
+JSVar LJSON::ParseNumberLit(const USTRING &lit)
+{
+	size_t len = lit.size(), idx = 0, signpos = string::npos, dotpos = string::npos, epos = string::npos, esignpos = string::npos;
+	bool hasValue = false, hasNZValue = false, hasExp = false, hasNZExp = false;
+	
+	string strBuf;
+	strBuf.reserve(len);
+	
+	stringstream ss;
+	UCHAR uc = 0;
+	while (idx < len)
+	{
+		uc = lit[idx];
+		switch (uc)
+		{
+		case UC_MINUS:
+		case UC_PLUS:
+			if (0 == idx)
+				signpos = 0;
+			else if (epos == idx - 1)	//only valid position
+				esignpos = idx;
+			else
+			{
+				ss << "Sign only valid at the beginning of numbers";
+				goto labelMalformat;
+			}
+			break;
+		case UC_UEXP:
+		case UC_LEXP:
+			//if (string::npos == epos && hasMantissa && dotpos != idx - 1)
+			//	epos = idx;
+			if (string::npos != epos)
+			{
+				ss << "Extra exponent token";
+				goto labelMalformat;
+			}
+			else if (!hasValue)
+			{
+				ss << "Exponent token without mantissa part";
+				goto labelMalformat;
+			}
+			else if (dotpos == idx - 1)
+			{
+				ss << "Exponent token with incomplete mantissa part";
+				goto labelMalformat;
+			}
+			else
+				epos = idx;
+			break;
+		case UC_DOT:
+			if (string::npos != epos)
+			{
+				ss << "Exponent part must be an integer";
+				goto labelMalformat;
+			}
+			else if (string::npos != dotpos)
+			{
+				ss << "Extra decimal point";
+				goto labelMalformat;
+			}
+			else
+				dotpos = idx;
+			
+			break;
+		case 0x30:	//'0', leading zero problem
+			if (string::npos != epos)	//exponent part
+			{
+				if (hasExp && !hasNZExp)
+				{
+					ss << "Excessive leading zero in exponent part";
+					goto labelMalformat;
+				}
+				hasExp = true;
+			}
+			else if (string::npos != dotpos)	//value part, has dot
+			{
+				hasValue = true;
+			}
+			else if (!hasValue)
+				hasValue = true;
+			else if (!hasNZValue)
+			{
+				ss << "Excessive leading zero";
+				goto labelMalformat;
+			}
+
+			break;
+				
+		default:
+			if (uc >= 0x31L && uc <= 0x39L)	//1 - 9
+			{
+				if (string::npos == epos)
+				{
+					hasNZValue = true;
+					hasValue = true;
+				}
+				else
+				{
+					hasExp = true;
+					hasNZExp = true;
+				}
+			}
+			else
+			{
+				ss << "Invalid character U+" << hex << uc << dec << " in number literal";
+				goto labelMalformat;
+			}
+			break;
+		}
+		strBuf.push_back((char)uc);
+		++idx;
+	}
+	
+	if (!hasValue)
+	{
+		ss << "Invalid number literal";
+		goto labelMalformat;
+	}
+	else if (string::npos != epos && !hasExp)
+	{
+		ss << "Missing exponent part";
+		goto labelMalformat;
+	}
+	else if (string::npos == dotpos && string::npos == epos)	//integer
+	{
+		JSIntValue val = 0;
+		sscanf(strBuf.c_str(), "%lld", &val);
+		return JSVar(val);
+	}
+	else
+	{
+		JSRealValue val = 0;
+		sscanf(strBuf.c_str(), "%Lg", &val);
+		return JSVar(val);
+	}
+	
+	// -- should not happen
+	return JSVar();
+labelMalformat:
+	throw JSONExcept(eJSONDataError, ss.str() + " - " + strBuf, uc);	
+}
+
+istream & LJSON::operator >> (istream &is, LJSON::JSVar &dst)
+{
+	
+	enum EStatus
+	{
+		eValueStart,	//must start a value, can't be value-ending tokens
+		eValue,	//reading a value. can accept value-ending tokens
+		eValueEnd,	//must read a value-ending token. 
+		eNameStart,	//must start a property name (of object).Wait for the " token to start a name string
+		eNameEnd	//property name ended (after receiving the closing ". must wait for ':' token.
+	} eStatus = eValueStart;
+	
+	stringstream ss;	//for message
+	
+	stack<JSVar> stkContainers;	//parent container for current values
+	
+	USTRING name(k_ustrEmptyUSTRING), buf(k_ustrEmptyUSTRING);
+	
+	UCHAR uc = 0;
+	size_t c_counter = 0;
+	
+	is >> noskipws;
+	CUTFIstream srcstrm(is);
+	
+	while (srcstrm.ReadUC(uc))
+	{
+		++c_counter;
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": c =' " << c << "', buf = \"" << buf << "\", eStatus = " << eStatus << ", buf = " << buf << ", c_counter = " << c_counter << endl;
+#endif
+// ***********************************************************/
+		
+		switch (eStatus)
+		{
+		case eValueStart:
+			if (uc <= 0x20) continue;
+
+			switch (uc)
+			{
+			case UC_OBJSTART:	//start of 
+				{
+					JSVar newVal(eObject);
+					if (!stkContainers.empty())	//has parent
+					{
+						JSVar p = stkContainers.top();
+						if (eArray == p.ValueType())
+							p.push(newVal);
+						else
+						{
+							p[name] = newVal;
+							name.clear();
+						}
+					}
+					stkContainers.push(newVal);
+					eStatus = eNameStart;	//waiting for name
+				}
+				break;
+			case UC_ARRAYSTART:	//start of array
+				{
+					JSVar newVal(eArray);
+					if (!stkContainers.empty())	//has parent
+					{
+						JSVar p = stkContainers.top();
+						if (eArray == p.ValueType())
+							p.push(newVal);
+						else
+						{
+							p[name] = newVal;
+							name.clear();
+						}
+					}
+					stkContainers.push(newVal);
+					eStatus = eValue;	//waiting for name
+				}
+				break;
+			case UC_QUOT:	//start of string
+			case UC_APOS:	//start of string
+				{
+					JSVar newVal(eString);
+					try
+					{
+						c_counter += ReadUSTRINGLit(srcstrm, newVal.SetStringValue(), uc);
+					}
+					catch (JSONExcept e)
+					{
+						c_counter += e.GetParam();
+						size_t bytes = srcstrm.GetCurrIstreamPos();
+						ss << __FILE__ << ':' << __LINE__ << ": " << e.what() << " at position " << bytes << ", " << c_counter << " unicode characters read";
+						
+						//throw JSONExcept(e.ValueType(), ss.str(), bytes);
+						goto labelJSONError;
+					}
+					catch (...)
+					{
+						size_t bytes = srcstrm.GetCurrIstreamPos();
+						ss << __FILE__ << ':' << __LINE__ << ": Unspecified streaming error at position " << bytes;
+						//throw JSONExcept(eUnknownError, ss.str(), bytes);
+						goto labelJSONError;
+					}
+					
+					if (!stkContainers.empty())	//has parent
+					{
+						JSVar p = stkContainers.top();
+						if (eArray == p.ValueType())
+							p.push(newVal);
+						else
+						{
+							p[name] = newVal;
+							name.clear();
+						}
+						eStatus = eValueEnd;	
+					}
+					else	//we are done here
+					{
+						dst = newVal;
+						goto labelDone;	//done
+					}
+					//waiting for name
+				}
+				break;
+			case UC_DOT:
+			case UC_PLUS:
+			case UC_MINUS:
+				buf.push_back(uc);
+				eStatus = eValue;
+				break;
+			default:
+				if (('0' <= uc && '9' >= uc) || ('a' <= uc && 'z' >= uc) || ('A' <= uc && 'Z' >= uc))	//is alpha num
+				{
+					buf.push_back(uc);
+					eStatus = eValue;
+				}
+				else
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Invalid unicode character U+" << hex << uc << dec << " at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos();
+					goto labelJSONError;
+				}
+				break;
+			}
+			break;
+		case eValue:
+			switch (uc)
+			{
+			case UC_QUOT:	//start of string
+			case UC_APOS:	//start of string
+				if (buf.empty())	//no other value literal collected yet
+				{
+					JSVar newVal(eString);
+					try
+					{
+						c_counter += ReadUSTRINGLit(srcstrm, newVal.SetStringValue(), uc);
+					}
+					catch (JSONExcept e)
+					{
+						c_counter += e.GetParam();
+						size_t bytes = srcstrm.GetCurrIstreamPos();
+						ss << e.what() << " at position " << bytes << ", " << c_counter << " unicode characters read";
+						
+						//throw JSONExcept(e.ValueType(), ss.str(), bytes);
+						goto labelJSONError;
+					}
+					catch (...)
+					{
+						size_t bytes = srcstrm.GetCurrIstreamPos();
+						ss << __FILE__ << ':' << __LINE__ << ": Unspecified streaming error at position " << bytes;
+						//throw JSONExcept(eUnknownError, ss.str(), bytes);
+						goto labelJSONError;
+					}
+					
+					if (!stkContainers.empty())	//has parent
+					{
+						JSVar p = stkContainers.top();
+						if (eArray == p.ValueType())
+							p.push(newVal);
+						else
+						{
+							p[name] = newVal;
+							name.clear();
+						}
+						eStatus = eValueEnd;	
+					}
+					else	//should not happen
+					{
+						dst = newVal;
+						goto labelDone;	//done
+					}
+					//waiting for name
+				}
+				else
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Invalid token U+" << hex << uc << dec << " at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos();
+					goto labelJSONError;
+				}
+				break;
+			// -- value end token
+			case UC_COMMA:
+				if (buf.empty() || stkContainers.empty())
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Invalid token U+" << hex << uc << dec << " at position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos() << ", value expected";
+					goto labelJSONError;
+				}
+				else
+				{
+					JSVar val;
+					if (US_JSNULL == buf)
+						val = eNull;
+					else if (US_JSTRUE == buf)
+						val = true;
+					else if (US_JSFALSE == buf)
+						val = false;
+					else
+					{
+						try
+						{
+							val = ParseNumberLit(buf);
+						}
+						catch (JSONExcept e)
+						{
+							ss << __FILE__ << ':' << __LINE__ << ": " << e.what();
+							
+							//throw JSONExcept(e.ValueType(), ss.str(), bytes);
+							goto labelJSONError;
+						}
+						catch (...)
+						{
+							ss << __FILE__ << ':' << __LINE__ << ": " << "Unknown number parsing error";
+							//throw JSONExcept(eUnknownError, ss.str(), bytes);
+							goto labelJSONError;
+						}
+					
+						if (eUndefined == val.ValueType())
+						{
+							ss << __FILE__ << ':' << __LINE__ << ": Invalid value literal at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos() << ", value expected";
+							goto labelJSONError;
+						}
+					}
+					
+					JSVar p = stkContainers.top();
+					if (eArray == p.ValueType())
+					{
+						p.push(val);
+						eStatus = eValueStart;
+					}
+					else
+					{
+						p[name] = val;
+						name.clear();
+						eStatus = eNameStart;
+					}
+				}
+				buf.clear();
+				//eStatus = eValueStart;
+				break;
+			case UC_ARRAYEND:
+				if (!stkContainers.empty())
+				{
+					JSVar p = stkContainers.top();
+					if (eArray == p.ValueType())
+					{
+						if (!buf.empty())
+						{
+							JSVar val;
+							if (US_JSNULL == buf)
+								val = eNull;
+							else if (US_JSTRUE == buf)
+								val = true;
+							else if (US_JSFALSE == buf)
+								val = false;
+							else
+							{
+								try
+								{
+									val = ParseNumberLit(buf);
+								}
+								catch (JSONExcept e)
+								{
+									ss << __FILE__ << ':' << __LINE__ << ": " << e.what();
+									
+									//throw JSONExcept(e.ValueType(), ss.str(), bytes);
+									goto labelJSONError;
+								}
+								catch (...)
+								{
+									ss << __FILE__ << ':' << __LINE__ << ": Unknown number parsing error";
+									//throw JSONExcept(eUnknownError, ss.str(), bytes);
+									goto labelJSONError;
+								}
+							
+								if (eUndefined == val.ValueType())
+								{
+									ss << __FILE__ << ':' << __LINE__ << ": Invalid value literal at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos() << ", value expected";
+									goto labelJSONError;
+								}
+							}
+					
+							p.push(val);
+							buf.clear();
+						}
+						
+						stkContainers.pop();
+						if (stkContainers.empty())
+						{
+							dst = p;	//done
+							goto labelDone;
+						}
+						
+					}
+					else
+					{
+						ss << __FILE__ << ':' << __LINE__ << ": Array closing token detected, but object closing token is expected";
+						goto labelJSONError;
+					}
+						
+				}
+				else	//should not happen
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Extra array closing token";
+					goto labelJSONError;
+				}
+				
+				eStatus = eValueEnd;
+					
+				break;
+			case UC_OBJEND:	//'}'
+				if (!stkContainers.empty())
+				{
+					JSVar p = stkContainers.top();
+					if (eObject == p.ValueType())
+					{
+						if (!buf.empty())
+						{
+							JSVar val;
+							if (US_JSNULL == buf)
+								val = eNull;
+							else if (US_JSTRUE == buf)
+								val = true;
+							else if (US_JSFALSE == buf)
+								val = false;
+							else
+							{
+								try
+								{
+									val = ParseNumberLit(buf);
+								}
+								catch (JSONExcept e)
+								{
+									ss << __FILE__ << ':' << __LINE__ << ": " << e.what();
+									
+									//throw JSONExcept(e.ValueType(), ss.str(), bytes);
+									goto labelJSONError;
+								}
+								catch (...)
+								{
+									ss << __FILE__ << ':' << __LINE__ << ": Unknown number parsing error";
+									//throw JSONExcept(eUnknownError, ss.str(), bytes);
+									goto labelJSONError;
+								}
+							
+								if (eUndefined == val.ValueType())
+								{
+									ss << __FILE__ << ':' << __LINE__ << ": Invalid value literal at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos() << ", value expected";
+									goto labelJSONError;
+								}
+							}
+							
+							p[name] = val;
+							buf.clear();
+							name.clear();
+						}
+						
+						stkContainers.pop();
+						if (stkContainers.empty())
+						{
+							dst = p;	//done
+							goto labelDone;
+						}
+					}
+					else
+					{
+						ss << __FILE__ << ':' << __LINE__ << ": Object closing token detected, but array closing token is expected";
+						goto labelJSONError;
+					}
+						
+				}
+				else	//should not happen
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Extra object closing token";
+					goto labelJSONError;
+				}
+				eStatus = eValueEnd;
+				break;
+			case UC_OBJSTART:	//only allow when buf is empty
+				if (buf.empty())
+				{
+					JSVar newVal(eObject);
+					if (!stkContainers.empty())
+					{
+						JSVar p = stkContainers.top();
+						
+						if (eArray == p.ValueType())
+							p.push(newVal);
+						else
+						{
+							p[name] = newVal;
+							name.clear();
+						}
+					}
+					stkContainers.push(newVal);
+					eStatus = eNameStart;
+				}
+				else
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Unexpected token U+" << hex << uc << dec << " found at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos();
+					goto labelJSONError;
+				}
+				break;
+			case UC_ARRAYSTART:	//only allow when buf is empty
+				if (buf.empty())
+				{
+					JSVar newVal(eArray);
+					if (!stkContainers.empty())
+					{
+						JSVar p = stkContainers.top();
+						
+						if (eArray == p.ValueType())
+							p.push(newVal);
+						else
+						{
+							p[name] = newVal;
+							name.clear();
+						}
+					}
+					stkContainers.push(newVal);
+					//eStatus = eValue;	// -- unchanged
+				}
+				else
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Unexpected token U+" << hex << uc << dec << " found at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos();
+					goto labelJSONError;
+				}
+				break;
+			// -- continue to collecting value literal. 
+			case UC_DOT:
+			case UC_PLUS:
+			case UC_MINUS:
+				buf.push_back(uc);
+				break;
+			
+			default:
+				if ((uc >= '0' && uc <= '9') || (uc >= 'a' && uc <= 'z') || (uc >= 'A' && uc <= 'Z'))
+					buf.push_back(uc);
+				else if (uc <= 0x20L)
+				{
+					if (buf.empty())
+						continue;
+					else	//treat space as a value stop token
+					{
+						JSVar val;
+						if (US_JSNULL == buf)
+							val = eNull;
+						else if (US_JSTRUE == buf)
+							val = true;
+						else if (US_JSFALSE == buf)
+							val = false;
+						else
+						{
+							try
+							{
+								val = ParseNumberLit(buf);
+							}
+							catch (JSONExcept e)
+							{
+								ss << __FILE__ << ':' << __LINE__ << ": " << e.what();
+								
+								//throw JSONExcept(e.ValueType(), ss.str(), bytes);
+								goto labelJSONError;
+							}
+							catch (...)
+							{
+								ss << __FILE__ << ':' << __LINE__ << ": Unknown number parsing error";
+								//throw JSONExcept(eUnknownError, ss.str(), bytes);
+								goto labelJSONError;
+							}
+						
+							if (eUndefined == val.ValueType())
+							{
+								ss << __FILE__ << ':' << __LINE__ << ": Invalid value literal at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos() << ", value expected";
+								goto labelJSONError;
+							}
+						}
+						
+						if (stkContainers.empty())
+						{
+							dst = val;	//all done
+							goto labelDone;
+						}
+						else
+						{
+							JSVar p = stkContainers.top();
+							if (eArray == p.ValueType())
+								p.push(val);
+							else
+							{
+								p[name] = val;
+								name.clear();
+							}
+						}
+						buf.clear();
+						eStatus = eValueEnd;
+					}
+				}
+				else
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Invalid character U+" << hex << uc << dec << " at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos();
+					goto labelJSONError;
+				}
+				break;
+			}
+			break;
+		case eValueEnd:
+			if (uc <= 0x20L) continue;
+			switch (uc)
+			{
+			case UC_ARRAYEND:
+				if (!stkContainers.empty())
+				{
+					JSVar p = stkContainers.top();
+					if (eArray != p.ValueType())
+					{
+						ss << __FILE__ << ':' << __LINE__ << ": Array closing token detected, but object closing token is expected";
+						goto labelJSONError;
+					}
+					stkContainers.pop();
+					if (stkContainers.empty())
+					{
+						dst = p;	//done
+						goto labelDone;
+					}
+				}
+				else	//should not happen
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Extra array closing token";
+					goto labelJSONError;
+				}
+				break;
+			case UC_OBJEND:
+				if (!stkContainers.empty())
+				{
+					JSVar p = stkContainers.top();
+					if (eObject != p.ValueType())
+					{
+						ss << __FILE__ << ':' << __LINE__ << ": Object closing token detected, but array closing token is expected";
+						goto labelJSONError;
+					}
+					stkContainers.pop();
+					if (stkContainers.empty())
+					{
+						dst = p;	//done
+						goto labelDone;
+					}
+				}
+				else	//should not happen
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Extra array closing token";
+					goto labelJSONError;
+				}
+				break;
+			case UC_COMMA:
+				if (!stkContainers.empty())
+				{
+					if (eObject == stkContainers.top().ValueType())
+						eStatus = eNameStart;
+					else
+						eStatus = eValueStart;
+						
+				}
+				else	//should not happen
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Comma token after last value";
+					goto labelJSONError;
+				}
+				break;
+			default:
+				ss << __FILE__ << ':' << __LINE__ << ": Invalid character U+" << hex << uc << dec << " detected at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos();
+				goto labelJSONError;
+				
+			}
+			break;
+		case eNameStart:
+			if (uc <= 0x20) continue;
+			if (UC_QUOT == uc || UC_APOS == uc)	//valid
+			{
+				try
+				{
+					c_counter += ReadUSTRINGLit(srcstrm, name, uc);
+				}
+				catch (JSONExcept e)
+				{
+					c_counter += e.GetParam();
+					size_t bytes = srcstrm.GetCurrIstreamPos();
+					ss << __FILE__ << ':' << __LINE__ << ": " << e.what() << " at stream position " << bytes << ", " << c_counter << " unicode characters read";
+					
+					//throw JSONExcept(e.ValueType(), ss.str(), bytes);
+					goto labelJSONError;
+				}
+				catch (...)
+				{
+					size_t bytes = srcstrm.GetCurrIstreamPos();
+					ss << __FILE__ << ':' << __LINE__ << ": Unspecified streaming error at position " << bytes;
+					//throw JSONExcept(eUnknownError, ss.str(), bytes);
+					goto labelJSONError;
+				}
+				
+				if (name.empty())
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Property name cannot be empty, string expected at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos();
+					goto labelJSONError;
+				}
+				
+				eStatus = eNameEnd;
+			}
+			else if (UC_OBJEND == uc)	//empty object allowed
+			{
+				if (!stkContainers.empty())
+				{
+					JSVar p = stkContainers.top();
+					if (p.ValueType() != eObject)
+					{
+						ss << __FILE__ << ':' << __LINE__ << ": Object closing token at position " << c_counter - 1 << ", but array closing token is expected";
+						goto labelJSONError;
+					}
+					stkContainers.pop();
+					if (stkContainers.empty())
+					{
+						dst = p;
+						goto labelDone;
+					}
+						
+					eStatus = eValueEnd;
+				}
+				else
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Extra object closing token at position " << c_counter - 1;
+					goto labelJSONError;
+				}
+			}
+			else
+			{
+				ss << __FILE__ << ':' << __LINE__ << ": String literal expected for property name at position " << c_counter - 1;
+				goto labelJSONError;
+			}
+			break;
+		case eNameEnd:	//only valid token is ':'
+			if (uc <= 0x20L) continue;
+			if (UC_COLON != uc)
+			{
+				ss << __FILE__ << ':' << __LINE__ << ": Colon token expected at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos();
+				goto labelJSONError;
+			}
+			eStatus = eValueStart;
+			break;
+		}
+	}
+	
+	// -- if here, container stack must be empty.
+	if (!stkContainers.empty())
+	{
+		ss << __FILE__ << ':' << __LINE__ << ": Colon token expected at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos();
+		goto labelJSONError;
+	}
+	else	//stkContainers.empty()
+	{
+		if (!buf.empty())
+		{
+			JSVar val;
+			if (US_JSNULL == buf)
+				val = eNull;
+			else if (US_JSTRUE == buf)
+				val = true;
+			else if (US_JSFALSE == buf)
+				val = false;
+			else
+			{
+				try
+				{
+					val = ParseNumberLit(buf);
+				}
+				catch (JSONExcept e)
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": " << e.what();
+					
+					//throw JSONExcept(e.ValueType(), ss.str(), bytes);
+					goto labelJSONError;
+				}
+				catch (...)
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Unknown number parsing error";
+					//throw JSONExcept(eUnknownError, ss.str(), bytes);
+					goto labelJSONError;
+				}
+			
+				if (eUndefined == val.ValueType())
+				{
+					ss << __FILE__ << ':' << __LINE__ << ": Invalid value literal at unicode position " << c_counter - 1 << ", stream position " << srcstrm.GetCurrIstreamPos() << ", value expected";
+					goto labelJSONError;
+				}
+			}
+			
+			dst = val;
+			//return val;
+		}
+	}
+	
+labelDone:	
+	return is;
+	
+	//throw JSONExcept(eStreamBroken, "Unexpected stream end");
+	
+labelJSONError:
+	throw JSONExcept(eJSONDataError, ss.str(), c_counter);
+	
+	
+}
+
+ostream & LJSON::operator << (ostream &os, const LJSON::JSVar &src)
+{
+	CUTFOstream tokenos(os, E_UTF8), dataos(os, E_UTF8, &MAP_ENTITIES);
+	src.Print(tokenos, dataos);
+	return os;
+}
+
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ljson.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ljson.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ljson.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ljson.hpp	2018-03-13 14:39:35.475170000 -0400
@@ -0,0 +1,207 @@
+#if !defined(__LJSON__)
+#define __LJSON__
+
+
+#include "ustring.hpp"
+#include "datanode.hpp"
+#include <iostream>
+#include <vector>
+#include <map>
+#include <string>
+#include <cstring>
+#include <exception>
+
+
+namespace LJSON
+{
+	enum EDataType
+	{
+		eUndefined = 0,	//when data is not set (empty reference)
+		eNull = eUndefined + 1,
+		eBoolean = eNull + 1,	//true, false
+		eInteger = eBoolean + 1,	//long long
+		eReal = eInteger + 1,	//long double
+		eString = eReal + 1,	//USTRING
+		eArray = eString + 1,
+		eObject = eArray + 1
+	};
+	
+	static const int TOTALTYPES = eObject + 1;
+	
+	enum EJSONError
+	{
+		eNoError = 0,
+		eValueIsUndefined = eNoError + 1,
+		eUnsupportedOperation = eValueIsUndefined + 1,	//wrong value type
+		eStreamBroken = eUnsupportedOperation + 1,	//unexpected stream finish
+		eJSONDataError = eStreamBroken + 1,
+		eOutOfArrayBoundary = eJSONDataError + 1,
+		ePropNameNotFound = eOutOfArrayBoundary + 1,
+		eUnknownError = ePropNameNotFound + 1,
+		eEndOfErrors = eUnknownError + 1
+	};
+	
+	extern const char * errMsgs[];
+
+	class JSONExcept: public std::exception
+	{
+	public:
+		JSONExcept(EJSONError code, const std::string &msg, unsigned long long param = 0) throw(): std::exception(), m_msg(msg), m_code(code), m_param(param){};
+		~JSONExcept(void) throw(){};
+		virtual const char * what() const throw() {return m_msg.c_str();}
+		EJSONError type(void) const throw() {return m_code;}
+		unsigned long long GetParam(void) const throw() {return m_param;} 
+	private:
+		std::string m_msg;
+		EJSONError m_code;
+		unsigned long long m_param;
+	};
+	class JSVar;
+	// -- C++ type for JS values
+	typedef bool JSBoolValue;
+	typedef long long int JSIntValue;
+	typedef long double JSRealValue;
+	typedef USTRING JSStringValue;
+	typedef std::vector<JSVar> JSArrayValue;
+	typedef std::map<USTRING, JSVar> JSObjectValue;
+		
+	class JSValue: public CDocNodeBase
+	{
+		friend class JSVar;
+	public:
+
+		virtual ~JSValue(void) {};
+		virtual EDataType ValueType(void) const = 0;
+		
+		
+	protected:
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const = 0;
+		virtual void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type = eUndefined) const = 0;
+	};
+
+	
+	class JSVar: public CDocNodeRef<JSValue>
+	{
+		friend std::istream & LJSON::operator >> (std::istream &is, LJSON::JSVar &src);
+		
+		// -- default utf8 stream out
+		friend std::ostream & LJSON::operator << (std::ostream &os, const LJSON::JSVar &dst);
+	public:
+		typedef CDocNodeRef<JSValue> TParent;
+
+		JSVar(EDataType t = eUndefined);
+		JSVar(const JSVar &src);
+		JSVar(JSBoolValue val);
+		
+		JSVar(const JSIntValue & val);
+		JSVar(long val);
+		JSVar(unsigned long val);
+		JSVar(int val);
+		JSVar(unsigned int val);
+		JSVar(short val);
+		JSVar(unsigned short val);
+		
+		JSVar(const JSRealValue & val);
+		JSVar(double val);
+		
+		
+		JSVar(const JSStringValue & val);
+		JSVar(const std::string & val);
+		JSVar(const char * utf8);
+		
+		JSVar(const JSArrayValue & val);
+		JSVar(const JSObjectValue & val);
+		
+//		const JSVar & operator = (const JSVar &src);
+		
+		JSBoolValue GetBoolValue(void) const;
+		const JSIntValue & GetIntValue(void) const;
+		const JSRealValue & GetRealValue(void) const;
+		const JSStringValue & GetStringValue(void) const;
+		const JSArrayValue & GetArrayValue(void) const;
+		const JSObjectValue & GetObjectValue(void) const;
+		
+		JSArrayValue & SetArrayValue(void);
+		JSObjectValue & SetObjectValue(void);
+			
+		void Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		void Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl, EDataType p_type = eUndefined) const;
+		
+		// -- for data accessing
+		EDataType ValueType(void) const;
+		size_t length(void) const;	//get size of array or object. Other types will throw
+		// -- array only, otherwise throw
+		
+		template <typename T>
+		const JSVar & operator [] (T) const;
+		
+		template <typename T>
+		JSVar & operator [] (T);
+		
+		
+		const JSVar & operator [] (const USTRING &) const;
+		const JSVar & operator [] (const std::string &) const;
+		const JSVar & operator [] (const char *) const;
+		const JSVar & operator [] (char *) const;
+	
+	
+		JSVar & operator [] (const USTRING &);
+		JSVar & operator [] (const std::string &);
+		JSVar & operator [] (const char *);
+		JSVar & operator [] (char *);
+		
+		//const JSVar & operator [] (size_t i) const;
+		//JSVar & operator [] (size_t i);
+		
+		JSVar & push(const JSVar &src);
+		// -- object only.
+		
+		
+		//const JSVar & operator [] (const USTRING & key) const;
+		//JSVar & operator [] (const USTRING & key);
+		
+	private:
+		//JSBoolValue & SetBoolValue(void);
+		JSIntValue & SetIntValue(void);
+		JSRealValue & SetRealValue(void);
+		JSStringValue & SetStringValue(void);
+		//JSArrayValue & SetArrayValue(void);
+		//JSObjectValue & SetObjectValue(void);
+			
+		//void SetBoolValue(JSBoolValue val);
+		void SetIntValue(const JSIntValue & val);
+		void SetRealValue(const JSRealValue & val);
+		void SetStringValue(const JSStringValue & val);
+		void SetArrayValue(const JSArrayValue & val);
+		void SetObjectValue(const JSObjectValue & val);
+		
+		//template <typename T>
+		//JSVar & operator = (const T&);
+	};
+	
+	std::istream & operator >> (std::istream &is, LJSON::JSVar &dst);
+	std::ostream & operator << (std::ostream &os, const LJSON::JSVar &dst);
+	class JSONDoc
+	{
+	public:
+		// -- BasicUtils/ustring.hpp
+		//static const int E_UTF8 = 8;
+		//static const int E_UTF16BE = 16;
+		//static const int E_UTF16LE = -16;
+		JSONDoc(JSVar root, const USTRING &jsonp = k_ustrEmptyUSTRING, int enc = E_UTF8);
+		void Print(std::ostream &os) const;
+		void Print(std::ostream &os, int lvl) const;
+		
+	private:
+		JSVar m_root;
+		USTRING m_jsonp;
+		int m_enc;
+	};
+	
+	extern JSVar null;
+	
+};
+
+
+#endif
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/lxml.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/lxml.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/lxml.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/lxml.cpp	2018-03-13 14:39:35.288206000 -0400
@@ -0,0 +1,1101 @@
+#include "lxml.hpp"
+
+using namespace std;
+
+namespace LXML
+{
+	// -- tokens in USTRING
+	const UCHAR UC_OPENTAG('<');
+	const UCHAR UC_TAGEND('>');
+	const USTRING US_CLOSETAG("</");
+	const USTRING US_TAGENDSH(" />");	//short hand tag end
+	// -- doc
+	const USTRING US_PRLSTART("<?xml");
+	const USTRING US_PRLEND("?>");
+	const USTRING US_XMLNS("xmlns=");
+	const USTRING US_XMLNSPRF("xmlns:");
+	const USTRING US_VERSION("version=");
+	const USTRING US_ENCODE("encoding=");
+	const USTRING US_STANDALONE("standalone=");
+	const USTRING US_YES("yes");
+	const USTRING US_NO("no");
+	const USTRING US_STYLESHEET("-stylesheet");
+	const USTRING US_DEFVER10("1.0");
+	const USTRING US_ENCUTF8("utf-8");
+	const USTRING US_ENCUTF16("utf-16");
+	const USTRING US_CDATAOPEN("<![CDATA[");
+	const USTRING US_CDATACLOSE("]]>");
+	const USTRING US_COMMENTOPEN("<!--");
+	const USTRING US_COMMENTCLOSE("-->");
+	const USTRING US_DTDOPEN("<!DOCTYPE ");
+	const USTRING US_DTDELEM("<!ELEMENT ");
+	const USTRING US_DTDATTR("<!ATTLIST ");
+	const USTRING US_DTDENTITY("<!ENTITY ");
+	const USTRING US_DTDCONTENTEMPTY("#EMPTY");
+	const USTRING US_DTDCONTENTANY("#ANY");
+	const USTRING US_DTDVALFIXED("#FIXED");
+	const USTRING US_DTDVALIMPLIED("#IMPLIED");
+	const USTRING US_DTDVALREQUIRED("#REQUIRED");
+	
+	const USTRING US_DTDPRIVATE("SYSTEM");
+	const USTRING US_DTDPUBLIC("PUBLIC");
+	const USTRING US_DTDTYPE("DTD");
+	const USTRING US_DTDLANG("EN");
+	
+	
+	//const size_t TOTAL_ENTITIES = 5;
+	//POD_STATICMAP PREDEF_ENTITIES[TOTAL_ENTITIES] = 
+	//{
+	//	{UC_OPENTAG, USTRING("&lt;")},
+	//	{UC_TAGEND, USTRING("&gt;")},
+	//	{UC_AMPS, USTRING("&amp;")},
+	//	{UC_QUOT, USTRING("&quot;")},
+	//	{UC_APOS, USTRING("&apos;")}
+	//};
+	// -- predefined escape sequences
+	//TEscapeSeqs MAP_ENTITIES;
+	
+	TEscapeSeqs MAP_ENTITIES =
+	{
+		{UC_OPENTAG, {UC_AMPS, UCHAR('l'), UCHAR('t'), UC_SEMICOLON}},
+		{UC_TAGEND, {UC_AMPS, UCHAR('g'), UCHAR('t'), UC_SEMICOLON}},
+		{UC_AMPS, {UC_AMPS, UCHAR('a'), UCHAR('m'), UCHAR('p'), UC_SEMICOLON}},
+		{UC_QUOT, {UC_AMPS, UCHAR('q'), UCHAR('u'), UCHAR('o'), UCHAR('t'), UC_SEMICOLON}},
+		{UC_APOS, {UC_AMPS, UCHAR('a'), UCHAR('p'), UCHAR('o'), UCHAR('s'), UC_SEMICOLON}}
+	};
+};
+
+using namespace LXML;
+
+//struct TXMLINIT
+//{
+//	TXMLINIT(void);
+//} x_ini_obj;
+//
+//TXMLINIT::TXMLINIT(void)
+//{
+//	CreateEscMap(PREDEF_ENTITIES, TOTAL_ENTITIES, MAP_ENTITIES);
+//}
+
+void LXML::CProlog::Print(ostream &os) const
+{
+	CUTFOstream tok_stream(os, E_UTF8), data_stream(os, E_UTF8, &MAP_ENTITIES);
+	x_Print(tok_stream, data_stream);
+}
+
+void LXML::CProlog::Print(ostream &os, int lvl) const
+{
+	CUTFOstream tok_stream(os, E_UTF8), data_stream(os, E_UTF8, &MAP_ENTITIES);
+	x_Print(tok_stream, data_stream, lvl);
+}
+
+void LXML::CProlog::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+	if (!attribs.empty())
+	{
+		tokenos << US_PRLSTART;
+		if (name.empty())
+			tokenos << US_STYLESHEET;
+		else
+		{
+			UCHAR UC_DASH('-');
+			if (UC_DASH != name[0])
+				tokenos << UC_DASH;
+			tokenos << name;
+		}
+		
+		//tokenos << UC_WHITESP;
+		
+		for (map<USTRING, USTRING> :: const_iterator iter = attribs.begin(), iterEnd = attribs.end(); iterEnd != iter; ++iter)
+		{
+			tokenos << UC_WHITESP;
+			dataos << iter->first;
+			tokenos << UC_EQUAL;
+			tokenos << UC_QUOT;
+			dataos << iter->second;
+			tokenos << UC_QUOT;
+		}
+		
+		tokenos << US_PRLEND;
+	}
+	else if (!name.empty())	//no attributes, treat as comment, name as the comment content
+	{
+		tokenos << US_COMMENTOPEN;
+		dataos << name;
+		tokenos << US_COMMENTCLOSE;
+	}
+}
+
+void LXML::CProlog::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl) const
+{
+	if (lvl > 0)
+	{
+		USTRING indts(k_ustrEmptyUSTRING);
+		indts.insert(indts.end(), lvl, UC_TAB);
+		tokenos << indts;
+	}
+	x_Print(tokenos, dataos);
+	tokenos << UC_NL;
+}
+
+void LXML::CDTDDef::Print(ostream &os) const
+{
+	CUTFOstream tok_stream(os, E_UTF8), data_stream(os, E_UTF8, &MAP_ENTITIES);
+	x_Print(tok_stream, data_stream);
+}
+
+void LXML::CDTDDef::Print(ostream &os, int lvl) const
+{
+	CUTFOstream tok_stream(os, E_UTF8), data_stream(os, E_UTF8, &MAP_ENTITIES);
+	x_Print(tok_stream, data_stream, lvl);
+}
+void LXML::CDTDDef::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+	if (!defname.empty())
+	{
+		switch (deftype)
+		{
+		case eElement:
+			tokenos << US_DTDELEM;
+			dataos << defname;
+			tokenos << UC_WHITESP;
+			if (empty_fixed_external)
+				tokenos << US_DTDCONTENTEMPTY;
+			else if (!value.empty())
+				tokenos << UCHAR('(') << value << UCHAR(')');
+			else	//not empty, no specific values
+				tokenos << US_DTDCONTENTANY;
+			tokenos << UC_TAGEND;
+			break;
+		case eAttribute:
+			if (!elem.empty() && !valtype.empty())
+			{
+				tokenos << US_DTDATTR;
+				dataos << defname;
+				tokenos << UC_WHITESP;
+				dataos << elem;
+				tokenos << UC_WHITESP;
+				dataos << valtype;
+				tokenos << UC_WHITESP;
+				
+				if (!value.empty())
+				{
+					if (empty_fixed_external)
+						tokenos << US_DTDVALFIXED << UC_WHITESP;
+					tokenos << UC_QUOT;
+					dataos << value;
+					tokenos << UC_QUOT;
+					if (required_private)
+						tokenos << UC_WHITESP << US_DTDVALREQUIRED;
+				}
+				else if (required_private)	//no value, ignore m_fixed
+					tokenos << US_DTDVALREQUIRED;
+				else
+					tokenos << US_DTDVALIMPLIED;
+				tokenos << UC_TAGEND;
+			}
+			break;
+		case eEntity:
+			if (!value.empty())
+			{
+				tokenos << US_DTDENTITY;
+				dataos << defname;
+				tokenos << UC_WHITESP;
+				
+				if (empty_fixed_external)	//m_value is the string
+				{	
+					if (required_private)
+						tokenos << US_DTDPRIVATE;
+					else
+						tokenos << US_DTDPUBLIC;
+						
+					tokenos << UC_WHITESP;
+				}
+				tokenos << UC_QUOT;
+				dataos << value;
+				tokenos << UC_QUOT;
+				
+				tokenos << UC_TAGEND;
+			}
+			break;
+		}
+	}
+	else if (!value.empty())	//no name, treat as comment, value as content
+	{
+		tokenos << US_COMMENTOPEN;
+		dataos << value;
+		tokenos << US_COMMENTCLOSE;
+	}
+		
+}
+
+void LXML::CDTDDef::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl) const
+{
+	if (lvl > 0)
+	{
+		USTRING indts(k_ustrEmptyUSTRING);
+		indts.insert(indts.end(), lvl, UC_TAB);
+		tokenos << indts;
+	}
+	x_Print(tokenos, dataos);
+	tokenos << UC_NL;
+}
+	
+	
+
+
+
+LXML::CGXMLDoc::CGXMLDoc(CGXMLRef root, int enc):
+	XMLVer(LXML::US_DEFVER10), IsISOStd(false), IsApproved(false), Standalone(false),
+	DTDOwner(k_ustrEmptyUSTRING), DTDType(US_DTDTYPE), DTDDescr(k_ustrEmptyUSTRING), DTDLangId(US_DTDLANG), DTDVer(k_ustrEmptyUSTRING), DTDURI(k_ustrEmptyUSTRING),
+	m_root(root), m_enc(E_UTF8), m_prologs(), m_dtddefs()
+{
+	if (E_UTF16LE == enc || E_UTF16BE == enc)
+		m_enc = enc;
+}
+
+void LXML::CGXMLDoc::AddProlog(const LXML::CProlog & prlg)
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": lref: prlg.empty() = " << prlg.empty() << endl;
+#endif
+// ***********************************************************/
+
+	m_prologs.push_back(prlg);
+}
+
+LXML::CProlog &  LXML::CGXMLDoc::AddProlog(void)
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": rref: prlg.empty() = " << prlg.empty() << endl;
+#endif
+// ***********************************************************/
+
+	list<CProlog> ::iterator iter = m_prologs.insert(m_prologs.end(), CProlog());
+	return *iter;
+}
+
+void LXML::CGXMLDoc::AddDTDDef(const CDTDDef & def)
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": lref: prlg.empty() = " << prlg.empty() << endl;
+#endif
+// ***********************************************************/
+
+
+	m_dtddefs.push_back(def);
+		
+}
+
+LXML::CDTDDef & LXML::CGXMLDoc::AddDTDDef(void)
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": rref: prlg.empty() = " << prlg.empty() << endl;
+#endif
+// ***********************************************************/
+
+	list<CDTDDef> ::iterator iter = m_dtddefs.insert(m_dtddefs.end(), CDTDDef());
+	return *iter;
+}
+
+
+
+void LXML::CGXMLDoc::Print(ostream &os) const
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": unformatted print" << endl;
+#endif
+// ***********************************************************/
+
+	// -- only print if m_root is not null
+	if (!m_root.IsNull())
+	{
+		USTRING _dblslash("//");
+		CUTFOstream tok_stream(os, m_enc), data_stream(os, m_enc, &MAP_ENTITIES);
+		
+		const USTRING *pEnc = &US_ENCUTF8;
+		if (E_UTF8 != m_enc)
+		{
+			tok_stream.PrintBOM();
+			pEnc = &US_ENCUTF16;
+		}
+		tok_stream << US_PRLSTART << UC_WHITESP << US_VERSION << UC_QUOT << XMLVer;
+		
+		tok_stream << UC_QUOT << UC_WHITESP << US_ENCODE << UC_QUOT << *pEnc << UC_QUOT << UC_WHITESP << US_STANDALONE << UC_QUOT;
+		
+		
+		if (Standalone) tok_stream << US_YES;
+		else tok_stream << US_NO;
+		
+			
+		tok_stream << UC_QUOT << US_PRLEND;	//end of first line
+		
+		// -- now putout dtd
+		const USTRING & root_tag = m_root->GetTag();
+		
+		if (!root_tag.empty())
+		{
+			if (!DTDURI.empty())	//external
+			{
+				tok_stream << US_DTDOPEN << root_tag;
+				
+				if (DTDOwner.empty() || DTDDescr.empty())	//as private
+				{
+					tok_stream << UC_WHITESP << US_DTDPRIVATE;
+				}
+				else
+				{
+					tok_stream << UC_WHITESP << US_DTDPUBLIC << UC_WHITESP << UC_QUOT;
+					if (IsISOStd)
+						tok_stream << USTRING("ISO");
+					else if (IsApproved)
+						tok_stream << UCHAR('+');
+					else
+						tok_stream << UCHAR('-');
+					
+					tok_stream << _dblslash << DTDOwner << _dblslash << DTDType << UC_WHITESP << DTDDescr;
+					
+					if (!DTDLangId.empty())
+						tok_stream << _dblslash << DTDLangId;
+					if (!DTDVer.empty())
+						tok_stream << _dblslash << DTDVer;
+						
+					tok_stream << UC_QUOT;
+				}
+				
+				tok_stream << UC_WHITESP << UC_QUOT << DTDURI << UC_QUOT;
+				
+				
+				if (m_dtddefs.empty())
+				{
+					tok_stream << UC_TAGEND;
+					goto labelDTDDone;
+				}
+			}
+			else if (!m_dtddefs.empty())
+				tok_stream << US_DTDOPEN << root_tag << UC_WHITESP;
+			else goto labelDTDDone;
+			
+			
+			tok_stream << UC_WHITESP << UCHAR('[') << UC_WHITESP;
+			
+			for (list<LXML::CDTDDef> :: const_iterator iter = m_dtddefs.begin(), iterEnd = m_dtddefs.end(); iterEnd != iter; ++iter)
+			{
+				iter->x_Print(tok_stream, data_stream);
+				tok_stream << UC_WHITESP;
+			}
+			
+			tok_stream << UCHAR(']') << UC_TAGEND;
+		}
+	labelDTDDone:
+//		tok_stream << UC_DTD;
+		
+		// -- stylesheet
+		//<?xml-stylesheet type="text/css" href="cd_catalog.css"?>
+		for (list<LXML::CProlog> :: const_iterator iter = m_prologs.begin(); iter != m_prologs.end(); ++iter)
+		{
+			tok_stream << UC_WHITESP;
+			iter->x_Print(tok_stream, data_stream);
+		}
+			
+		m_root->x_Print(tok_stream, data_stream);
+	}
+}
+
+void LXML::CGXMLDoc::Print(ostream &os, int lvl) const
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Formatted print" << endl;
+#endif
+// ***********************************************************/
+
+	// -- only print if m_root is not null
+	if (!m_root.IsNull())
+	{
+		USTRING idnts(k_ustrEmptyUSTRING);
+		if (lvl > 0) idnts.insert(idnts.end(), lvl, UC_TAB);
+		USTRING _dblslash("//");
+
+		CUTFOstream tok_stream(os, m_enc), data_stream(os, m_enc, &MAP_ENTITIES);
+		
+		const USTRING *pEnc = &US_ENCUTF8;
+		if (E_UTF8 != m_enc)
+		{
+			tok_stream.PrintBOM();
+			pEnc = &US_ENCUTF16;
+		}
+		tok_stream << idnts << US_PRLSTART << UC_WHITESP << US_VERSION << UC_QUOT << XMLVer;
+		
+		tok_stream << UC_QUOT << UC_WHITESP << US_ENCODE << UC_QUOT << *pEnc << UC_QUOT << UC_WHITESP << US_STANDALONE << UC_QUOT;
+		if (Standalone) tok_stream << US_YES;
+		else tok_stream << US_NO;
+			
+		tok_stream << UC_QUOT << US_PRLEND << UC_NL;	//end of first line
+		
+		// -- now putout dtd
+		const USTRING & root_tag = m_root->GetTag();
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": root_tag = " << root_tag << endl;
+cerr << __FILE__ << ':' << __LINE__ << ": m_dtddefs.size() = " << m_dtddefs.size() << endl;
+#endif
+// ***********************************************************/
+		
+		if (!root_tag.empty())
+		{
+
+			if (!DTDURI.empty())	//external
+			{
+				tok_stream << idnts << US_DTDOPEN << root_tag;
+				
+				if (DTDOwner.empty() || DTDDescr.empty())	//as private
+				{
+					tok_stream << UC_WHITESP << US_DTDPRIVATE;
+				}
+				else
+				{
+					tok_stream << UC_WHITESP << US_DTDPUBLIC << UC_WHITESP << UC_QUOT;
+					if (IsISOStd)
+						tok_stream << USTRING("ISO");
+					else if (IsApproved)
+						tok_stream << UCHAR('+');
+					else
+						tok_stream << UCHAR('-');
+					
+					tok_stream << _dblslash << DTDOwner << _dblslash << DTDType << UC_WHITESP << DTDDescr;
+					
+					if (!DTDLangId.empty())
+						tok_stream << _dblslash << DTDLangId;
+					if (!DTDVer.empty())
+						tok_stream << _dblslash << DTDVer;
+						
+					tok_stream << UC_QUOT;
+				}
+				
+				tok_stream << UC_WHITESP << UC_QUOT << DTDURI << UC_QUOT;
+				
+				
+				if (m_dtddefs.empty())
+				{
+					tok_stream << UC_TAGEND << UC_NL;
+					goto labelDTDDone;
+				}
+			}
+			else if (!m_dtddefs.empty())
+				tok_stream << US_DTDOPEN << root_tag << UC_WHITESP;
+			else goto labelDTDDone;
+			
+			
+			tok_stream << UC_WHITESP << UCHAR('[') << UC_NL;
+			
+			for (list<LXML::CDTDDef> :: const_iterator iter = m_dtddefs.begin(), iterEnd = m_dtddefs.end(); iterEnd != iter; ++iter)
+			{
+				iter->x_Print(tok_stream, data_stream, lvl + 1);
+			}
+			
+			tok_stream << idnts << UCHAR(']') << UC_TAGEND << UC_NL;
+		}
+	labelDTDDone:
+//		tok_stream << UC_DTD;
+		
+		// -- stylesheet
+		//<?xml-stylesheet type="text/css" href="cd_catalog.css"?>
+		for (list<LXML::CProlog> :: const_iterator iter = m_prologs.begin(); iter != m_prologs.end(); ++iter)
+			iter->x_Print(tok_stream, data_stream, lvl);
+			
+		m_root->x_Print(tok_stream, data_stream, lvl);
+	}
+	
+}
+
+//LXML::CGXMLNode::CGXMLNode(const USTRING &tag, const USTRING &data):
+//	m_tagname(tag), m_defns(k_ustrEmptyUSTRING), m_text(data), m_cdata(k_ustrEmptyUSTRING), m_attribs(), m_nspfx(), m_children()
+//{
+//	//if (tag.empty())	//treat as comment
+//	//{
+//	//	m_tagname.clear();
+//	//	m_cdata = data;
+//	//	m_text.clear();
+//	//	return;
+//	//}
+//		//throw CException(CDiagCompileInfo(__FILE__, __LINE__, "CGXMLNode::CGXMLNode"), nullptr, CException::eUnknown, "Tag name cannot be empty");
+//}
+//
+//LXML::CGXMLNode::CGXMLNode(USTRING &&tag, const USTRING &data):
+//	m_tagname(move(tag)), m_defns(k_ustrEmptyUSTRING), m_text(data), m_cdata(k_ustrEmptyUSTRING), m_attribs(), m_nspfx(), m_children()
+//{}
+//	
+//LXML::CGXMLNode::CGXMLNode(USTRING &&tag, USTRING &&data):
+//	m_tagname(move(tag)), m_defns(k_ustrEmptyUSTRING), m_text(move(data)), m_cdata(k_ustrEmptyUSTRING), m_attribs(), m_nspfx(), m_children()
+//{}
+//
+//LXML::CGXMLNode::CGXMLNode(const USTRING &tag, USTRING &&data):
+//	m_tagname(tag), m_defns(k_ustrEmptyUSTRING), m_text(move(data)), m_cdata(k_ustrEmptyUSTRING), m_attribs(), m_nspfx(), m_children()
+//{}
+
+
+
+
+void LXML::CGXMLNode::SetText(const USTRING & txt)
+{
+	m_text = txt;
+}
+
+void LXML::CGXMLNode::SetText(USTRING && txt)
+{
+	m_text = move(txt);
+}
+
+void LXML::CGXMLNode::SetCData(const USTRING & cdata)
+{
+	m_cdata = cdata;
+}
+
+void LXML::CGXMLNode::SetCData(USTRING && cdata)
+{
+	m_cdata = move(cdata);
+}
+
+void LXML::CGXMLNode::SetDefaultNS(const USTRING & defns)
+{
+	m_defns = defns;
+}
+
+void LXML::CGXMLNode::SetDefaultNS(USTRING && defns)
+{
+	m_defns = move(defns);
+}
+
+const USTRING & LXML::CGXMLNode::GetAttrib(const USTRING &attr_name) const
+{
+	if (!attr_name.empty())
+	{
+		TProps::const_iterator iter = m_attribs.find(attr_name);
+		if (m_attribs.end() != iter)
+			return iter->second;
+	}
+	return k_ustrEmptyUSTRING;
+}
+
+
+void LXML::CGXMLNode::SetAttrib(const USTRING &attr_name, const USTRING &attr_value)
+{
+	if (attr_name.empty())
+		throw CSimpleException(__FILE__, __LINE__, "Attribute name is empty");
+	m_attribs[attr_name] = attr_value;
+}
+
+void LXML::CGXMLNode::SetAttrib(const USTRING &attr_name, USTRING &&attr_value)
+{
+	if (attr_name.empty())
+		throw CSimpleException(__FILE__, __LINE__, "Attribute name is empty");
+	m_attribs[attr_name] = move(attr_value);
+}
+
+USTRING & LXML::CGXMLNode::SetAttrib(const USTRING &attr_name)
+{
+	if (attr_name.empty())
+		throw CSimpleException(__FILE__, __LINE__, "Attribute name is empty");
+	return m_attribs[attr_name];
+}
+
+void LXML::CGXMLNode::RemoveAttrib(const USTRING &attr_name)
+{
+	if (!attr_name.empty())
+	{
+		TProps::iterator iter = m_attribs.find(attr_name);
+		if (m_attribs.end() != iter)
+			m_attribs.erase(iter);
+	}
+}
+
+void LXML::CGXMLNode::DefNSPfx(const USTRING &pfx, const USTRING &ns)
+{
+	if (!pfx.empty() && !ns.empty())
+		m_nspfx[pfx] = ns;
+}
+
+void LXML::CGXMLNode::DefNSPfx(const USTRING &pfx, USTRING &&ns)
+{
+	if (!pfx.empty() && !ns.empty())
+		m_nspfx[pfx] = move(ns);
+}
+
+void LXML::CGXMLNode::UndefNSPfx(const USTRING &pfx)
+{
+	if (!pfx.empty())
+	{
+		TProps::iterator iter = m_nspfx.find(pfx);
+		if (m_nspfx.end() != iter)
+			m_nspfx.erase(iter);
+	}
+}
+
+const USTRING & LXML::CGXMLNode::GetNS(const USTRING &pfx) const
+{
+	if (!pfx.empty())
+	{
+		TProps::const_iterator iter = m_nspfx.find(pfx);
+		if (m_nspfx.end() != iter)
+			return iter->second;
+	}
+	return k_ustrEmptyUSTRING;
+}
+
+bool LXML::CGXMLNode::AppendChild(CGXMLRef ch)
+{
+	for (TChildren::const_iterator iter = m_children.begin(), iterEnd = m_children.end(); iterEnd != iter; ++iter)
+	{
+		if ((*iter) == ch)
+			return false;
+	}
+	m_children.push_back(ch);
+	return true;
+}
+
+CGXMLRef LXML::CGXMLNode::AppendChild(const USTRING &tag, const USTRING &data)
+{
+	CGXMLRef ch(new CGXMLNode(tag, data));
+	m_children.push_back(ch);
+	return ch;
+}
+
+CGXMLRef LXML::CGXMLNode::AppendComment(const USTRING &comment)
+{
+	CGXMLRef ch(new CGXMLNode(k_ustrEmptyUSTRING, comment));
+	m_children.push_back(ch);
+	return ch;
+}
+
+bool LXML::CGXMLNode::RemoveChild(CGXMLRef ch)
+{
+	for (TChildren::iterator iter = m_children.begin(), iterEnd = m_children.end(); iterEnd != iter; ++iter)
+	{
+		if ((*iter) == ch)
+		{
+			m_children.erase(iter);
+			return false;
+		}
+	}
+	return false;
+}
+
+
+void LXML::CGXMLNode::RemoveChildren(const USTRING &tag)
+{
+	TChildren::iterator iter = m_children.begin(), iterEnd = m_children.end();
+	
+	while (iterEnd != iter)
+	{
+		if (tag == (*iter)->GetTag())
+		{
+			TChildren::iterator iterErase = iter;
+			++iter;
+			m_children.erase(iterErase);
+		}
+		else
+			++iter;
+	}
+}
+
+vector<CGXMLRef> LXML::CGXMLNode::FindChildren(const USTRING &tag) const
+{
+	vector<CGXMLRef> result;
+	for (TChildren::const_iterator iter = m_children.begin(), iterEnd = m_children.end(); iterEnd != iter; ++iter)
+		if (tag == (*iter)->GetTag())
+			result.push_back(*iter);
+	return result;
+}
+
+void LXML::CGXMLNode::ClearChildren(void)
+{
+	m_children.clear();
+}
+
+void LXML::CGXMLNode::Print(ostream &os) const
+{
+	CUTFOstream token_os(os, E_UTF8), data_os(os, E_UTF8, &MAP_ENTITIES);
+	x_Print(token_os, data_os);
+}
+
+void LXML::CGXMLNode::Print(ostream &os, int lvl) const
+{
+	CUTFOstream token_os(os, E_UTF8), data_os(os, E_UTF8, &MAP_ENTITIES);
+	x_Print(token_os, data_os, lvl);
+}
+
+
+void LXML::CGXMLNode::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const
+{
+
+	int content = 0;
+	USTRING cdata(k_ustrEmptyUSTRING);
+	if (m_tagname.empty())	//treat as a comment node, only print TEXT
+	{
+		if (!m_text.empty())
+		{
+			tokenos << US_COMMENTOPEN;
+			tokenos << m_text;
+			content = 1;
+		}
+		
+		//x_AssemblePCData(cdata);
+		//
+		//if (!cdata.empty())
+		//{
+		//	if (0 == content)
+		//	{
+		//		tokenos << US_COMMENTOPEN;
+		//		content = 1;
+		//	}
+		//	tokenos << cdata;
+		//}
+		//
+		//if (content > 0)
+		//	tokenos << US_COMMENTCLOSE;
+		
+		
+		return;	
+		
+	}
+	
+	
+	tokenos << UC_OPENTAG;
+	dataos << m_tagname;
+	
+	if (!m_defns.empty())
+	{
+		tokenos << UC_WHITESP << US_XMLNS << UC_QUOT;
+		dataos << m_defns;
+		tokenos << UC_QUOT;
+	}
+	
+	if (!m_nspfx.empty())
+	{
+		for (TProps::const_iterator iter = m_nspfx.begin(), iterEnd = m_nspfx.end(); iterEnd != iter; ++iter)
+		{
+			tokenos << UC_WHITESP << US_XMLNSPRF;
+			dataos << iter->first;
+			tokenos << UC_EQUAL << UC_QUOT;
+			dataos << iter->second;
+			tokenos << UC_QUOT;
+		}
+	}
+	
+	if (!m_attribs.empty())
+	{
+		for (TProps::const_iterator iter = m_attribs.begin(), iterEnd = m_attribs.end(); iterEnd != iter; ++iter)
+		{
+			tokenos << UC_WHITESP;
+			dataos << iter->first;
+			tokenos << UC_EQUAL << UC_QUOT;
+			dataos << iter->second;
+			tokenos << UC_QUOT;
+		}
+	}
+	
+	// -- get extra properties from derived classes
+	// -- typically style=
+	TProps exprops;
+	x_AssembleExtraAttribs(exprops);
+	
+	if (!exprops.empty())
+	{
+		for (TProps::const_iterator iter = exprops.begin(), iterEnd = exprops.end(); iterEnd != iter; ++iter)
+		{
+			tokenos << UC_WHITESP;
+			dataos << iter->first;
+			tokenos << UC_EQUAL << UC_QUOT;
+			dataos << iter->second;
+			tokenos << UC_QUOT;
+		}
+	}
+	
+	
+	
+	if (!m_children.empty())
+	{
+		tokenos << UC_TAGEND;	//end tag
+		content = 2;
+		for (TChildren::const_iterator iter = m_children.begin(), iterEnd = m_children.end(); iterEnd != iter; ++iter)
+			(*iter)->x_Print(tokenos, dataos);
+	}
+	
+	if (!m_cdata.empty())
+	{
+		if (0 == content)	//no children, need end of tag
+		{
+			tokenos << UC_TAGEND;	//end tag
+			//content = 2;
+		}
+		// -- CDATA should not escape
+		tokenos << US_CDATAOPEN << m_cdata;
+		content = 3;	//as cdata section
+	}
+	
+	// -- CDATA
+	
+	x_AssembleCData(cdata);
+	
+	if (!cdata.empty())
+	{
+		switch (content)
+		{
+		case 0:	//no children, no m_cdata
+			tokenos << UC_TAGEND;	//end tag
+		case 2:
+			tokenos << US_CDATAOPEN;
+		case 3:
+			tokenos << cdata;
+		}
+		tokenos << US_CDATACLOSE;
+		content = 3;
+	}
+	else if (3 == content)	//close cdata
+	{
+		tokenos << US_CDATACLOSE;
+	}
+	
+	cdata.clear();
+	
+	
+	if (!m_text.empty())
+	{
+		if (0 == content)	//means no children printed
+		{
+			tokenos << UC_TAGEND;	//end tag
+			content = 1;
+		}
+		tokenos << m_text;
+	}
+	
+	// -- extra pcdata
+	x_AssemblePCData(cdata);
+	
+	if (!cdata.empty())	//use this
+	{
+		switch (content)
+		{
+		case 0:	//nothing, need end tag
+			tokenos << UC_TAGEND;	//end tag
+			content = 1;
+		default:
+			
+			tokenos << cdata;
+			break;
+		}
+	}
+	if (0 == content)	//empty tag, using shorthand close
+		tokenos << US_TAGENDSH;
+	else
+	{
+		tokenos << US_CLOSETAG;
+		dataos << m_tagname;
+		tokenos << UC_TAGEND;
+	}
+
+}
+
+void LXML::CGXMLNode::x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl) const
+{
+	USTRING idnts(k_ustrEmptyUSTRING);
+	if (lvl > 0) idnts.insert(idnts.end(), lvl, UC_TAB);
+	int content = 0;
+	USTRING cdata(k_ustrEmptyUSTRING);
+	if (m_tagname.empty())	//treat as a comment node, only print CDATA
+	{
+		if (!m_cdata.empty())
+		{
+			tokenos << idnts << US_COMMENTOPEN << UC_NL;
+			tokenos << idnts << UC_TAB << m_cdata << UC_NL;
+			content = 1;
+		}
+		
+		x_AssembleCData(cdata);
+		
+		if (!cdata.empty())
+		{
+			if (0 == content)
+			{
+				tokenos << idnts << US_COMMENTOPEN << UC_NL;
+				content = 1;
+			}
+			tokenos << idnts << UC_TAB << cdata << UC_NL;
+		}
+		
+		if (content > 0)
+			tokenos << idnts << US_COMMENTCLOSE << UC_NL;
+		
+		return;	
+	}
+
+	tokenos << idnts;
+	tokenos << UC_OPENTAG;
+	dataos << m_tagname;
+	
+	if (!m_defns.empty())
+	{
+		tokenos << UC_WHITESP << US_XMLNS << UC_QUOT;
+		dataos << m_defns;
+		tokenos << UC_QUOT;
+	}
+	
+	if (!m_nspfx.empty())
+	{
+		for (TProps::const_iterator iter = m_nspfx.begin(), iterEnd = m_nspfx.end(); iterEnd != iter; ++iter)
+		{
+			tokenos << UC_WHITESP << US_XMLNSPRF;
+			dataos << iter->first;
+			tokenos << UC_EQUAL << UC_QUOT;
+			dataos << iter->second;
+			tokenos << UC_QUOT;
+		}
+	}
+	
+	if (!m_attribs.empty())
+	{
+		for (TProps::const_iterator iter = m_attribs.begin(), iterEnd = m_attribs.end(); iterEnd != iter; ++iter)
+		{
+			tokenos << UC_WHITESP;
+			dataos << iter->first;
+			tokenos << UC_EQUAL << UC_QUOT;
+			dataos << iter->second;
+			tokenos << UC_QUOT;
+		}
+	}
+	
+	// -- get extra properties from derived classes
+	// -- typically style=
+	TProps exprops;
+	x_AssembleExtraAttribs(exprops);
+	
+	if (!exprops.empty())
+	{
+		for (TProps::const_iterator iter = exprops.begin(), iterEnd = exprops.end(); iterEnd != iter; ++iter)
+		{
+			tokenos << UC_WHITESP;
+			dataos << iter->first;
+			tokenos << UC_EQUAL << UC_QUOT;
+			dataos << iter->second;
+			tokenos << UC_QUOT;
+		}
+	}
+	
+	// -- children first
+	
+
+	if (!m_children.empty())
+	{
+		tokenos << UC_TAGEND << UC_NL;	//end tag
+		content = 2;	//has children
+		for (TChildren::const_iterator iter = m_children.begin(), iterEnd = m_children.end(); iterEnd != iter; ++iter)
+		{
+			(*iter)->x_Print(tokenos, dataos, lvl + 1);
+			tokenos << UC_NL;
+		}
+	}
+	
+	if (!m_cdata.empty())
+	{
+		if (0 == content)	//no children, need end of tag
+		{
+			tokenos << UC_TAGEND << UC_NL;	//end tag
+			//content = 2;
+		}
+		// -- CDATA should not escape
+		tokenos << idnts << UC_TAB << US_CDATAOPEN << UC_NL << idnts << UC_TAB << UC_TAB << m_cdata << UC_NL;
+		content = 3;	//as cdata section
+	}
+	
+	// -- CDATA
+	x_AssembleCData(cdata);
+	
+	if (!cdata.empty())
+	{
+		switch (content)
+		{
+		case 0:	//no children, no m_cdata
+			tokenos << UC_TAGEND << UC_NL;	//end tag
+		case 2:
+			tokenos << idnts << UC_TAB << US_CDATAOPEN << UC_NL;
+		case 3:
+			tokenos << idnts << UC_TAB << UC_TAB << cdata << UC_NL;
+		}
+		tokenos << idnts << UC_TAB << US_CDATACLOSE << UC_NL;
+		content = 3;
+	}
+	else if (3 == content)	//close cdata
+	{
+		tokenos << idnts << UC_TAB << US_CDATACLOSE << UC_NL;
+	}
+	
+	cdata.clear();
+	
+	if (!m_text.empty())
+	{
+		if (0 == content)	//means no children printed. Print texxt and close tag in one line
+		{
+			tokenos << UC_TAGEND;	//end tag
+			tokenos << m_text;
+			content = 1;
+		}
+		else	// not empty, already have a newline
+		{
+			tokenos << idnts << UC_TAB;	//end tag
+			tokenos << m_text;
+			tokenos << UC_NL;
+		}
+	}
+	
+	
+	x_AssemblePCData(cdata);
+	
+	if (!cdata.empty())	//use this
+	{
+		switch (content)
+		{
+		case 0:	//nothing, need end tag
+			tokenos << UC_TAGEND;	//end tag
+		case 1:	//has text, just follow it and treat as inline	
+			dataos << cdata;
+			content = 1;
+			break;
+		default:
+			tokenos << idnts << UC_TAB;
+			dataos << cdata;
+			tokenos << UC_NL;
+			break;
+		}
+	}
+	
+	switch (content)
+	{
+	case 0:
+		tokenos << US_TAGENDSH;
+		break;
+	case 1:	//inline close
+		tokenos << US_CLOSETAG;
+		dataos << m_tagname;
+		tokenos << UC_TAGEND;
+		break;
+	default:	//has newline
+		tokenos << idnts << US_CLOSETAG;
+		dataos << m_tagname;
+		tokenos << UC_TAGEND;
+		
+	}
+	
+}
+
+void LXML::CGXMLNode::x_AssembleExtraAttribs(TProps &exprops) const
+{}
+void LXML::CGXMLNode::x_AssemblePCData(USTRING &exprops) const
+{}
+void LXML::CGXMLNode::x_AssembleCData(USTRING &exprops) const
+{}
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/lxml.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/lxml.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/lxml.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/lxml.hpp	2018-03-13 14:39:35.294236000 -0400
@@ -0,0 +1,270 @@
+#if !defined(__LXML__)
+#define __LXML__
+
+#include "ustring.hpp"
+#include "datanode.hpp"
+#include <iostream>
+#include <list>
+#include <map>
+#include <string>
+#include <cstring>
+
+
+namespace LXML
+{
+	
+	// -- all USTRING implementation
+	class CGXMLNode;
+	typedef CDocNodeRef<CGXMLNode> CGXMLRef;
+	typedef std::map<USTRING, USTRING> TProps;
+	typedef std::list< CGXMLRef > TChildren;
+		
+	extern const USTRING US_DEFVER10;
+	extern const USTRING US_DTDTYPE;
+	extern const USTRING US_DTDLANG;
+	
+	class CProlog
+	{
+		friend class CGXMLDoc;
+	public:
+		USTRING name;	//if empty, default as stypesheet
+		std::map<USTRING, USTRING> attribs;
+			
+		CProlog(void): name(k_ustrEmptyUSTRING), attribs() {};
+		void Print(std::ostream &os) const;
+		void Print(std::ostream &os, int lvl) const;
+		void Reset(void) {name.clear(); attribs.clear();}
+	private:
+		void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl) const;
+	};
+	
+
+	class CDTDDef
+	{
+		friend class CGXMLDoc;
+	public:
+		enum EType
+		{
+			eElement,
+			eAttribute,
+			eEntity
+		} deftype;
+		
+		USTRING defname;
+		USTRING valtype;
+		USTRING value;
+		USTRING elem;	//for attribs, element it belongs to
+		
+		bool empty_fixed_external;	//for element, #EMPTY. for attribs, #FIXED, for entities, external 
+		bool required_private;	//for attribs, #REQUIRED, for entities: private DTD
+		
+		CDTDDef(void):deftype(eElement), defname(k_ustrEmptyUSTRING), valtype(k_ustrEmptyUSTRING), value(k_ustrEmptyUSTRING), elem(k_ustrEmptyUSTRING), empty_fixed_external(false), required_private(false) {};
+		void Reset(void) {deftype = eElement; defname.clear(); valtype.clear(); value.clear(); elem.clear(); empty_fixed_external = false; required_private = false;}
+		void Print(std::ostream &os) const;
+		void Print(std::ostream &os, int lvl) const;
+	private:
+		void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl) const;
+	};
+	
+	class CGXMLDoc
+	{
+	public:
+		// -- BasicUtils/ustring.hpp
+		//static const int E_UTF8 = 8;
+		//static const int E_UTF16BE = 16;
+		//static const int E_UTF16LE = -16;
+		CGXMLDoc(CGXMLRef root, int enc = E_UTF8);
+		template<typename T>
+		CGXMLDoc(CDocNodeRef<T> root, int enc = E_UTF8);
+		// -- public data, user fill in for convenience
+		USTRING XMLVer;
+		
+		bool IsISOStd;
+		bool IsApproved;
+		bool Standalone;	//has external reference, will cause document standalone to be "no"
+		
+		USTRING DTDOwner;
+		USTRING DTDType;
+		USTRING DTDDescr;
+		USTRING DTDLangId;	//language id
+		USTRING DTDVer;
+		// -- lack any of the above three will be treated as a private DTD
+		USTRING DTDURI;
+		
+		
+		void AddProlog(const CProlog & prlg);
+		CProlog & AddProlog(void);
+		
+		void AddDTDDef(const CDTDDef & def);
+		CDTDDef & AddDTDDef(void);
+		
+		
+		void Print(std::ostream &os) const;
+		void Print(std::ostream &os, int lvl) const;
+			
+		
+		
+	private:
+		
+		CGXMLRef m_root;
+		int m_enc;
+		
+		// -- external style sheet
+		//std::list<USTRING> m_doc
+		
+		std::list<CProlog> m_prologs;	//external stylesheets
+		std::list<CDTDDef> m_dtddefs;	//for internal
+		
+	};
+
+	template<typename T>
+	CGXMLDoc::CGXMLDoc(CDocNodeRef<T> root, int enc):
+		XMLVer(US_DEFVER10), IsISOStd(false), IsApproved(false), Standalone(false),
+		DTDOwner(k_ustrEmptyUSTRING), DTDType(US_DTDTYPE), DTDDescr(k_ustrEmptyUSTRING), DTDLangId(US_DTDLANG), DTDVer(k_ustrEmptyUSTRING), DTDURI(k_ustrEmptyUSTRING),
+		m_root(nullptr), m_enc(E_UTF8), m_prologs(), m_dtddefs()
+	{
+		T *pT = root.GetPointer();
+		if (nullptr != pT)
+		{
+			CGXMLNode *pX = dynamic_cast< CGXMLNode* > (pT);
+			if (nullptr == pX)
+				throw CSimpleException(__FILE__, __LINE__, "Incompatiple root node type");
+			m_root = pX;
+		}
+			
+		if (E_UTF16LE == enc || E_UTF16BE == enc)
+		m_enc = enc;
+	}
+	
+	class CGXMLNode: public CDocNodeBase
+	{
+		friend class CDocNodeRef<CGXMLNode>;
+		friend class CGXMLDoc;
+	public:
+		//CGXMLNode(const std::string &tag);
+		// -- if tag is empty, its a comment node. data will be cdata
+		template<typename TTAG, typename... TDATA>
+		CGXMLNode(TTAG &&tag, TDATA&& ...data);
+		
+		//CGXMLNode(const USTRING &tag, const USTRING &data = k_ustrEmptyUSTRING);
+		//CGXMLNode(USTRING &&tag, const USTRING &data = k_ustrEmptyUSTRING);
+		//CGXMLNode(USTRING &&tag, USTRING &&data);
+		//CGXMLNode(const USTRING &tag, USTRING &&data);
+/*debug*******************************************************
+#if defined(_DEBUG)
+		virtual ~CGXMLNode(void)
+		{
+			std::cerr << __FILE__ << ':' << __LINE__ << ": Node \"" << m_tagname << "\" called!" << std::endl;
+		}
+
+#endif
+// ***********************************************************/
+
+		
+		const USTRING & GetTag(void) const {return m_tagname;}
+		
+		const USTRING & GetText(void) const {return m_text;}
+		USTRING & SetText(void) {return m_text;}
+		void SetText(const USTRING & txt);
+		void SetText(USTRING && txt);
+		
+		const USTRING & GetCData(void) const {return m_cdata;}
+		USTRING & SetCData(void) {return m_cdata;}
+		void SetCData(const USTRING & cdata);
+		void SetCData(USTRING && cdata);
+		
+		const USTRING & GetDefaultNS(void) const {return m_defns;}
+		USTRING & SetDefaultNS(void) {return m_defns;}
+		void SetDefaultNS(const USTRING & defns);
+		void SetDefaultNS(USTRING && defns);
+		
+		const USTRING & GetAttrib(const USTRING &attr_name) const;
+		void SetAttrib(const USTRING &attr_name, const USTRING &attr_value);
+		void SetAttrib(const USTRING &attr_name, USTRING &&attr_value);
+		
+		USTRING & SetAttrib(const USTRING &attr_name);
+		void RemoveAttrib(const USTRING &attr_name);
+		
+		// -- define ns. if prefix is empty, refer to default namespace
+		void DefNSPfx(const USTRING &pfx, const USTRING &ns);
+		void DefNSPfx(const USTRING &pfx, USTRING &&ns);
+		void UndefNSPfx(const USTRING &pfx);
+		const USTRING & GetNS(const USTRING &pfx) const;
+			
+		bool AppendChild(CGXMLRef ch);	//will check to make sure no dup in children
+		CGXMLRef AppendChild(const USTRING &tag, const USTRING &data = k_ustrEmptyUSTRING);
+		
+		CGXMLRef AppendComment(const USTRING &comment);
+		//CGXMLRef AppendChild(const std::string &tag);
+		bool RemoveChild(CGXMLRef ch);
+		void RemoveChildren(const USTRING &tag);
+		//void RemoveChildren(const std::string &tag);
+		//TChildren FindChild(const std::string &tn) const;	//find child by tag name
+		std::vector<CGXMLRef> FindChildren(const USTRING &tag) const;	//find child by tag name
+		
+		void ClearChildren(void);
+		const TChildren &GetChildren(void) const {return m_children;}
+		
+		// -- template version of children operations for derived classes
+		template<typename T>
+		bool AppendChild(CDocNodeRef<T> ch);	//will check to make sure no dup in children
+		
+		template<typename T>
+		bool RemoveChild(CDocNodeRef<T> ch);
+		
+		// -- simple UTF-8 print. for xml pieces
+		void Print(std::ostream &os) const;
+		void Print(std::ostream &os, int lvl) const;
+		
+	protected:
+		
+		USTRING m_tagname;
+		USTRING m_defns;	//default name space
+		
+		USTRING m_text;	//text node. PCDATA
+		USTRING m_cdata;	//text for CDATA
+		
+		
+		TProps m_attribs;
+		// -- specialized attributes
+		TProps m_nspfx;	//namespace prefix
+			
+		TChildren m_children;
+	private:
+		void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos) const;
+		void x_Print(CUTFOstream &tokenos, CUTFOstream &dataos, int lvl) const;
+		
+		// -- for derivatives to add extra attributes, such as style
+		virtual void x_AssembleExtraAttribs(TProps &exprops) const;
+		virtual void x_AssemblePCData(USTRING &pcdata) const;
+		virtual void x_AssembleCData(USTRING &cdata) const;
+	};
+	
+	// -- template implementation
+	template<typename T>
+	bool CGXMLNode::AppendChild(CDocNodeRef<T> ch)
+	{
+		//CDocNodeRef<CGXMLNode> ref(ch.GetPointer());
+		return AppendChild(CDocNodeRef<CGXMLNode> (ch.GetPointer()));
+	}
+	
+	template<typename T>
+	bool CGXMLNode::RemoveChild(CDocNodeRef<T> ch)
+	{
+		//CDocNodeRef<CGXMLNode> ref(ch.GetPointer());
+		return RemoveChild(CDocNodeRef<CGXMLNode> (ch.GetPointer()));
+	}
+	
+	template<typename TTAG, typename... TDATA>
+	CGXMLNode::CGXMLNode(TTAG &&tag, TDATA&& ...data):
+		m_tagname(std::forward<TTAG>(tag)), m_defns(k_ustrEmptyUSTRING), m_text(std::forward<TDATA>(data)...), m_cdata(k_ustrEmptyUSTRING), m_attribs(), m_nspfx(), m_children()
+	{}
+};
+
+
+
+
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/main.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/main.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/main.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/main.cpp	2018-03-13 14:39:35.441846000 -0400
@@ -0,0 +1,891 @@
+#include <ncbi_pch.hpp>
+#include "envdef.hpp"
+#include "offl_cd_align_proc.hpp"
+#include "offl_sparcle_data.hpp"
+#include "objutils.hpp"
+#include "ptrmap.hpp"
+#include "compactstore.hpp"
+#include "basealgo.hpp"
+#include "enumlit.hpp"
+#include "argwrapper.hpp"
+#include "datanode.hpp"
+#include "lxml.hpp"
+#include "ljson.hpp"
+#include "ustring.hpp"
+#include "combistream.hpp"
+#include "segset.hpp"
+#include "offldata.hpp"
+//#include <serial/objostrxml.hpp>
+//#include <serial/objistr.hpp>
+//#include <serial/serial.hpp>
+/*debug*******************************************************/
+#if defined(_DEBUG)
+#include <corelib/ncbitime.hpp>
+#endif
+// ***********************************************************/
+#include <corelib/ncbiapp.hpp>
+#include <corelib/ncbifile.hpp>
+#include <corelib/ncbireg.hpp>
+
+static const char *PROGRAM_USAGE =	//multiline
+"Process rpsblast output and try to assign a name based on "
+"computed domain architecture.";
+
+static const char *PROGRAM_DESCRIPTION =	//multiline
+"This program accepts output from rpsblast command line utility with '-outfmt 5' option, "
+"basically the CBlastOutput object serialized in xml. For each Iteration in the object, "
+"the program will computer the domain architecture of the query sequence and assign the associated "
+"name to it.\n\n"
+"The output will be an xml document defined by cluster_assignment.dtd from gpipe project";
+
+static constexpr const struct TVER
+{
+	int major;
+	int minor;
+	int patch_level;
+} VER = {0, 1, 0};
+
+// -- Define error codes
+enum EErrorSubCode
+{
+	e_OK = 0,
+	e_InitFileError,
+	e_DataFileError,
+	e_PrecedenceUndefined,
+	e_NamingSourceUndefined,
+	//-----------------------
+	eErr_TotalErrorCodes
+};
+
+//This macro must be used inside ncbi namespace
+BEGIN_NCBI_SCOPE
+NCBI_DEFINE_ERRCODE_X(Sparclbl_job, 134, eErr_TotalErrorCodes - 1);
+END_NCBI_SCOPE
+
+//customize Argument definition
+USING_NCBI_SCOPE;
+using namespace objects;
+using namespace LXML;
+// -- must be defined for ERR_POST_X
+#define NCBI_USE_ERRCODE_X Sparclbl_job
+
+/**********************************************************************
+*	Define constants
+**********************************************************************/
+constexpr const char * __default_datadir = "data";
+constexpr const char * __reg_section_cdddata = "cdddata";
+constexpr const char * __reg_tag_datadir = "datadir";
+constexpr const char * __reg_tag_cddids = "cddids";
+constexpr const char * __reg_tag_bscores = "bscores";
+constexpr const char * __reg_tag_spfeats = "spfeats";
+constexpr const char * __reg_tag_genfeats = "genfeats";
+constexpr const char * __reg_tag_cdtrack = "cdtrack";
+constexpr const char * __reg_tag_famlinks = "famlinks";
+constexpr const char * __reg_tag_sparchs = "sparchs";
+constexpr const char * __reg_tag_genarchs = "genarchs";
+constexpr const char * __reg_tag_namesrc = "namesrc";
+
+
+// -- for naming source and confidence level
+static constexpr const char * __name_src_file = "reviewlevel_namesrc.txt";
+// *******************************************************************/
+
+
+
+struct TNamingSource2Confidence
+{
+	string m_NameSource;
+	int m_Confidence;
+	
+	
+};
+	
+typedef std::map<string, TNamingSource2Confidence> TReviewLevel2Precedence;
+
+/*debug*******************************************************/
+#if defined(_DEBUG)
+CStopWatch sw(CStopWatch::eStart);
+#endif
+// ***********************************************************/
+
+
+// -- give argument index names
+enum EArgIndice: unsigned int
+{
+	// -- name-indice here. C++ standard, if no value explicitly assigned, enumerators start from 0 and increase by 1
+	argListIn,	//path/name of a file contains a list of input data files (ie, blast xml files)
+	argOutFile,
+	argEVCutoff,
+	argDataDir,
+	argPrecedenceFile,
+	// ------------------------
+	TOTALARGS	//This natually as arg count.
+};
+
+static TArgDefinition dimValidArgs[] = 
+{
+	// -- define your valid arguments
+	// -- do not use nullptr. use EMPTYSTR as empty string
+	{
+		"l",	//argListIn
+		TArgDefinition::eKey,	//enum TArgDefinition::EArgCategory(argument type: eKey, ePos, eOpenPos, eFlag, eNegFlag)
+		ncbi::CArgDescriptions::eString,	//ncbi::CArgDescriptions::EType(process type)
+		"Specify the name of the list file that contains path/names of input data files",	//string (description)
+		true,	//if optional
+		TArgDefinition::EMPTYSTR,	//Synopsis (short description)
+		"-inlist",	//alias (can be used to specify at command line but not indexed in program
+		0,	//ncbi::CArgDescriptions::EFlags
+		TArgDefinition::EMPTYSTR,	//value environment var (read arg value from this environment variable)
+		TArgDefinition::EMPTYSTR,	//Default Value
+		nullptr,	//ncbi::CArgAllow * , constraint
+		ncbi::CArgDescriptions::eConstraint	//ncbi::CArgDescriptions::EConstraintNegate, eConstraint or eConstraintInvert
+	},
+	{
+		"o",	//argOutFile
+		TArgDefinition::eKey,	//enum TArgDefinition::EArgCategory(argument type: eKey, ePos, eOpenPos, eFlag, eNegFlag)
+		ncbi::CArgDescriptions::eString,	//ncbi::CArgDescriptions::EType(process type)
+		"Specify output file name. If omitted, output to stdout",	//string (description)
+		true,	//if optional
+		TArgDefinition::EMPTYSTR,	//Synopsis (short description)
+		"-outfile",	//alias (can be used to specify at command line but not indexed in program
+		0,	//ncbi::CArgDescriptions::EFlags
+		TArgDefinition::EMPTYSTR,	//value environment var (read arg value from this environment variable)
+		TArgDefinition::EMPTYSTR,	//Default Value
+		nullptr,	//ncbi::CArgAllow * , constraint
+		ncbi::CArgDescriptions::eConstraint	//ncbi::CArgDescriptions::EConstraintNegate, eConstraint or eConstraintInvert
+	},
+	{
+		"e",	//argEVCutoff
+		TArgDefinition::eKey,	//enum TArgDefinition::EArgCategory(argument type: eKey, ePos, eOpenPos, eFlag, eNegFlag)
+		ncbi::CArgDescriptions::eDouble,	//ncbi::CArgDescriptions::EType(process type)
+		"Specify E-Value cut off. Default is 0.01",	//string (description)
+		true,	//if optional
+		TArgDefinition::EMPTYSTR,	//Synopsis (short description)
+		"-evcut",	//alias (can be used to specify at command line but not indexed in program
+		0,	//ncbi::CArgDescriptions::EFlags
+		TArgDefinition::EMPTYSTR,	//value environment var (read arg value from this environment variable)
+		"0.01",	//Default Value
+		nullptr,	//ncbi::CArgAllow * , constraint
+		ncbi::CArgDescriptions::eConstraint	//ncbi::CArgDescriptions::EConstraintNegate, eConstraint or eConstraintInvert
+	},
+	{
+		"d",	//argDataDir
+		TArgDefinition::eKey,	//enum TArgDefinition::EArgCategory(argument type: eKey, ePos, eOpenPos, eFlag, eNegFlag)
+		ncbi::CArgDescriptions::eString,	//ncbi::CArgDescriptions::EType(process type)
+		"Specify the directory where CDD/SPARCLE data reside. If omitted, looking for a directory named 'data' in the same directory where this binary is.",	//string (description)
+		true,	//if optional
+		TArgDefinition::EMPTYSTR,	//Synopsis (short description)
+		"-datadir",	//alias (can be used to specify at command line but not indexed in program
+		0,	//ncbi::CArgDescriptions::EFlags
+		TArgDefinition::EMPTYSTR,	//value environment var (read arg value from this environment variable)
+		TArgDefinition::EMPTYSTR,	//Default Value
+		nullptr,	//ncbi::CArgAllow * , constraint
+		ncbi::CArgDescriptions::eConstraint	//ncbi::CArgDescriptions::EConstraintNegate, eConstraint or eConstraintInvert
+	},
+	{
+		"p",	//argPrecedenceFile
+		TArgDefinition::eKey,	//enum TArgDefinition::EArgCategory(argument type: eKey, ePos, eOpenPos, eFlag, eNegFlag)
+		ncbi::CArgDescriptions::eString,	//ncbi::CArgDescriptions::EType(process type)
+		"Specify the full path of a procedence definition file.",	//string (description)
+		false,	//if optional
+		TArgDefinition::EMPTYSTR,	//Synopsis (short description)
+		"-precedence",	//alias (can be used to specify at command line but not indexed in program
+		0,	//ncbi::CArgDescriptions::EFlags
+		TArgDefinition::EMPTYSTR,	//value environment var (read arg value from this environment variable)
+		TArgDefinition::EMPTYSTR,	//Default Value
+		nullptr,	//ncbi::CArgAllow * , constraint
+		ncbi::CArgDescriptions::eConstraint	//ncbi::CArgDescriptions::EConstraintNegate, eConstraint or eConstraintInvert
+	}
+	
+};
+
+// -- positional arguments
+static const size_t TOTALEXTRAARGS = 1;
+static TExtraArg dimValidExtraArgs[] = 
+{
+	{0, kMax_UInt, "Files that contain genomic sequence data. If none specified, read sequence data from stdin.", ncbi::CArgDescriptions::eInputFile, 0}
+};
+
+string bin_name;
+
+
+
+class CSparcLabelApp: public CNcbiApplication
+{
+public:
+	CSparcLabelApp(void);
+	virtual void Init(void);
+	virtual int Run(void);
+	virtual int DryRun(void);
+	virtual void Exit(void);
+	~CSparcLabelApp(void);
+private:
+	string m_bin_loc;
+	string m_bin_name;
+	CNcbiRegistry& m_reg;
+	ofstream m_outfile;
+	
+};
+
+CSparcLabelApp::CSparcLabelApp(void): CNcbiApplication(), m_bin_loc(), m_bin_name(), m_reg(GetConfig()), m_outfile()
+{
+	size_t lastslash = bin_name.rfind('/');
+	if (string::npos == lastslash)
+	{
+		m_bin_loc = ".";
+		m_bin_name = bin_name;
+	}
+	else
+	{
+		m_bin_loc = bin_name.substr(0, lastslash);
+		m_bin_name = bin_name.substr(lastslash + 1);
+	}
+
+	SetVersion(CVersionInfo(VER.major, VER.minor, VER.patch_level));
+}
+
+void CSparcLabelApp::Init(void)
+{
+	// -- first
+	CNcbiApplication::Init();
+	//size_t slash_pos = bin_name.rfind('/');
+	//if (string::npos != slash_pos)
+	//	m_bin_loc = bin_name.substr(0, slash_pos);
+	//string inifile = bin_name + ".ini";
+	////CFile cfgfile(bin_name + ".ini");
+	//
+	//ifstream regfs(inifile.c_str(), ios::in | ios::binary);
+	//	
+	//if (regfs.good())
+	//{
+	//	try
+	//	{
+	//		m_reg.Read(regfs, CNcbiRegistry::eTransient);
+	//	}
+	//	catch (CException e)
+	//	{
+	//		LOG_POST_X(e_InitFileError, e.what());
+	//	}
+	//	catch (...)
+	//	{
+	//		LOG_POST_X(e_InitFileError, "Unknown error when processing ini file");
+	//	}
+	//}
+	//regfs.close();
+		
+	SetupArgDescriptions(ProcessArgDefinitions(m_bin_name, PROGRAM_USAGE, PROGRAM_DESCRIPTION, dimValidArgs, TOTALARGS, dimValidExtraArgs, TOTALEXTRAARGS));
+}
+
+
+CGXMLRef CreateNamingXmlNode(const string &qid, ArchId_t archid, const string & name, const string &label, const string &archstr, const string &archType, const TNamingSource2Confidence &evd)
+{
+	char dimBuf[32];
+	
+	
+	//CGXMLRef root(new CGXMLNode("NameAssignment"));
+	CGXMLRef protein(new CGXMLNode("Protein"));
+	//root->AppendChild(protein);
+	
+	protein->SetAttrib("Seq-id", qid);
+	protein->AppendChild("AssignedName", name);
+	
+	
+	CGXMLRef support(new CGXMLNode("Support"));
+	protein->AppendChild(support);
+	
+	CGXMLRef sparcle(new CGXMLNode("SPARCLE"));
+	support->AppendChild(sparcle);
+	
+	sprintf(dimBuf, "%d", archid);
+	
+	sparcle->AppendChild("ArchId", dimBuf);
+	sparcle->AppendChild("Name", name);
+	sparcle->AppendChild("Label", label);
+	
+	sparcle->AppendChild(archType, archstr);
+	
+	//CGXMLRef evdline(new CGXMLNode("EvidenceLine"));
+	//evdline->AppendChild("archstr", archstr);
+	
+	// -- Precedence under protein
+	CGXMLRef precedence(new CGXMLNode("Precedence"));
+	protein->AppendChild(precedence);
+	
+	precedence->AppendChild("evidence_source", evd.m_NameSource);
+	sprintf(dimBuf, "%d", evd.m_Confidence);
+	precedence->AppendChild("confidence", dimBuf);
+	
+	return protein;
+}
+
+void ProcessBlastOut(istream &data_in, double evalcut, const COfflCdAlignProcessor &proc, const TDomClusterIndexIfx& dom_cluster_src, const TArchIndexIfx &arch_src, const map<string, TNamingSource2Confidence> &namesrc_cfd, CGXMLRef xroot)
+{
+	while (data_in.good())
+	{
+		CBlastOutput objBlastOutput;
+		try
+		{
+			ObjStreamIn<CBlastOutput> (data_in, objBlastOutput, eSerial_Xml);
+		}
+		catch (...)	//It's done here
+		{
+			return;
+		}
+	
+		const CBlastOutput::TIterations &rIters = objBlastOutput.GetIterations();
+		for (CBlastOutput::TIterations::const_iterator iter = rIters.begin(), iterEnd = rIters.end(); iterEnd != iter; ++iter)
+		{
+			_TOfflDomQuery qobj;
+			vector<PssmId_t> missed;
+			proc.ParseBlastOutput(qobj, **iter, missed, evalcut);
+			string archStr, spArchStr;
+
+			CreateArchStrings(dom_cluster_src, qobj.m_dimSplitAligns[0].m_vecConciseIndice, qobj.m_vecAlignments, archStr, spArchStr);
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": spArchStr = " << spArchStr << ", archStr = " << archStr << endl;
+#endif
+// ***********************************************************/
+  		
+			if (!spArchStr.empty())
+			{
+				const TSpDomArch * pSpArch = arch_src.FindSpArch(spArchStr);
+				if (nullptr != pSpArch)
+				{
+					//cout << "Found specific architecture " << pSpArch->m_uiArchId << endl;
+					//cout << "Tentative name for " << qobj.m_strCleanedInput << ": " << pSpArch->m_strName << endl;
+					//cout << "Label: " << pSpArch->m_strLabel << endl;
+					//cout << "Review level:" << pSpArch->m_strReviewLevel << endl;
+					//cout << "Current defline: " << qobj.m_strTitle << endl;
+					
+					
+					map<string, TNamingSource2Confidence> :: const_iterator iterMethod = namesrc_cfd.find(pSpArch->m_strReviewLevel);
+					if (namesrc_cfd.end() != iterMethod)
+					{
+						CGXMLRef prt = CreateNamingXmlNode(qobj.m_strCleanedInput, pSpArch->m_uiArchId, pSpArch->m_strName, pSpArch->m_strLabel, pSpArch->m_strArchString, "SpecificArch", iterMethod->second);
+          	
+						xroot->AppendChild(prt);
+					}
+					else
+					{
+						LOG_POST_X(e_NamingSourceUndefined, "Undefined corresponding naming source value for review level " << pSpArch->m_strReviewLevel);
+					}
+				}
+			}
+		}
+	}
+}
+
+// -- return value:
+//	0: success
+//	1: reviewlevel2namesrc file error
+//	2: namesrc2confidence file error
+//	3: undefined confidence level
+int LoadPrecedenceMapFiles(const char * rl2src_fn, const char *src2cfd_fn, TReviewLevel2Precedence &dst)
+{
+	string buf;
+	ifstream inf(src2cfd_fn);
+	if (!inf.good())
+	{
+		LOG_POST_X(e_DataFileError, "Cannot open " << src2cfd_fn);
+		return 2;
+	}
+	
+	map<string, int> map_proc;
+	while (inf.good())
+	{
+		buf.clear();
+		getline(inf, buf);
+		LTrimString(buf);
+		if (!buf.empty() && '#' != buf[0])
+		{
+			size_t pos = buf.find('\t');
+			if (string::npos == pos)
+				continue;
+			int p;
+			// -- number
+			string tmp = buf.substr(pos + 1);
+			TrimString(tmp);
+			try
+			{
+				p = NStr::StringToNumeric<int> (tmp);
+			}
+			catch (...)
+			{
+				continue;	//just skip invalid lines
+			}
+			tmp = buf.substr(0, pos);
+			TrimString(tmp);
+			map_proc.emplace(tmp, p);
+		}
+	}
+	
+	inf.close();
+	inf.open(rl2src_fn);
+	if (!inf.good())
+	{
+		LOG_POST_X(e_DataFileError, "Cannot open " << rl2src_fn);
+		return 1;
+	}
+	
+	while (inf.good())
+	{
+		buf.clear();
+		getline(inf, buf);
+		if (!buf.empty() && '#' != buf[0])
+		{
+			size_t pos = buf.find('\t');
+			if (string::npos == pos)
+				continue;
+			string nsrc = buf.substr(pos + 1);
+			map<string, int> :: const_iterator iterPrec = map_proc.find(nsrc);
+			if (map_proc.end() == iterPrec)
+			{
+				LOG_POST_X(e_PrecedenceUndefined, "Undefined confidence level for naming source " << nsrc << ", corresponding to review level " << buf.substr(0, pos));
+				return 3;
+			}
+			
+			dst.emplace(buf.substr(0, pos), TNamingSource2Confidence{move(nsrc), iterPrec->second});
+		}
+	}
+	return 0;
+}
+
+int CSparcLabelApp::Run(void)
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Elapsed: " << sw.Elapsed() << ": Entering Run()" << endl;
+#endif
+// ***********************************************************/
+
+	int retVal = 0;
+	const CArgs & args = GetArgs();
+	
+	const CArgValue
+		&AV_InList = args[dimValidArgs[argListIn].name],
+		&AV_OutFile = args[dimValidArgs[argOutFile].name],
+		&AV_EvalCutoff = args[dimValidArgs[argEVCutoff].name],
+		&AV_DataDir = args[dimValidArgs[argDataDir].name],
+		&AV_PrecedenceFile = args[dimValidArgs[argPrecedenceFile].name];
+	
+	
+	string datadir = m_bin_loc + "/" + __default_datadir;
+	
+	if (AV_DataDir.HasValue())
+		datadir = AV_DataDir.AsString();
+	else
+	{
+		const string & dataloc = m_reg.Get(__reg_section_cdddata, __reg_tag_datadir);
+		if (!dataloc.empty())
+			datadir = dataloc;
+	}
+	if (CDir(datadir).Exists())
+	{
+		// -- check if procedence definition file provided
+		
+		const char
+			*cddids = nullptr,
+			*bscores = nullptr,
+			*spfeats = nullptr,
+			*genfeats = nullptr,
+			*cdtrack = nullptr,
+			*famlinks = nullptr,
+			*sparchs = nullptr,
+			*genarchs = nullptr,
+			*namesrc = __name_src_file;
+			
+		const string &reg_namesrc = m_reg.Get(__reg_section_cdddata, __reg_tag_namesrc);
+		if (!reg_namesrc.empty())
+			namesrc = reg_namesrc.c_str();
+		
+		
+		TReviewLevel2Precedence namesrc_cfd;
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Elapsed: " << sw.Elapsed() << ": Before LoadPrecedenceMapFiles()" << endl;
+#endif
+// ***********************************************************/
+		
+		int rcode = LoadPrecedenceMapFiles((datadir + "/" + namesrc).c_str(), AV_PrecedenceFile.AsString().c_str(), namesrc_cfd);
+		
+		if (rcode > 0) return rcode;
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Elapsed: " << sw.Elapsed() << ": After LoadPrecedenceMapFiles()" << endl;
+#endif
+// ***********************************************************/
+		
+			
+		const string & reg_cddids = m_reg.Get(__reg_section_cdddata, __reg_tag_cddids);
+
+		if (!reg_cddids.empty())
+			cddids = reg_cddids.c_str();
+		
+		const string & reg_bscores = m_reg.Get(__reg_section_cdddata, __reg_tag_bscores);
+		if (!reg_bscores.empty())
+			bscores = reg_bscores.c_str();
+		
+		const string & reg_spfeats = m_reg.Get(__reg_section_cdddata, __reg_tag_spfeats);
+		if (!reg_spfeats.empty())
+			spfeats = reg_spfeats.c_str();
+		
+		const string & reg_genfeats = m_reg.Get(__reg_section_cdddata, __reg_tag_genfeats);
+		if (!reg_genfeats.empty())
+			genfeats = reg_genfeats.c_str();
+		
+		const string & reg_cdtrack = m_reg.Get(__reg_section_cdddata, __reg_tag_cdtrack);
+		if (!reg_cdtrack.empty())
+			cdtrack = reg_cdtrack.c_str();
+		
+		const string & reg_famlinks = m_reg.Get(__reg_section_cdddata, __reg_tag_famlinks);
+		if (!reg_famlinks.empty())
+			famlinks = reg_famlinks.c_str();
+		
+		const string & reg_sparchs = m_reg.Get(__reg_section_cdddata, __reg_tag_sparchs);
+		if (!reg_sparchs.empty())
+			sparchs = reg_sparchs.c_str();
+
+		const string & reg_genarchs = m_reg.Get(__reg_section_cdddata, __reg_tag_genarchs);
+		if (!reg_genarchs.empty())
+			genarchs = reg_genarchs.c_str();
+			
+		double evalcut = AV_EvalCutoff.AsDouble();
+
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Elapsed: " << sw.Elapsed() << ": Before dom_cluster_src::LoadData()" << endl;
+#endif
+// ***********************************************************/
+		
+		COfflDomClusterData dom_cluster_src;
+		
+		try
+		{
+			dom_cluster_src.LoadData(datadir, cddids, spfeats, genfeats, bscores, cdtrack, famlinks);
+		}
+		catch (CSimpleException e)
+		{
+			LOG_POST_X(e_DataFileError, e.GetFile() << ':' << e.GetLine() << ": " << e.what());
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		catch (std::exception e)
+		{
+			LOG_POST_X(e_DataFileError, e.what());
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		catch (...)
+		{
+			LOG_POST_X(e_DataFileError, "Unknown error loading CDD data files");
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Elapsed: " << sw.Elapsed() << ": After dom_cluster_src::LoadData()" << endl;
+#endif
+// ***********************************************************/
+
+
+		COfflArchData arch_src;
+		
+		try
+		{
+			arch_src.LoadData(datadir, sparchs, genarchs);
+		}
+		catch (CSimpleException e)
+		{
+			LOG_POST_X(e_DataFileError, e.GetFile() << ':' << e.GetLine() << ": " << e.what());
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		catch (std::exception e)
+		{
+			LOG_POST_X(e_DataFileError, e.what());
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		catch (...)
+		{
+			LOG_POST_X(e_DataFileError, "Unknown error loading Architecture data files");
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Elapsed: " << sw.Elapsed() << ": After arch_src::LoadData()" << endl;
+#endif
+// ***********************************************************/
+
+		
+		COfflCdAlignProcessor proc(&dom_cluster_src);
+		
+		CCombFileBuf in_files;
+		//CCombIstream in_files(ios::in | ios::binary);
+		
+		if (AV_InList.HasValue())
+		{
+			string inlist = AV_InList.AsString();
+			CFile infname(inlist);
+			if (infname.Exists())
+			{
+				string buf;
+				ifstream lsfile(infname.GetPath().c_str());
+				while (lsfile.good())
+				{
+					buf.clear();
+					getline(lsfile, buf);
+					if (!buf.empty())
+					{
+						infname.Reset(buf);
+
+
+						if (infname.Exists())
+							in_files.AppendFile(buf);
+					}
+				}
+			}
+		}
+		
+		// -- check extra files
+		size_t extrafiles = args.GetNExtra();
+
+		if (extrafiles > 0)
+		{
+			CFile infname;
+			for (size_t i = 1; i <= extrafiles; ++i)
+			{
+				const string & exfile = args[i].AsString();
+				if (!exfile.empty())
+				{
+					infname.Reset(exfile);
+					if (infname.Exists())
+					{
+						in_files.AppendFile(exfile);
+					}
+				}
+			}
+		}
+		
+		ostream * data_out = &cout;
+
+		
+		if (AV_OutFile.HasValue())
+		{
+			const string & ofilename = AV_OutFile.AsString();
+			m_outfile.open(ofilename.c_str(), ios::binary | ios::app);
+			if (m_outfile.good())
+			{
+		
+				data_out = &m_outfile;
+			}
+			else
+				cerr << "Output file " << ofilename << " open failure. Direct to stdout" << endl;
+		}
+		
+		CGXMLRef xroot(new CGXMLNode("NameAssignment"));
+		
+		if (in_files.NLeft() > 0)	//has files, process data from file
+		{
+			istream *data_in = in_files.OpenStream();
+			ProcessBlastOut(*data_in, evalcut, proc, dom_cluster_src, arch_src, namesrc_cfd, xroot);
+			//string infile;
+			//istream * data_in = in_files.Next(infile);
+			//while (!infile.empty())
+			//{
+			//	if (nullptr != data_in)
+			//		ProcessBlastOut(*data_in, evalcut, proc, dom_cluster_src, arch_src, namesrc_cfd, xroot);
+			//	data_in = in_files.Next(infile);
+			//}
+		}
+		else
+			ProcessBlastOut(cin, evalcut, proc, dom_cluster_src, arch_src, namesrc_cfd, xroot);
+			
+		CGXMLDoc xdoc(xroot);
+		xdoc.DTDURI = "http://www.ncbi.nlm.nih.gov/gpipe/protein_naming/cluster_assignment.dtd";
+		xdoc.Print(*data_out, 0);
+		(*data_out) << endl;
+	}
+	else
+	{
+		LOG_POST_X(e_DataFileError, "Data file directory " << datadir << " does not exist or unaccessible");
+		retVal = e_DataFileError;
+		goto labelReturn;
+	}
+
+		
+labelReturn:
+	
+	return retVal;
+}
+
+
+int CSparcLabelApp::DryRun(void)
+{
+
+	int retVal = 0;
+	const CArgs & args = GetArgs();
+	
+	const CArgValue
+		&AV_InList = args[dimValidArgs[argListIn].name],
+		&AV_OutFile = args[dimValidArgs[argOutFile].name],
+		&AV_EvalCutoff = args[dimValidArgs[argEVCutoff].name],
+		&AV_DataDir = args[dimValidArgs[argDataDir].name],
+		&AV_PrecedenceFile = args[dimValidArgs[argPrecedenceFile].name];
+	
+	
+	string datadir = m_bin_loc + "/" + __default_datadir;
+	
+	if (AV_DataDir.HasValue())
+		datadir = AV_DataDir.AsString();
+	else
+	{
+		const string & dataloc = m_reg.Get(__reg_section_cdddata, __reg_tag_datadir);
+		if (!dataloc.empty())
+			datadir = dataloc;
+	}
+	if (CDir(datadir).Exists())
+	{
+		// -- check if procedence definition file provided
+		
+		const char
+			*cddids = nullptr,
+			*bscores = nullptr,
+			*spfeats = nullptr,
+			*genfeats = nullptr,
+			*cdtrack = nullptr,
+			*famlinks = nullptr,
+			*sparchs = nullptr,
+			*genarchs = nullptr,
+			*namesrc = __name_src_file;
+			
+		const string &reg_namesrc = m_reg.Get(__reg_section_cdddata, __reg_tag_namesrc);
+		if (!reg_namesrc.empty())
+			namesrc = reg_namesrc.c_str();
+		
+		
+		TReviewLevel2Precedence namesrc_cfd;
+		
+		int rcode = LoadPrecedenceMapFiles((datadir + "/" + namesrc).c_str(), AV_PrecedenceFile.AsString().c_str(), namesrc_cfd);
+		
+		if (rcode > 0) return rcode;
+		
+			
+		const string & reg_cddids = m_reg.Get(__reg_section_cdddata, __reg_tag_cddids);
+
+		if (!reg_cddids.empty())
+			cddids = reg_cddids.c_str();
+		
+		const string & reg_bscores = m_reg.Get(__reg_section_cdddata, __reg_tag_bscores);
+		if (!reg_bscores.empty())
+			bscores = reg_bscores.c_str();
+		
+		const string & reg_spfeats = m_reg.Get(__reg_section_cdddata, __reg_tag_spfeats);
+		if (!reg_spfeats.empty())
+			spfeats = reg_spfeats.c_str();
+		
+		const string & reg_genfeats = m_reg.Get(__reg_section_cdddata, __reg_tag_genfeats);
+		if (!reg_genfeats.empty())
+			genfeats = reg_genfeats.c_str();
+		
+		const string & reg_cdtrack = m_reg.Get(__reg_section_cdddata, __reg_tag_cdtrack);
+		if (!reg_cdtrack.empty())
+			cdtrack = reg_cdtrack.c_str();
+		
+		const string & reg_famlinks = m_reg.Get(__reg_section_cdddata, __reg_tag_famlinks);
+		if (!reg_famlinks.empty())
+			famlinks = reg_famlinks.c_str();
+		
+		const string & reg_sparchs = m_reg.Get(__reg_section_cdddata, __reg_tag_sparchs);
+		if (!reg_sparchs.empty())
+			sparchs = reg_sparchs.c_str();
+
+		const string & reg_genarchs = m_reg.Get(__reg_section_cdddata, __reg_tag_genarchs);
+		if (!reg_genarchs.empty())
+			genarchs = reg_genarchs.c_str();
+			
+		double evalcut = AV_EvalCutoff.AsDouble();
+
+		
+		COfflDomClusterData dom_cluster_src;
+		
+		try
+		{
+			dom_cluster_src.LoadData(datadir, cddids, spfeats, genfeats, bscores, cdtrack, famlinks);
+		}
+		catch (CSimpleException e)
+		{
+			LOG_POST_X(e_DataFileError, e.GetFile() << ':' << e.GetLine() << ": " << e.what());
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		catch (std::exception e)
+		{
+			LOG_POST_X(e_DataFileError, e.what());
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		catch (...)
+		{
+			LOG_POST_X(e_DataFileError, "Unknown error loading CDD data files");
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+
+
+		COfflArchData arch_src;
+		
+		try
+		{
+			arch_src.LoadData(datadir, sparchs, genarchs);
+		}
+		catch (CSimpleException e)
+		{
+			LOG_POST_X(e_DataFileError, e.GetFile() << ':' << e.GetLine() << ": " << e.what());
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		catch (std::exception e)
+		{
+			LOG_POST_X(e_DataFileError, e.what());
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		catch (...)
+		{
+			LOG_POST_X(e_DataFileError, "Unknown error loading Architecture data files");
+			retVal = e_DataFileError;
+			goto labelReturn;
+		}
+		cerr << "Dryrun passed, all resources are present and loaded successfully." << endl;
+	}
+	else
+	{
+		LOG_POST_X(e_DataFileError, "Data file directory " << datadir << " does not exist or unaccessible");
+		retVal = e_DataFileError;
+		goto labelReturn;
+	}
+
+		
+labelReturn:
+	
+	return retVal;
+}
+
+void CSparcLabelApp::Exit(void)
+{
+	// -- last
+	CNcbiApplication::Exit();
+}
+
+CSparcLabelApp::~CSparcLabelApp(void)
+{}
+
+int main(int argc, char * argv[])
+{
+	bin_name = CDirEntry::CreateAbsolutePath(argv[0], CDirEntry::eRelativeToExe);
+	return CSparcLabelApp().AppMain(argc, argv);
+}
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/normbase.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/normbase.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/normbase.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/normbase.cpp	2018-03-13 14:39:35.178319000 -0400
@@ -0,0 +1,53 @@
+#include "normbase.hpp"
+using namespace std;
+
+//const string k_strEmptyString("");
+const string & GetEmptyString(void)
+{
+	static const string EmptyStdString("");
+	return EmptyStdString;
+}
+
+//const wstring k_strEmptyWString(L"");
+const wstring & GetEmptyWString(void)
+{
+	static const wstring EmptyStdWString(L"");
+	return EmptyStdWString;
+}
+
+
+CSimpleException::CSimpleException(const string &f, int l, const string &m) noexcept:
+	exception(),
+	m_msg(m), m_file(f), m_line(l)
+{}
+
+CSimpleException::CSimpleException(const string &f, int l, string &&m) noexcept:
+	exception(),
+	m_msg(move(m)), m_file(f), m_line(l)
+{}
+
+CSimpleException::CSimpleException(const std::string &f, int l, const std::stringstream &ss) noexcept:
+	exception(),
+	m_msg(ss.str()), m_file(f), m_line(l)
+{}
+
+const char* CSimpleException::what() const noexcept
+{
+	return m_msg.c_str();
+}
+
+void CSimpleException::Print(ostream &os) const noexcept
+{
+	try
+	{
+		os << m_file << ':' << m_line << "; " << m_msg << endl;
+	}
+	catch (...)
+	{;}
+}
+
+ostream & operator << (ostream &os, const CSimpleException &e)
+{
+	e.Print(os);
+	return os;
+}
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/normbase.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/normbase.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/normbase.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/normbase.hpp	2018-03-13 14:39:35.201390000 -0400
@@ -0,0 +1,150 @@
+#if !defined(__NORM_BASE__)
+#define __NORM_BASE__
+
+#include <exception>
+#include <iostream>
+#include <string>
+#include <sstream>
+/**********************************************************************
+*	Some basic numeric definitions
+**********************************************************************/
+constexpr const long double PI = 3.1415926535898L;
+//constexpr const double k_dDec2RadFact = ((double)2.0) * PI / (double)360;
+//constexpr const unsigned int k_uiUnsignedLimit = ~(unsigned int)0;
+//constexpr const int k_iIntUpperLimit = (int)(k_uiUnsignedLimit >> 1);
+//constexpr const int k_iIntLowerLimit = - k_iIntUpperLimit - 1;
+//constexpr const size_t k_sztUpperLimit = ~(size_t)0;
+
+constexpr const double k_RAD_PER_DEG = ((double)2.0) * PI / (double)360;
+constexpr const unsigned int k_UINT_MAX = ~(unsigned int)0;
+constexpr const int k_INT_MAX = (int)(k_UINT_MAX >> 1);
+constexpr const int k_INT_MIN = - k_INT_MAX - 1;
+constexpr const size_t k_SIZE_MAX = ~(size_t)0;
+
+
+#define BoolAlpha(a) (a ? "true" : "false")
+
+/**********************************************************************
+*	Detect and define fixed-width types
+**********************************************************************/
+typedef unsigned char BYTE;	//assume 8 
+
+// -- take sizeof(short), sizeof(int) sizeof(long)
+template<size_t, size_t, size_t>
+struct TWordSizeDef;
+
+template<>
+struct TWordSizeDef<1, 2, 2>
+{
+	typedef int INT16;
+	typedef long long INT32;
+	typedef long long INT64;	//no way doing 64 bit, just define the same as 32bit
+	typedef unsigned int UINT16;
+	typedef unsigned long long UINT32;
+	typedef unsigned long long UINT64;
+};
+
+template<>
+struct TWordSizeDef<1, 2, 4>
+{
+	typedef int INT16;
+	typedef long INT32;
+	typedef long long INT64;
+	typedef unsigned int UINT16;
+	typedef unsigned long UINT32;
+	typedef unsigned long long UINT64;
+};
+
+template<>
+struct TWordSizeDef<2, 2, 4>
+{
+	typedef int INT16;
+	typedef long INT32;
+	typedef long long INT64;
+	typedef unsigned int UINT16;
+	typedef unsigned long UINT32;
+	typedef unsigned long long UINT64;
+};
+
+template<>
+struct TWordSizeDef<2, 4, 4>
+{
+	typedef short INT16;
+	typedef int INT32;
+	typedef long long INT64;
+	typedef unsigned short UINT16;
+	typedef unsigned int UINT32;
+	typedef unsigned long long UINT64;
+};
+
+template<>
+struct TWordSizeDef<2, 4, 8>
+{
+	typedef short INT16;
+	typedef int INT32;
+	typedef long INT64;
+	typedef unsigned short UINT16;
+	typedef unsigned int UINT32;
+	typedef unsigned long UINT64;
+};
+
+typedef TWordSizeDef<sizeof(short), sizeof(int), sizeof(long)> TMachineWords;
+
+typedef TMachineWords :: INT16 INT16;
+typedef TMachineWords :: INT32 INT32;
+typedef TMachineWords :: UINT16 UINT16;
+typedef TMachineWords :: UINT32 UINT32;
+typedef TMachineWords :: INT64 INT64;
+typedef TMachineWords :: UINT64 UINT64;
+
+
+/**********************************************************************
+*	Empty string reference
+**********************************************************************/
+const std::string & GetEmptyString(void);
+#define k_strEmptyString GetEmptyString()
+//extern const std::string k_strEmptyString;
+const std::wstring & GetEmptyWString(void);
+#define k_strEmptyWString GetEmptyWString()
+
+/**********************************************************************
+*	Define exception class
+class exception
+{
+public:
+  exception () noexcept;
+  exception (const exception&) noexcept;
+  exception& operator= (const exception&) noexcept;
+  virtual ~exception();
+  virtual const char* what() const noexcept;
+};
+
+usage:
+	throw CSimpleException(__FILE__, __LINE__, "Parse error!");
+**********************************************************************/
+
+class CSimpleException: public std::exception
+{
+public:
+	CSimpleException(const std::string &f, int l, const std::string &m) noexcept;
+	CSimpleException(const std::string &f, int l, std::string &&m) noexcept;
+	CSimpleException(const std::string &f, int l, const std::stringstream &ss) noexcept;
+	void Print(std::ostream &os) const noexcept;
+	virtual const char* what() const noexcept;
+	const std::string & GetFile(void) const {return m_file;}
+	const int GetLine(void) const {return m_line;}
+private:
+	std::string m_msg;
+	std::string m_file;	//__FILE__
+	int m_line;	//__LINE__
+};
+
+std::ostream & operator << (std::ostream &os, const CSimpleException &e);
+
+#define THROW_SIMPLE(a) throw CSimpleException(__FILE__, __LINE__, dynamic_cast<stringstream& > (stringstream() << a))
+
+
+#endif
+
+
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/objutils.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/objutils.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/objutils.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/objutils.cpp	2018-03-13 14:39:35.456243000 -0400
@@ -0,0 +1,28 @@
+#include "objutils.hpp"
+#include <objects/general/general__.hpp>
+#include <objects/seqloc/seqloc__.hpp>
+USING_NCBI_SCOPE;
+using namespace objects;
+
+void CObjectIdWriteHooker::WriteChoiceVariant(CObjectOStream& os, const CConstObjectInfoCV& variant)
+{
+	//const CObject_id& objid = *CType<CObject_id>::Get(variant.GetVariant().GetPointedObject());
+	const CObject_id& objid = *reinterpret_cast<const CObject_id*> (variant.GetVariant().GetObjectPtr());
+	if (objid.Which() == CObject_id::e_Id)
+	{
+		char dimBuf[16];
+		sprintf(dimBuf, "%d", objid.GetId());
+		
+		CObject_id rep_id;
+		rep_id.SetStr(dimBuf);
+		
+		//const ncbi::CTypeInfo* typeInfo = ObjectInfo(rep_id);
+		
+		
+		//CConstObjectInfoCV infoCV(ObjectInfo(rep_id));
+		os.WriteObject(ObjectInfo(rep_id));
+		//DefaultWrite(os, infoCV);
+		//os << rep_id;
+	}
+	else DefaultWrite(os, variant);
+}
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/objutils.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/objutils.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/objutils.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/objutils.hpp	2018-03-13 14:39:35.461700000 -0400
@@ -0,0 +1,158 @@
+#if !defined(__OBJ_UTILS__)
+#define __OBJ_UTILS__
+#include "envdef.hpp"
+#include <objects/general/general__.hpp>
+#include <objects/seqloc/seqloc__.hpp>
+#include <serial/objhook.hpp>
+#include <serial/objistr.hpp>
+#include <serial/objistrasn.hpp>
+#include <serial/objistrasnb.hpp>
+#include <serial/objistrjson.hpp>
+#include <serial/objistrxml.hpp>
+#include <serial/objostr.hpp>
+#include <serial/objostrasn.hpp>
+#include <serial/objostrasnb.hpp>
+#include <serial/objostrjson.hpp>
+#include <serial/objostrxml.hpp>
+#include <serial/objhook.hpp>
+#include <serial/serial.hpp>
+
+/***********************************************************************************************************************
+//	this is to convert e_Id variant in object id into e_Str variant so that Cn3D 4.1- can work correctly
+************************************************************************************************************************/
+class CObjectIdWriteHooker: public ncbi::CWriteChoiceVariantHook
+{
+	virtual void WriteChoiceVariant(ncbi::CObjectOStream& os, const ncbi::CConstObjectInfoCV& variant);
+};
+
+// *********************************************************************************************************************/
+
+//template<class BioObj> 
+//void ObjStreamOut(ncbi::CNcbiOstream& os, const BioObj& rBioObj, ncbi::ESerialDataFormat eFormat = ncbi::eSerial_AsnText)
+//{
+//  if (ncbi::eSerial_Xml == eFormat)	//Get rid of dtd
+//  {
+//  	ncbi::CObjectOStreamXml os_xml(os, eNoOwnership);
+//  	os_xml.SetReferenceDTD(false);
+//  	ncbi::CObjectTypeInfo(ncbi::objects::CSeq_id::GetTypeInfo()).FindVariant("local").SetLocalWriteHook(os_xml, new CObjectIdWriteHooker);
+//  	os_xml << rBioObj;
+//  }
+//	else
+//	{
+////#if defined(__USING_CENTOS6__)
+//		ncbi::CObjectOStream *pOStream = ncbi::CObjectOStream::Open(eFormat, os, eNoOwnership);
+////#else
+////		ncbi::CObjectOStream *pOStream = ncbi::CObjectOStream::Open(eFormat, os, ncbi::eNoOwnership);
+////#endif
+//		ncbi::CObjectTypeInfo(ncbi::objects::CSeq_id::GetTypeInfo()).FindVariant("local").SetLocalWriteHook(*pOStream, new CObjectIdWriteHooker);
+//		*pOStream << rBioObj;
+//		delete pOStream;
+//	}
+//}
+//
+//template<class BioObj> 
+//void ObjStreamOut(ncbi::CNcbiOstream& os, const BioObj* pBioObj, ncbi::ESerialDataFormat eFormat = ncbi::eSerial_AsnText)
+//{
+//	if (nullptr == pBioObj) return;
+//	
+//	if (ncbi::eSerial_Xml == eFormat)	//Get rid of dtd
+//  {
+////#if defined(__USING_CENTOS6__)
+//    ncbi::CObjectOStreamXml os_xml(os, eNoOwnership);
+////#else
+////		ncbi::CObjectOStreamXml os_xml(os, ncbi::eNoOwnership);
+////#endif
+//   	os_xml.SetReferenceDTD(false);
+//   	ncbi::CObjectTypeInfo(ncbi::objects::CSeq_id::GetTypeInfo()).FindVariant("local").SetLocalWriteHook(os_xml, new CObjectIdWriteHooker);
+//   	os_xml << (*pBioObj);
+//  }
+//	else
+//	{
+////#if defined(__USING_CENTOS6__)
+//		ncbi::CObjectOStream *pOStream = ncbi::CObjectOStream::Open(eFormat, os, eNoOwnership);
+////#else
+////		ncbi::CObjectOStream *pOStream = ncbi::CObjectOStream::Open(eFormat, os, ncbi::eNoOwnership);
+////#endif
+//		ncbi::CObjectTypeInfo(ncbi::objects::CSeq_id::GetTypeInfo()).FindVariant("local").SetLocalWriteHook(*pOStream, new CObjectIdWriteHooker);
+//		*pOStream << (*pBioObj);
+//		delete pOStream;
+//	}
+//}
+
+template<class BioObj> 
+void ObjStreamOut(ncbi::CNcbiOstream& os, const BioObj& rBioObj, ncbi::ESerialDataFormat eFormat = ncbi::eSerial_AsnText)
+{
+	ncbi::CObjectOStream *pOStream = ncbi::CObjectOStream::Open(eFormat, os, eNoOwnership);
+	
+	if (ncbi::eSerial_Xml == eFormat)	//Get rid of dtd
+  {
+  	ncbi::CObjectOStreamXml *p_os_xml = dynamic_cast< ncbi::CObjectOStreamXml* > (pOStream);
+  	if (nullptr != p_os_xml)
+  		p_os_xml->SetReferenceDTD(false);
+  }
+	
+	ncbi::CObjectTypeInfo(ncbi::objects::CSeq_id::GetTypeInfo()).FindVariant("local").SetLocalWriteHook(*pOStream, new CObjectIdWriteHooker);
+	*pOStream << rBioObj;
+	delete pOStream;
+}
+
+template<class BioObj> 
+void ObjStreamOut(ncbi::CNcbiOstream& os, const BioObj* pBioObj, ncbi::ESerialDataFormat eFormat = ncbi::eSerial_AsnText)
+{
+	if (nullptr == pBioObj) return;
+	
+	ncbi::CObjectOStream *pOStream = ncbi::CObjectOStream::Open(eFormat, os, eNoOwnership);
+	
+	if (ncbi::eSerial_Xml == eFormat)	//Get rid of dtd
+  {
+  	ncbi::CObjectOStreamXml *p_os_xml = dynamic_cast< ncbi::CObjectOStreamXml* > (pOStream);
+  	if (nullptr != p_os_xml)
+  		p_os_xml->SetReferenceDTD(false);
+  }
+	
+	ncbi::CObjectTypeInfo(ncbi::objects::CSeq_id::GetTypeInfo()).FindVariant("local").SetLocalWriteHook(*pOStream, new CObjectIdWriteHooker);
+	*pOStream << (*pBioObj);
+	delete pOStream;
+}
+
+
+
+template<class BioObj> 
+void ObjStreamIn(ncbi::CNcbiIstream& is, BioObj& rBioObj, ncbi::ESerialDataFormat eFormat = ncbi::eSerial_AsnText)
+{
+//#if defined(__USING_CENTOS6__)
+	ncbi::CObjectIStream *pIStream = ncbi::CObjectIStream::Open(eFormat, is, eNoOwnership);
+//#else
+//	ncbi::CObjectIStream *pIStream = ncbi::CObjectIStream::Open(eFormat, is, ncbi::eNoOwnership);
+//#endif
+
+	*pIStream >> rBioObj;
+	//pIStream->Read(ObjectInfo(rBioObj));
+	delete pIStream;
+}
+
+template<class BioObj> 
+BioObj* ObjStreamIn(ncbi::CNcbiIstream& is, BioObj* pBioObj = nullptr, ncbi::ESerialDataFormat eFormat = ncbi::eSerial_AsnText)
+{
+	BioObj* pEffective = pBioObj ? pBioObj : new BioObj();
+//#if defined(__USING_CENTOS6__)
+	ncbi::CObjectIStream *pIStream = ncbi::CObjectIStream::Open(eFormat, is, eNoOwnership);
+//#else
+//	ncbi::CObjectIStream *pIStream = ncbi::CObjectIStream::Open(eFormat, is, ncbi::eNoOwnership);
+//#endif
+
+	*pIStream >> (*pEffective);
+	//pIStream->Read(ObjectInfo(rBioObj));
+	delete pIStream;
+	return pEffective;
+}
+
+template<class BioObj>
+std::string GetString(const BioObj& rBioObj)
+{
+	std::stringstream ss;
+	ObjStreamOut<BioObj> (ss, rBioObj);
+	return ss.str();
+}
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offl_cd_align_proc.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offl_cd_align_proc.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offl_cd_align_proc.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offl_cd_align_proc.cpp	2018-03-13 14:39:35.385121000 -0400
@@ -0,0 +1,281 @@
+#include "offl_cd_align_proc.hpp"
+//#include "basicutils.hpp"
+//#if defined(__BLAST_XML2__)
+//#include <objects/blastxml2/blastxml2__.hpp>
+//#else
+//#include <objects/blastxml/blastxml__.hpp>
+//#endif
+#include <objects/seq/seq__.hpp>
+#include <corelib/ncbistr.hpp>
+#include <corelib/ncbifile.hpp>
+
+USING_NCBI_SCOPE;
+using namespace objects;
+
+void _TOfflDomQuery::NACommit(void)
+{
+	m_iMolType = CSeq_inst::eMol_na;
+	SeqLen_t aaLen = m_uiSeqLen / 3;
+	
+	m_dimTranslated[0].clear();
+	m_dimTranslated[0].append(aaLen, '-');
+	
+	m_dimTranslated[3] = m_dimTranslated[0];
+	
+	aaLen = (m_uiSeqLen - 1) / 3;
+	
+	m_dimTranslated[1].clear();
+	m_dimTranslated[1].append(aaLen, '-');
+	
+	m_dimTranslated[4] = m_dimTranslated[1];
+	
+	aaLen = (m_uiSeqLen - 2) / 3;
+	
+	m_dimTranslated[2].clear();
+	m_dimTranslated[2].append(aaLen, '-');
+	m_dimTranslated[5] = m_dimTranslated[2];
+}
+
+void _TOfflDomQuery::PRCommit(void)
+{
+	m_iMolType = CSeq_inst::eMol_aa;
+	m_dimTranslated[0].clear();
+	m_dimTranslated[0].append(m_uiSeqLen, '-');
+}
+
+void _TOfflDomQuery::ParseAlignStrings(const string &qseq, const string &hseq, SeqPos_t qf, SeqPos_t hf, SeqPos_t start, SeqLen_t n, TDomSeqAlignment &dst, int rfidx)
+{
+	SeqLen_t segLen = 0;
+	bool bEffSeg = true;
+
+	while (start < n)
+	{
+
+		if (bEffSeg)	//initially, both chains are in effect
+		{
+			if ('-' != qseq[start] && '-' != hseq[start])
+				++segLen;
+			else
+			{
+
+				bEffSeg = false;
+				
+				dst.m_vecMStarts.push_back(qf);
+				dst.m_vecSStarts.push_back(hf);
+				dst.m_vecLens.push_back(segLen);
+				
+				// -- write in master sequence data
+				m_dimTranslated[rfidx].replace(qf, segLen, qseq, start - segLen, segLen);
+				
+				qf += segLen;
+				hf += segLen;
+				segLen = 0;
+				if ('-' == qseq[start])
+					--qf;
+				else
+				{
+					--hf;
+					//write in one more residue
+					m_dimTranslated[rfidx][qf] = qseq[start];
+				}
+			}
+		}
+		else	//not in effective seg
+		{
+			//!bEffSeg
+			bool segStart = true;
+			if ('-' != qseq[start])
+			{
+				++qf;
+				m_dimTranslated[rfidx][qf] = qseq[start];
+			}
+			else
+				segStart = false;
+				
+			if ('-' != hseq[start])
+				++hf;
+			else
+				segStart = false;
+				
+			if ((bEffSeg = segStart)) ++segLen;
+			
+		}
+			
+		++start;
+	}//while
+	// -- last segment
+	if (bEffSeg && segLen > 0)
+	{
+
+		dst.m_vecMStarts.push_back(qf);
+		dst.m_vecSStarts.push_back(hf);
+		dst.m_vecLens.push_back(segLen);
+		
+		m_dimTranslated[rfidx].replace(qf, segLen, qseq, start - segLen, segLen);
+	}
+}
+
+
+void COfflCdAlignProcessor::ParseBlastOutput(_TOfflDomQuery &dst, const CIteration &blastout, vector<PssmId_t> &missed, double evcut) const
+{
+	dst.m_vecAlignments.clear();
+	
+	if (blastout.CanGetQuery_ID())
+		dst.m_strCleanedInput = blastout.GetQuery_ID();
+	
+	if (blastout.CanGetQuery_def())
+		dst.m_strTitle = blastout.GetQuery_def();	//length of original sequence, could be na
+	
+	if (blastout.CanGetQuery_len())
+		dst.m_uiSeqLen = blastout.GetQuery_len();	//length of original sequence, could be na
+		
+	
+	if (blastout.CanGetMessage())
+		dst.m_strMessage = blastout.GetMessage();	//length of original sequence, could be na
+		
+	if (blastout.CanGetHits())
+	{
+		const CIteration::THits &hits = blastout.GetHits();	//list< CRef< CHit > >
+		if (!hits.empty())
+		{
+			dst.m_vecAlignments.reserve(hits.size() * 3);	//estimated
+			
+			TDomSeqAlignment alnVal;
+			
+			for (CIteration::THits::const_iterator iterHit = hits.begin(), iterHitEnd = hits.end(); iterHitEnd != iterHit; ++iterHit)
+			{
+				PssmId_t pssmid = (unsigned int)atoi((*iterHit)->GetAccession().c_str());
+				
+				SeqLen_t cdLen = (*iterHit)->GetLen();
+				const CHit::THsps &hsps = (*iterHit)->GetHsps();	//list< CRef< CHsp > > THsps
+				for (CHit::THsps::const_iterator iterHsp = hsps.begin(), iterHspEnd = hsps.end(); iterHspEnd != iterHsp; ++iterHsp)
+				{
+					double eval = (*iterHsp)->GetEvalue();
+					if (eval > evcut) continue;
+					
+					dst.m_vecAlignments.push_back(alnVal);
+					TDomSeqAlignment &currAlign = *dst.m_vecAlignments.rbegin();
+					
+					currAlign.m_uiPssmId = pssmid;
+					currAlign.m_uiAlignedLen = (*iterHsp)->GetAlign_len();
+					currAlign.m_iScore = (int)((*iterHsp)->GetScore() + 0.5);
+					currAlign.m_dEValue = eval;
+					currAlign.m_dBitScore = (*iterHsp)->GetBit_score();
+					currAlign.m_iNumIdent = (*iterHsp)->GetIdentity();
+					currAlign.m_dSeqIdentity = (double)currAlign.m_iNumIdent / (double)cdLen * 100.0;
+					currAlign.m_iReadingFrame = (*iterHsp)->GetQuery_frame();
+					
+					if (currAlign.m_iReadingFrame > 1 || currAlign.m_iReadingFrame < 0)	//na determined
+					{
+						if (dst.m_dimTranslated[0].empty())	//not filled yet
+							dst.NACommit();
+					}
+					
+					
+					currAlign.m_iFrom = (*iterHsp)->GetQuery_from() - COORDSBASE;
+					currAlign.m_iTo = (*iterHsp)->GetQuery_to() - COORDSBASE;
+
+					// -- start to parse sequence
+					const string &qseq = (*iterHsp)->GetQseq(), hseq = (*iterHsp)->GetHseq();
+					size_t alnLen = qseq.size(), alnResIdx = 0;	//assume qseq.size() == hseq.size()
+
+					// -- incase of blast problem...
+					// -- trim unaligned regions from beginning
+					while (alnResIdx < alnLen && ('-' == qseq[alnResIdx] || '-' == hseq[alnResIdx])) ++alnResIdx;
+					
+					// -- see if NA
+					if (dst.m_dimTranslated[0].empty())	//not filled yet
+					{
+						SeqLen_t aaRes = 0;
+						SeqPos_t t0 = alnResIdx;
+						
+						while (t0 < alnLen)
+						{
+							if ('-' == qseq[t0])
+								++t0;
+							else
+							{
+								size_t t1 = qseq.find('-', t0);
+								if (string::npos == t1)	//
+									t1 = alnLen;
+								aaRes += t1 - t0;
+								t0 = t1 + 1;
+							}
+						}
+						if (aaRes == currAlign.m_iTo - currAlign.m_iFrom + 1)
+							dst.PRCommit();
+						else if (aaRes * 3 == currAlign.m_iTo - currAlign.m_iFrom + 1)
+							dst.NACommit();
+					}
+					if (dst.m_iMolType == CSeq_inst::eMol_aa)
+					{
+						currAlign.m_iReadingFrame = 0;	//0 is invalid for real reading frames, but a sign for protein sequence
+						currAlign.m_eAlignType = TSeqAlignment::eNormal;
+						currAlign.m_eStrand = eNa_strand_unknown;
+						SeqPos_t qfrom = currAlign.m_iFrom, hfrom = (*iterHsp)->GetHit_from() - COORDSBASE;
+						
+						dst.ParseAlignStrings(qseq, hseq, qfrom, hfrom, alnResIdx, alnLen, currAlign, 0);
+					}
+					else if (dst.m_iMolType == CSeq_inst::eMol_na)	//na
+					{
+						// -- calculate 
+						int rfidx = READINGFRAME::IndexOf(currAlign.m_iReadingFrame);
+						currAlign.m_eAlignType = TSeqAlignment::ePr2Na;
+
+						if (currAlign.m_iReadingFrame > 0)	//plus
+						{
+							currAlign.m_eStrand = eNa_strand_plus;
+							//currAlign.m_iReadingFrame -= 1;	//from 1, 2, 3 to 0, 1 ,2
+							
+							SeqPos_t qfrom = READINGFRAME::NA2Pr(currAlign.m_iFrom, currAlign.m_iReadingFrame, dst.m_uiSeqLen),
+								hfrom = (*iterHsp)->GetHit_from() - COORDSBASE;
+							
+							//SeqPos_t qfrom = currAlign.NAPlus2Pr(currAlign.m_iFrom), 
+
+							dst.ParseAlignStrings(qseq, hseq, qfrom, hfrom, alnResIdx, alnLen, currAlign, rfidx);
+
+						}	//plus strand
+						else	//minus strand
+						{
+							currAlign.m_eStrand = eNa_strand_minus;
+							// -- squeeze m_uiSeqLen in currAlign.m_iReadingFrame, rf -1, -2, -3 -> 0, 1, 2
+							//currAlign.m_iReadingFrame = (-currAlign.m_iReadingFrame - 1) | (m_uiSeqLen << 2);
+							int qfrom = READINGFRAME::NA2Pr(currAlign.m_iTo, currAlign.m_iReadingFrame, dst.m_uiSeqLen),
+								hfrom = (*iterHsp)->GetHit_from() - COORDSBASE;
+
+							dst.ParseAlignStrings(qseq, hseq, qfrom, hfrom, alnResIdx, alnLen, currAlign, rfidx);
+						}
+					}
+					else
+						throw CSimpleException(__FILE__, __LINE__, "Unable to determine sequence type (protein or nucleotide)");
+				}
+			}
+			
+			// -- calculate
+			if (!dst.m_vecAlignments.empty())
+			{
+				size_t ttlAligns = dst.m_vecAlignments.size();
+				if (CSeq_inst::eMol_aa == dst.m_iMolType)	//protein
+				{
+					vector<size_t> ttlIndice;
+					ttlIndice.reserve(ttlAligns);
+					for (size_t i = 0; i < ttlAligns; ++i)
+						ttlIndice.push_back(i);
+					Calculate(dst.m_vecAlignments, ttlIndice, dst.m_dimSplitAligns[0], missed);
+				}
+				else
+				{
+					vector<size_t> rfIndice[READINGFRAME::TOTAL_RFS];
+					for (size_t i = 0; i < READINGFRAME::TOTAL_RFS; ++i)
+						rfIndice[i].reserve(ttlAligns);
+						
+					SortReadingFrames(rfIndice, dst);
+					
+					for (size_t i = 0; i < READINGFRAME::TOTAL_RFS; ++i)
+						Calculate(dst.m_vecAlignments, rfIndice[i], dst.m_dimSplitAligns[i], missed);
+				}
+			}
+		}
+	}
+}
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offl_cd_align_proc.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offl_cd_align_proc.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offl_cd_align_proc.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offl_cd_align_proc.hpp	2018-03-13 14:39:35.390893000 -0400
@@ -0,0 +1,69 @@
+#if !defined(__OFFL_CD_ALIGN_PROC__)
+#define __OFFL_CD_ALIGN_PROC__
+
+#include "cdalignproc_base.hpp"
+#if defined(__DB_OFFLINE__)
+//#include "objutils.hpp"
+#include "compactstore.hpp"
+#include "ptrmap.hpp"
+#else
+//#include <NcbiBase/objutils.hpp>
+#include <BasicUtils/compactstore.hpp>
+#include <BasicUtils/ptrmap.hpp>
+#endif
+#include <objects/blastxml/blastxml__.hpp>
+
+/*****************************************************
+*	Blastoutput can have the following information
+******************************************************
+*	typedef string TProgram;
+*	typedef string TVersion;
+*	typedef string TReference;
+*	typedef string TDb;
+*	typedef string TQuery_ID;
+*	typedef string TQuery_def;
+*	typedef int TQuery_len;
+*	typedef string TQuery_seq;
+*	typedef CParameters TParam;
+*		typedef string TMatrix;
+*		typedef double TExpect;
+*		typedef double TInclude;
+*		typedef int TSc_match;
+*		typedef int TSc_mismatch;
+*		typedef int TGap_open;
+*		typedef int TGap_extend;
+*		typedef string TFilter;
+*		typedef string TPattern;
+*		typedef string TEntrez_query;
+*	typedef list< CRef< CIteration > > TIterations;
+*	typedef CStatistics TMbstat;
+// **************************************************/
+
+struct _TOfflDomQuery: public TDomQuery
+{
+	_TOfflDomQuery(void):
+		TDomQuery(),
+		m_strMessage(), m_dimTranslated() {};
+	void ParseAlignStrings(const std::string &qseq, const std::string &hseq, SeqPos_t qf, SeqPos_t hf, SeqPos_t start, SeqLen_t n, TDomSeqAlignment &dst, int rfidx = 0);
+	
+	std::string m_strMessage;
+	std::string m_dimTranslated[READINGFRAME::TOTAL_RFS];
+	// -- internals
+	void NACommit(void);
+	void PRCommit(void);
+};
+
+
+
+class COfflCdAlignProcessor: public CCdAlignProcessor
+{
+public:
+	static constexpr const SeqPos_t COORDSBASE = 1;
+	COfflCdAlignProcessor(const TDomClusterIndexIfx *dom_src) : CCdAlignProcessor(dom_src) {};
+	void ParseBlastOutput(_TOfflDomQuery &dst, const ncbi::objects::CIteration &blastout, std::vector<PssmId_t> &missed, double evcut = 0.01) const;
+};
+
+
+
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offl_sparcle_data.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offl_sparcle_data.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offl_sparcle_data.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offl_sparcle_data.cpp	2018-03-13 14:39:35.397635000 -0400
@@ -0,0 +1,702 @@
+#include "offl_sparcle_data.hpp"
+#if defined(__DB_OFFLINE__)
+#include "basealgo.hpp"
+#else
+#include <BasicUtils/basealgo.hpp>
+#endif
+#include <corelib/ncbifile.hpp>
+#include <fstream>
+#include <iostream>
+
+USING_NCBI_SCOPE;
+void COfflDomClusterData::Reset(void)
+{
+	CDomClusterIndex::Reset();
+	m_CDStore.Reset();
+	m_ClusterStore.Reset();
+}
+
+void COfflDomClusterData::Reset(bool mem_realloc, const std::string &datadir, const char *cddids, const char *spfeats, const char *genfeats, const char *bscores, const char *cdtrack, const char *famlinks)
+{
+	if (mem_realloc)
+		Reset();
+	else
+	{
+		CDomClusterIndex::Reset();
+		m_CDStore.Clear();
+		m_ClusterStore.Clear();
+	}
+	LoadData(datadir, cddids, spfeats, genfeats, bscores, cdtrack, famlinks);
+}
+
+void COfflDomClusterData::Reset(bool mem_realloc, const std::string &cddids, const std::string &spfeats, const std::string &genfeats, const std::string &bscores, const std::string &cdtrack, const std::string &famlinks)
+{
+	if (mem_realloc)
+		Reset();
+	else
+	{
+		CDomClusterIndex::Reset();
+		m_CDStore.Clear();
+		m_ClusterStore.Clear();
+	}
+	LoadData_real(cddids, spfeats, genfeats, bscores, cdtrack, famlinks);
+}
+
+void COfflDomClusterData::LoadData(const std::string &datadir, const char *cddids, const char *spfeats, const char *genfeats, const char *bscores, const char *cdtrack, const char *famlinks)
+{
+	static constexpr const size_t TOTAL_CDS_ESTI = 52000;	//estimated domains
+	static constexpr const size_t TOTAL_CLSTS_ESTI = 6000;
+	if (m_CDStore.IsEmpty())	//not loaded yet, load it
+	{
+		ifstream dfstream;
+		string buf;
+		
+		string
+			_cddids = (cddids ? datadir + "/" + cddids : datadir + "/" + COfflDomClusterData::__cdd_ids_file),
+			_cdtrack = (cdtrack ? datadir + "/" + cdtrack : datadir + "/" + COfflDomClusterData::__cdtrack_file),
+			_famlinks =	(famlinks ? datadir + "/" + famlinks : datadir + "/" + COfflDomClusterData::__domfam_link_file),
+			_spfeats = (spfeats ? datadir + "/" + spfeats : datadir + "/" + COfflDomClusterData::__spec_feats_file),
+			_genfeats = (genfeats ? datadir + "/" + genfeats : datadir + "/" + COfflDomClusterData::__gen_feats_file),
+			_bscores = (bscores ? datadir + "/" + bscores : datadir + "/" + COfflDomClusterData::__bs_thrlds_file);
+			
+		LoadData_real(_cddids, _spfeats, _genfeats, _bscores, _cdtrack, _famlinks);
+	
+	}
+}
+
+void COfflDomClusterData::LoadData_real(const string &cddids, const string &spfeats, const string &genfeats, const string &bscores, const string &cdtrack, const string &famlinks)
+{
+	static constexpr const size_t TOTAL_CDS_ESTI = 52000;	//estimated domains
+	static constexpr const size_t TOTAL_CLSTS_ESTI = 6000;
+	if (m_CDStore.IsEmpty())	//not loaded yet, load it
+	{
+		ifstream dfstream;
+		string buf;
+		
+		CFile srcfile;
+		srcfile.Reset(cddids);
+		
+		if (!srcfile.Exists())
+			throw CSimpleException(__FILE__, __LINE__, "Data file " + srcfile.GetPath() + " does not exist");
+		else
+		{
+
+			// -- cluster search
+			vector< TCluster* > clst_ptrs;
+			clst_ptrs.reserve(TOTAL_CLSTS_ESTI);
+			
+			// -- cd search, exclude sd
+			vector< TDomain* > cd_ptrs;
+			cd_ptrs.reserve(TOTAL_CDS_ESTI);
+			
+			// -- both cd and sd
+			vector< TDomain* > dom_ptrs;
+			dom_ptrs.reserve(TOTAL_CDS_ESTI);
+			
+			dfstream.open(srcfile.GetPath().c_str());
+			
+			while (dfstream.good())
+			{
+				buf.clear();
+				getline(dfstream, buf);
+				LTrimString(buf);
+				if (!buf.empty() && '#' != buf[0])
+				{
+					
+					size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+					//unsigned int pssmid = (unsigned int)atoi(buf.substr(pos0, pos1 - pos0).c_str());
+					PssmId_t pssmid = NStr::StringToNumeric<PssmId_t> (buf.substr(pos0, pos1 - pos0));
+					
+					pos0 = pos1 + 1;
+					pos1 = buf.find('\t', pos0);
+					string tmp(buf.substr(pos0, pos1 - pos0));
+					TrimString(tmp);
+					if (('c' == tmp[0] || 'C' == tmp[0]) && ('l' == tmp[1] || 'L' == tmp[1]) && (tmp[2] >= '0' && tmp[2] <= '9'))	//cluster
+					{
+						// is cluster
+						TCluster * p_clst = m_ClusterStore.Append();
+						p_clst->m_uiPssmId = pssmid;
+						p_clst->m_strAccession = move(tmp);
+						p_clst->m_iClusterId = NStr::StringToNumeric<ClusterId_t> (p_clst->m_strAccession.substr(2));
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);
+						p_clst->m_strShortName = buf.substr(pos0, pos1 - pos0);
+						TrimString(p_clst->m_strShortName);
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);
+						p_clst->m_strDefline = buf.substr(pos0, pos1 - pos0);
+						TrimString(p_clst->m_strDefline);
+						// -- no need -- cluster length is always 0
+						//pos0 = pos1 + 1;
+						//iterClst->second.m_uiLength = NStr::StringToNumeric<unsigned int>(buf.substr(pos0));
+						clst_ptrs.emplace_back(p_clst);
+					}
+					else	//cd
+					{
+						TDomain * p_cd = m_CDStore.Append();
+						p_cd->m_uiPssmId = pssmid;
+						p_cd->m_strAccession = buf.substr(pos0, pos1 - pos0);
+						TrimString(p_cd->m_strAccession);
+						if (isdigit(p_cd->m_strAccession[2]))	//cdxxx, sdxxx or clxxx
+						{
+							if ('d' == p_cd->m_strAccession[1] || 'D' == p_cd->m_strAccession[1])	//cd or sd
+							{
+								if ('c' == p_cd->m_strAccession[0] || 'C' == p_cd->m_strAccession[0])	//curated
+								{
+									p_cd->m_bCurated = true;
+									cd_ptrs.emplace_back(p_cd);
+								}
+									
+								else if ('s' == p_cd->m_strAccession[0] || 'S' == p_cd->m_strAccession[0])	//curated
+									p_cd->m_bIsStructDom = true;
+							}
+						}
+						
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);
+						p_cd->m_strShortName = buf.substr(pos0, pos1 - pos0);
+						TrimString(p_cd->m_strShortName);
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);
+						p_cd->m_strDefline = buf.substr(pos0, pos1 - pos0);
+						TrimString(p_cd->m_strDefline);
+						pos0 = pos1 + 1;
+						string tmp1(buf.substr(pos0));
+						TrimString(tmp1);
+						p_cd->m_uiLength = NStr::StringToNumeric<SeqLen_t> (tmp1);
+						dom_ptrs.emplace_back(p_cd);
+					}
+				}
+			}
+			dfstream.close();
+			
+			// -- now create maps, 
+			clst_ptrs.shrink_to_fit();	//cluster
+			cd_ptrs.shrink_to_fit();	//curated
+			dom_ptrs.shrink_to_fit();	//all domains
+/*debug*******************************************************/
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": cd_ptrs.size() = " << cd_ptrs.size() << ", clst_ptrs.size() = " << clst_ptrs.size() << endl;
+#endif
+// ***********************************************************/
+
+			SetPssmId2CdPtrs(move(dom_ptrs));
+			SetAcxn2CdPtrs(move(cd_ptrs));
+
+
+			SetPssmId2ClusterPtrs(clst_ptrs);
+/*debug*******************************************************/
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": cd_ptrs.size() = " << cd_ptrs.size() << ", clst_ptrs.size() = " << clst_ptrs.size() << endl;
+#endif
+// ***********************************************************/
+			SetClusterId2ClusterPtrs(move(clst_ptrs));
+		}
+		
+		// -- CDTrack information just for parent and root of domains
+		srcfile.Reset(cdtrack);
+		if (!srcfile.Exists())
+			throw CSimpleException(__FILE__, __LINE__, "Data file " + srcfile.GetPath() + " does not exist");
+		else
+		{
+			dfstream.open(srcfile.GetPath().c_str());
+			
+			while (dfstream.good())
+			{
+				buf.clear();
+				getline(dfstream, buf);
+				LTrimString(buf);
+
+				if (!buf.empty() && '#' != buf[0])
+				{
+					// -- accession
+					size_t pos0 = 0, pos1 = buf.find(' ', pos0);
+
+					string currAcc = buf.substr(pos0, pos1 - pos0);
+
+					TrimString(currAcc);
+					
+					// -- title
+					while(buf[pos1] <= ' ') ++pos1;
+					pos0 = pos1;
+					pos1 = buf.find(' ', pos0);
+					
+					
+					// -- pssmid
+					while(' ' == buf[pos1]) ++pos1;
+					pos0 = pos1;
+					pos1 = buf.find(' ', pos0);
+					PssmId_t pssmid = NStr::StringToNumeric<PssmId_t> (buf.substr(pos0, pos1 - pos0));
+					//unsigned int pssmid = (unsigned int)atoi(buf.substr(pos0, pos1 - pos0).c_str());
+					TDomain * p_dom = const_cast< TDomain* > (FindCdInfo(pssmid));
+					
+					if (nullptr != p_dom)
+					{
+						// -- parent acc
+						while(buf[pos1] <= ' ') ++pos1;
+						pos0 = pos1;
+						pos1 = buf.find(' ', pos0);
+						
+						string parentAcc = buf.substr(pos0, pos1 - pos0);
+						TrimString(parentAcc);
+						if ("N/A" != parentAcc)
+						{
+							if (parentAcc == p_dom->m_strAccession)
+								p_dom->m_uiHierarchyParent = pssmid;
+							else
+							{
+								const TDomain * ppcd = FindCdInfo(parentAcc);
+								if (nullptr != ppcd) 
+									p_dom->m_uiHierarchyParent = ppcd->m_uiPssmId;
+							}
+						}
+
+						// -- root acc
+						while(buf[pos1] <= ' ') ++pos1;
+						pos0 = pos1;
+						pos1 = buf.find(' ', pos0);
+						string rootAcc = buf.substr(pos0, pos1 - pos0);
+						TrimString(rootAcc);
+						if (rootAcc == parentAcc)
+							p_dom->m_uiHierarchyRoot = p_dom->m_uiHierarchyParent;
+						else if (rootAcc == p_dom->m_strAccession)
+							p_dom->m_uiHierarchyRoot = pssmid;
+						else
+						{
+							const TDomain * prcd = FindCdInfo(rootAcc);
+							if (nullptr != prcd) 
+								p_dom->m_uiHierarchyParent = prcd->m_uiPssmId;
+							
+						}
+					}
+				}
+			}	//dfstream
+			dfstream.close();
+		}
+		
+		// -- get domain superfamily associations
+		srcfile.Reset(famlinks);
+		if (!srcfile.Exists())
+			throw CSimpleException(__FILE__, __LINE__, "Data file " + srcfile.GetPath() + " does not exist");
+		else
+		{
+			dfstream.open(srcfile.GetPath().c_str());
+  		
+			while (dfstream.good())
+			{
+				buf.clear();
+				getline(dfstream, buf);
+				LTrimString(buf);
+				if (!buf.empty() && '#' != buf[0])
+				{
+					size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+					pos0 = pos1 + 1;
+					pos1 = buf.find('\t', pos0);
+					string tmp(buf.substr(pos0, pos1 - pos0));
+					TrimString(tmp);
+					PssmId_t pssmid = NStr::StringToNumeric<PssmId_t> (tmp);
+					TDomain * p_dom = const_cast< TDomain* > (FindCdInfo(pssmid));
+					
+					if (nullptr != p_dom)
+					{
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);
+						pos0 = pos1 + 1;
+						//pos1 = buf.find('\t', pos0);
+						tmp = buf.substr(pos0);
+						TrimString(tmp);
+						p_dom->m_uiClusterPssmId = NStr::StringToNumeric<PssmId_t>(tmp);
+						if (p_dom->m_uiClusterPssmId > 0)
+						{
+							const TCluster *p_clst = FindClusterByPssmId(p_dom->m_uiClusterPssmId);
+							if (nullptr != p_clst)
+								p_dom->m_iClusterId = p_clst->m_iClusterId;
+							else if (p_dom->m_uiClusterPssmId == pssmid)
+								p_dom->m_iClusterId = INVALIDCLUSTERID;
+						}
+						p_dom->m_bMultiDom = false;
+					}
+				}
+			}
+			
+			dfstream.close();
+		}
+		
+		TDomSite featValue;
+		// -- specific site annotations
+		srcfile.Reset(spfeats);
+		if (!srcfile.Exists())
+			throw CSimpleException(__FILE__, __LINE__, "Data file " + srcfile.GetPath() + " does not exist");
+		else
+		{
+			dfstream.open(srcfile.GetPath().c_str());
+			
+			while (dfstream.good())
+			{
+				buf.clear();
+				getline(dfstream, buf);
+				LTrimString(buf);
+				if (!buf.empty() && '#' != buf[0])
+				{
+					size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+					string tmp(buf.substr(pos0, pos1 - pos0));
+					TrimString(tmp);
+					PssmId_t pssmid = NStr::StringToNumeric<PssmId_t>(tmp);
+					TDomain * p_dom = const_cast< TDomain* > (FindCdInfo(pssmid));
+					
+					if (nullptr != p_dom)
+					{
+						p_dom->m_lstSpecificFeatures.emplace_back(featValue);
+						TDomSite &tgt =  *(p_dom->m_lstSpecificFeatures.rbegin());
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//accession
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//shortname
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//index
+						
+						tmp = buf.substr(pos0, pos1 - pos0);
+						TrimString(tmp);
+						tgt.m_iIndex = NStr::StringToNumeric<int>(tmp);
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//title
+						
+						tgt.m_strTitle = buf.substr(pos0, pos1 - pos0);
+						TrimString(tgt.m_strTitle);
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//Motif
+						
+						if ('0' != buf[pos0])
+						{
+							//tgt.SetMotifStr(buf.substr(pos0, pos1 - pos0).c_str());
+							tgt.m_strMotif = buf.substr(pos0, pos1 - pos0);
+							TrimString(tgt.m_strMotif);
+						}
+						
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//structure based evidence present
+						
+						if ('1' == buf[pos0])
+							tgt.m_flags |= TDomSite::STRUCTURE_BASED_EVIDENCE;
+							
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//reference based evidence present
+						
+						if ('1' == buf[pos0])
+							tgt.m_flags |= TDomSite::REFERENCE_BASED_EVIDENCE;
+							
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//additional comments present
+						
+						if ('1' == buf[pos0])
+							tgt.m_flags |= TDomSite::ADDITIONAL_COMMENTS;
+							
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//site coordinates
+						
+						vector<TSignedSeqPos> vecSitePos;	//to store coordinates
+						
+						vecSitePos.reserve((pos1 - pos0) * 3);	//estimated
+						
+						size_t pos_c = buf.find(',', pos0);
+						
+						while (pos_c < pos1)
+						{
+							vecSitePos.emplace_back(NStr::StringToNumeric<SeqPos_t>(buf.substr(pos0, pos_c - pos0)));
+							pos0 = pos_c + 1;
+							pos_c = buf.find(',', pos0);
+						}
+						
+						// -- last one
+						vecSitePos.emplace_back(NStr::StringToNumeric<SeqPos_t>(buf.substr(pos0, pos1 - pos0)));
+						
+						tgt.SetData(vecSitePos);
+						
+						tgt.m_iCompleteSize = (int)vecSitePos.size();
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//type
+						
+						if (string::npos == pos1)	//no other field
+							tgt.m_iType = NStr::StringToNumeric<int>(buf.substr(pos0));
+						else	//assume has motif string added
+							tgt.m_iType = NStr::StringToNumeric<int>(buf.substr(pos0, pos1 - pos0));
+					}
+				}
+			}
+			
+			dfstream.close();
+		}	
+			
+		// -- get generic site annotations
+		srcfile.Reset(genfeats);
+		if (!srcfile.Exists())
+			throw CSimpleException(__FILE__, __LINE__, "Data file " + srcfile.GetPath() + " does not exist");
+		else
+		{
+			dfstream.open(srcfile.GetPath().c_str());
+  		
+			while (dfstream.good())
+			{
+				buf.clear();
+				getline(dfstream, buf);
+				if (!buf.empty() && '#' != buf[0])
+				{
+					size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+					
+					PssmId_t pssmid = NStr::StringToNumeric<PssmId_t> (buf.substr(pos0, pos1 - pos0));
+					TDomain * p_dom = const_cast< TDomain* > (FindCdInfo(pssmid));
+					if (nullptr != p_dom)
+					{
+						p_dom->m_lstGenericFeatures.push_back(featValue);
+						TDomSite &tgt =  *(p_dom->m_lstGenericFeatures.rbegin());
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//accession
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//shortname
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//index
+						
+						tgt.m_iIndex = NStr::StringToNumeric<int>(buf.substr(pos0, pos1 - pos0));
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//title
+						
+						tgt.m_strTitle = buf.substr(pos0, pos1 - pos0);
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//Motif
+						
+						if ('0' != buf[pos0])
+						{
+							//tgt.SetMotifStr(buf.substr(pos0, pos1 - pos0).c_str());
+							tgt.m_strMotif = buf.substr(pos0, pos1 - pos0);
+							TrimString(tgt.m_strMotif);
+						}
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//structure based evidence present
+						
+						if ('1' == buf[pos0])
+							tgt.m_flags |= TDomSite::STRUCTURE_BASED_EVIDENCE;
+							
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//reference based evidence present
+						
+						if ('1' == buf[pos0])
+							tgt.m_flags |= TDomSite::REFERENCE_BASED_EVIDENCE;
+							
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//additional comments present
+						
+						if ('1' == buf[pos0])
+							tgt.m_flags |= TDomSite::ADDITIONAL_COMMENTS;
+							
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//site coordinates
+						
+						vector<SeqPos_t> vecSitePos;	//to store coordinates
+						
+						vecSitePos.reserve((pos1 - pos0) * 3);	//estimated
+						
+						size_t pos_c = buf.find(',', pos0);
+						
+						while (pos_c < pos1)
+						{
+							vecSitePos.push_back(NStr::StringToNumeric<SeqPos_t>(buf.substr(pos0, pos_c - pos0)));
+							pos0 = pos_c + 1;
+							pos_c = buf.find(',', pos0);
+						}
+						
+						// -- last one
+						vecSitePos.push_back(NStr::StringToNumeric<SeqPos_t>(buf.substr(pos0, pos1 - pos0)));
+						
+						tgt.SetData(vecSitePos);
+						
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);	//type
+						
+						if (string::npos == pos1)	//no other field
+							tgt.m_iType = NStr::StringToNumeric<int>(buf.substr(pos0));
+						else	//assume has motif string added
+							tgt.m_iType = NStr::StringToNumeric<int>(buf.substr(pos0, pos1 - pos0));
+					}
+				}
+			}
+
+			dfstream.close();
+
+		}
+			
+		// -- read bitscore thresholds
+		srcfile.Reset(bscores);
+		if (!srcfile.Exists())
+			throw CSimpleException(__FILE__, __LINE__, "Data file " + srcfile.GetPath() + " does not exist");
+		else
+		{
+
+			dfstream.open(srcfile.GetPath().c_str());
+			while (dfstream.good())
+			{
+				buf.clear();
+				getline(dfstream, buf);
+				if (!buf.empty() && '#' != buf[0])
+				{
+					size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+					PssmId_t pssmid = NStr::StringToNumeric<PssmId_t>(buf.substr(pos0, pos1 - pos0));
+					
+					TDomain * p_dom = const_cast< TDomain* > (FindCdInfo(pssmid));
+					if (nullptr != p_dom)
+					{
+						// -- accession, no need
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);
+						
+						// -- score
+						pos0 = pos1 + 1;
+						pos1 = buf.find('\t', pos0);
+  		
+						if (string::npos == pos1)
+							p_dom->m_dMinBitScore = NStr::StringToNumeric<double>(buf.substr(pos0));
+						else
+							p_dom->m_dMinBitScore = NStr::StringToNumeric<double>(buf.substr(pos0, pos1 - pos0));
+					}
+				}
+			}
+			dfstream.close();
+
+		}
+	}
+}
+
+void COfflArchData::LoadData(const std::string &datadir, const char *sparchs, const char *famarchs)
+{
+	if (m_SpArchStore.IsEmpty())	//not loaded yet, load it
+	{
+		ifstream dfstream;
+		string buf;
+		
+		CFile srcfile;
+		// -- Specific architectures
+		srcfile.Reset(sparchs ? datadir + "/" + sparchs : datadir + "/" + COfflArchData::__specific_arch_file);
+		if (!srcfile.Exists())
+			throw CSimpleException(__FILE__, __LINE__, "Data file " + srcfile.GetPath() + " does not exist");
+		else
+		{
+			vector< TSpDomArch* > sp_arch_ptrs;
+			sp_arch_ptrs.reserve(140000);
+			
+			
+			dfstream.open(srcfile.GetPath().c_str());
+			while (dfstream.good())
+			{
+				buf.clear();
+				getline(dfstream, buf);
+				if (!buf.empty() && '#' != buf[0])
+				{
+					size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+					ArchId_t archid = NStr::StringToNumeric<ArchId_t>(buf.substr(pos0, pos1 - pos0));
+					
+					// -- get string
+					pos0 = pos1 + 1;
+					pos1 = buf.find('\t', pos0);
+					
+					TSpDomArch * p_sparch = m_SpArchStore.Append(archid, buf.substr(pos0, pos1 - pos0));
+					
+					// -- name
+					pos0 = pos1 + 1;
+					pos1 = buf.find('\t', pos0);
+					p_sparch->m_strName = buf.substr(pos0, pos1 - pos0);
+					
+					// -- label
+					pos0 = pos1 + 1;
+					pos1 = buf.find('\t', pos0);
+					p_sparch->m_strLabel = buf.substr(pos0, pos1 - pos0);
+					
+					// -- review level
+					pos0 = pos1 + 1;
+					pos1 = buf.find('\t', pos0);
+					
+					p_sparch->m_strReviewLevel = buf.substr(pos0, pos1 - pos0);
+						
+					// -- associated superfamily architecture
+					pos0 = pos1 + 1;
+					pos1 = buf.find('\t', pos0);
+					if (string::npos == pos1)
+						p_sparch->m_uiSupFamArchId = NStr::StringToNumeric<ArchId_t>(buf.substr(pos0));
+					else
+						p_sparch->m_uiSupFamArchId = NStr::StringToNumeric<ArchId_t>(buf.substr(pos0, pos1 - pos0));
+					
+					sp_arch_ptrs.emplace_back(p_sparch);
+				}
+			}
+			dfstream.close();
+			sp_arch_ptrs.shrink_to_fit();
+			SetArchId2SpPtrs(sp_arch_ptrs);
+			SetArchStr2SpPtrs(move(sp_arch_ptrs));
+		}
+		
+		// -- read bitscore thresholds
+		srcfile.Reset(famarchs ? datadir + "/" + famarchs : datadir + "/" + COfflArchData::__supfam_arch_file);
+		if (!srcfile.Exists())
+			throw CSimpleException(__FILE__, __LINE__, "Data file " + srcfile.GetPath() + " does not exist");
+		else
+		{
+			vector< TDomArch* > arch_ptrs;
+			arch_ptrs.reserve(312000);
+			dfstream.open(srcfile.GetPath().c_str());
+			while (dfstream.good())
+			{
+				buf.clear();
+				getline(dfstream, buf);
+				if (!buf.empty() && '#' != buf[0])
+				{
+					size_t pos0 = 0, pos1 = buf.find('\t', pos0);
+					ArchId_t archid = NStr::StringToNumeric<ArchId_t>(buf.substr(pos0, pos1 - pos0));
+					
+					// -- get string
+					pos0 = pos1 + 1;
+					pos1 = buf.find('\t', pos0);
+					if (string::npos == pos1)
+						pos1 = buf.size();
+					
+					TDomArch * p_arch = m_ArchStore.Append(archid, buf.substr(pos0, pos1 - pos0));
+					arch_ptrs.emplace_back(p_arch);
+				}
+			}
+			dfstream.close();
+			arch_ptrs.shrink_to_fit();
+			SetArchId2FamPtrs(arch_ptrs);
+			SetArchStr2FamPtrs(move(arch_ptrs));
+		}
+	}
+}
+
+void COfflArchData::Reset(void)
+{
+	CArchIndex::Reset();
+	m_SpArchStore.Reset();
+	m_ArchStore.Reset();
+}
+void COfflArchData::Reset(bool mem_realloc, const std::string &datadir, const char *sparchs, const char *famarchs)
+{
+	if (mem_realloc)
+		Reset();
+	else
+	{
+		CArchIndex::Reset();
+		m_SpArchStore.Clear();
+		m_ArchStore.Clear();
+	}
+	LoadData(datadir, sparchs, famarchs);
+}
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offl_sparcle_data.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offl_sparcle_data.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offl_sparcle_data.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offl_sparcle_data.hpp	2018-03-13 14:39:35.403933000 -0400
@@ -0,0 +1,84 @@
+#if !defined(__OFFL_SPARCLE_DATA__)
+#define __OFFL_SPARCLE_DATA__
+#if defined(__DB_OFFLINE__)
+#include "compactstore.hpp"
+#include "offldata.hpp"
+#else
+#include <BasicUtils/compactstore.hpp>
+#include <DataUtils/offldata.hpp>
+#endif
+#include <corelib/ncbimtx.hpp>
+class COfflDomClusterData: public CDomClusterIndex
+{
+public:
+	
+	static constexpr const char * __cdd_ids_file = "cddids.tbl";
+	static constexpr const char * __spec_feats_file = "cddannot.dat";
+	static constexpr const char * __gen_feats_file = "cddannot_generic.dat";
+	static constexpr const char * __bs_thrlds_file = "bitscore_specific.txt";
+	static constexpr const char * __cdtrack_file = "cdtrack.txt";
+	static constexpr const char * __domfam_link_file = "family_superfamily_links";
+	
+	typedef CCompactStore<TDomain, 50400 * sizeof(TDomain) > TOfflCDStore;
+	typedef CCompactStore<TCluster, 6000 * sizeof(TCluster) > TOfflClusterStore;
+	
+	COfflDomClusterData(void):
+		CDomClusterIndex(), m_CDStore(), m_ClusterStore() {};
+	
+	COfflDomClusterData(const std::string &datadir, const char *cddids = nullptr, const char *spfeats = nullptr, const char *genfeats = nullptr, const char *bscores = nullptr, const char *cdtrack = nullptr, const char *famlinks = nullptr):
+		CDomClusterIndex(), m_CDStore(), m_ClusterStore()
+	{LoadData(datadir, cddids, spfeats, genfeats, bscores, cdtrack, famlinks);}
+	
+	COfflDomClusterData(const std::string &cddids, const std::string &spfeats, const std::string &genfeats, const std::string &bscores, const std::string &cdtrack, const std::string &famlinks):
+		CDomClusterIndex(), m_CDStore(), m_ClusterStore()
+	{LoadData_real(cddids, spfeats, genfeats, bscores, cdtrack, famlinks);}
+	
+	// -- any file names be nullptr, use default file name
+	void LoadData(const std::string &datadir, const char *cddids = nullptr, const char *spfeats = nullptr, const char *genfeats = nullptr, const char *bscores = nullptr, const char *cdtrack = nullptr, const char *famlinks = nullptr);	//uusing default file names
+	
+	void LoadData_real(const std::string &cddids, const std::string &spfeats, const std::string &genfeats, const std::string &bscores, const std::string &cdtrack, const std::string &famlinks);	//totaly customized data, 
+	
+	void Reset(void);
+	void Reset(bool mem_realloc, const std::string &datadir, const char *cddids = nullptr, const char *spfeats = nullptr, const char *genfeats = nullptr, const char *bscores = nullptr, const char *cdtrack = nullptr, const char *famlinks = nullptr);
+	void Reset(bool mem_realloc, const std::string &cddids, const std::string &spfeats, const std::string &genfeats, const std::string &bscores, const std::string &cdtrack, const std::string &famlinks);
+	
+private:
+	
+	TOfflCDStore m_CDStore;
+	TOfflClusterStore m_ClusterStore;
+	
+};
+
+
+
+
+class COfflArchData: public CArchIndex
+{
+public:
+	static constexpr const char * __specific_arch_file = "specific_arch.txt";
+	static constexpr const char * __supfam_arch_file = "superfamily_arch.txt";
+	
+	typedef CCompactStore<TSpDomArch, 28000 * sizeof(TSpDomArch) > TOfflSpArchStore;
+	typedef CCompactStore<TDomArch, 80000 * sizeof(TDomArch) > TOfflArchStore;
+	
+	COfflArchData(void):
+		CArchIndex(), m_SpArchStore(), m_ArchStore() {};
+	
+	COfflArchData(const std::string &datadir, const char *sparchs = nullptr, const char *famarchs = nullptr):
+		CArchIndex(), m_SpArchStore(), m_ArchStore()
+	{LoadData(datadir, sparchs, famarchs);}
+	
+	void LoadData(const std::string &datadir, const char *sparchs = nullptr, const char *famarchs = nullptr);	//uusing default file names
+	
+	
+	void Reset(void);
+	void Reset(bool mem_realloc, const std::string &datadir, const char *sparchs = nullptr, const char *famarchs = nullptr);
+	
+private:
+	
+	TOfflSpArchStore m_SpArchStore;
+	TOfflArchStore m_ArchStore;
+};
+
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offldata.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offldata.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offldata.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offldata.cpp	2018-03-13 14:39:35.337741000 -0400
@@ -0,0 +1,1018 @@
+#include "offldata.hpp"
+#include "prosite.hpp"
+#if defined(__DB_OFFLINE__)
+#include "basealgo.hpp"
+#else
+#include <BasicUtils/basealgo.hpp>
+#endif
+#include <sstream>
+
+USING_NCBI_SCOPE;
+using namespace objects;
+
+const char * READINGFRAME::RF_TITLES[] = {"RF +1", "RF +2", "RF +3", "RF -1", "RF -2", "RF -3"};
+int READINGFRAME::RF_IDS[] = {1, 2, 3, -1, -2, -3};
+	
+const char * READINGFRAME::tagTitle::operator [] (int idx) noexcept
+{
+	if (idx < -READINGFRAME::TOTAL_RFS || idx >= READINGFRAME::TOTAL_RFS)
+		return nullptr;
+	if (idx < 0)
+		return READINGFRAME::RF_TITLES[idx + READINGFRAME::TOTAL_RFS];
+	return READINGFRAME::RF_TITLES[idx];
+}
+
+int READINGFRAME::tagId::operator [] (int idx) noexcept
+{
+	
+	if (idx < -READINGFRAME::TOTAL_RFS || idx >= READINGFRAME::TOTAL_RFS)
+		return 0;	//0 is not a valid rf id
+	if (idx < 0)
+		return READINGFRAME::RF_IDS[idx + READINGFRAME::TOTAL_RFS];
+	return READINGFRAME::RF_IDS[idx];
+}
+
+int READINGFRAME::IndexOf (int id) noexcept
+{
+	if (id == 0 || id < -3 || id > 3)
+		return 0;	//invalid id always return 0, the first, as protein uses it
+	return (id < 0 ? READINGFRAME::RF_SIZE - id - 1 : id - 1);
+}
+
+SeqPos_t READINGFRAME::NA2Pr(SeqPos_t napos, int rf, SeqLen_t na_len)
+{
+	if (rf > 0)
+	{
+		// -- plus
+		if (rf > 3)
+			return napos;
+		return napos / READINGFRAME::RF_SIZE;
+	}
+	else if (rf < 0)
+	{
+		if (rf < -3)
+			return napos;
+		return (na_len - napos - 1) / READINGFRAME::RF_SIZE;
+	}
+	// -- rf = 0;
+	return napos;
+	
+}
+
+SeqPos_t READINGFRAME::Pr2NA(SeqPos_t prpos, int rf, SeqLen_t pr_len)
+{
+	if (rf > 0)
+	{
+		// -- plus
+		if (rf > 3)
+			return prpos;
+		return prpos * READINGFRAME::RF_SIZE + rf - 1;
+	}
+	else if (rf < 0)
+	{
+		// -- minus
+		if (rf < -3)
+			return prpos;
+		return (pr_len - prpos - 1) * READINGFRAME::RF_SIZE - rf - 1;
+	}
+	// -- rf = 0;
+	return prpos;
+	
+}
+	
+
+const char * TDataModes::dimLits[] = {"rep", "std", "full"};
+const char * TDataModes::dimDisplay[] = {"Concise", "Standard", "Full"};
+	
+const char * TTargetData::dimLits[] = {"doms", "feats", "both"};
+const char * TTargetData::dimDisplay[] = {"Domain hits", "Site annotations", "Domain hits and site annotations"};
+
+
+CPdbId::CPdbId(void):
+	m_usedelim(CPdbId::DELIM_CHAR),
+	m_numid(0),
+	m_mol{'\x0', '\x0', '\x0', '\x0'},
+	m_chain{'\x0', '\x0', '\x0', '\x0', '\x0'}
+{}
+
+CPdbId::CPdbId(const std::string &acxn, bool AA2a):
+	m_usedelim(CPdbId::DELIM_CHAR),
+	m_numid(0),
+	m_mol{'\x0', '\x0', '\x0', '\x0'},
+	m_chain{'\x0', '\x0', '\x0', '\x0', '\x0'}
+{
+	if (!SetAcxn(acxn, AA2a))
+		THROW_SIMPLE("Invalid Pdb ID string " << acxn);
+}
+
+bool CPdbId::IsValid(void) const
+{
+	return ('\x0' != m_mol[0] && '\x0' != m_mol[1] && '\x0' != m_mol[2] && '\x0' == m_mol[3]);
+}
+
+string CPdbId::GetMol(void) const
+{
+	if (!IsValid())
+		return k_strEmptyString;
+	
+	if (m_numid < 9)
+		return (to_string(m_numid) + m_mol);
+	
+	char dimBuf[32];
+	sprintf(dimBuf, CPdbId::NUM_ID_FMT, m_numid);
+	return string(CPdbId::NEW_SIG) + dimBuf + m_mol;
+}
+
+string CPdbId::GetChain(void) const
+{
+	if (!IsValid())
+		return k_strEmptyString;
+	return m_chain;
+}
+
+CPdbId::operator string(void) const
+{
+	string s = GetMol();
+	if (s.empty())	//valid
+		return s;
+	if (m_usedelim) s.push_back(m_usedelim);
+	return s + m_chain;
+}
+
+bool CPdbId::SetAcxn(const string & acxn, bool AA2a)
+{
+	size_t len = acxn.size();
+	if (len < CPdbId::PDBMOL_LEN + 1)	//not enough
+		return false;
+	
+	size_t ch_idx = 0;
+	NUM_ID numid = 0;
+	
+	if (acxn.substr(ch_idx, CPdbId::SIG_LEN) == CPdbId::NEW_SIG)	//new format
+	{
+		if (len < CPdbId::SIG_LEN + CPdbId::PDBMOL_LEN + CPdbId::NUM_ID_DIGITS)	//too short for a valid new id
+			return false;
+		ch_idx += CPdbId::SIG_LEN;
+			
+		while (ch_idx < CPdbId::SIG_LEN + CPdbId::NUM_ID_DIGITS)
+		{
+			if (!isdigit(acxn[ch_idx]))
+				return false;
+			numid = numid * 10 + (NUM_ID)(acxn[ch_idx] - '0');
+			++ch_idx;
+		}
+	}
+	else	//old format
+	{
+		if (!isdigit(acxn[ch_idx]))
+			return false;
+		
+		numid = (NUM_ID)(acxn[ch_idx] - '0');
+		++ch_idx;
+	}
+	
+	char mol[PDBMOL_LEN + 1] = {'\x0', '\x0', '\x0', '\x0'};	//for tail '\0'
+	
+	
+	// -- molecule
+	for (size_t i = 0; i < PDBMOL_LEN; ++i)
+	{
+		char c = acxn[i + ch_idx];
+		if (!isalnum(c))
+			return false;
+		mol[i] = (char)toupper(c);	//molecule is case-insensitive
+	}
+	
+	ch_idx += PDBMOL_LEN;
+	
+	if (ch_idx < len)	//has chain
+	{
+		if (!isalnum(acxn[ch_idx]))	//consider as a delimit
+			++ch_idx;
+			
+		size_t mol_len = len - ch_idx;
+		
+		if (mol_len > PDBCHN_MAX_LEN)	//too long
+			return false;
+		
+		char chain[PDBCHN_MAX_LEN + 1] = {'\x0', '\x0', '\x0', '\x0', '\x0'};
+		size_t chain_idx = 0;
+		if (2 == mol_len && AA2a && acxn[ch_idx] == acxn[ch_idx + 1] && isupper(acxn[ch_idx]))
+			chain[chain_idx] = tolower(acxn[ch_idx]);
+		else
+		{
+			while (ch_idx < len)
+			{
+				if (!isalnum(acxn[ch_idx]))
+					return false;
+				chain[chain_idx++] = acxn[ch_idx];
+				++ch_idx;
+			}
+		}
+		// -- chain copy first
+		memcpy(m_chain, m_chain, PDBCHN_MAX_LEN + 1);
+	}
+	// -- copy
+	m_numid = numid;
+	memcpy(m_mol, mol, PDBMOL_LEN + 1);
+	return true;
+}
+
+
+void TDocsum::Reset(void)
+{
+	m_iGi = 0;
+	m_strAccession.clear();
+	m_strNcbiId.clear();
+	m_uiSeqLen = 0;
+	m_strTitle.clear();
+	m_iMolType = CSeq_inst::eMol_not_set;
+	m_iTaxId = 0;
+	m_iGenCode = 1;
+	m_iMGenCode = 2;	//mitochondrial genetic code
+	m_strSciName.clear();	//scientific name
+	m_strBlastName.clear();	//blast name
+	m_strCommonName.clear();	//common name
+}
+
+void TSequence::Reset(void)
+{
+	TDocsum::Reset();
+	m_iInputType = 0;	//CCleanInput::EStringDataType values
+	m_strCleanedInput.clear();	//also from CCleanInput
+	m_strSeqData.clear();	//1-letter seqdata
+	m_Src.clear();
+	m_B64PackedIds.clear();
+	m_iValid = e_Invalid;
+	m_iStatus = 0;	//misc status for compatibility, previous field name is m_iOid
+	m_iPig = 0;	//if has one. otherwise 0
+	// -- added 2012/4/12 -- for range. m_iStart is default to 0, m_iEnd is default to -1, meaning whole length.
+	m_iFrom = 0;
+	m_iTo = 0;
+
+	m_vecMaskedRegions.clear();
+}
+
+
+
+
+const char * TDomSite::GENERIC_SITE_TITLE = "active site";
+const char * TDomSite::FEATTYPES[] = {"other", "active site", "polypeptide binding site", "nucleotide binding site", "ion binding site", "chemical binding site", "posttranslational modification", "structural motif"};
+	
+//map<int, string> TDomSite::m_mapActualFeatTypes;
+
+void TDomSite::Reset(void)
+{
+	m_strTitle.clear();
+	m_strDescr.clear();
+	m_strMotif.clear();
+	m_iMotifuse = 0;
+	m_iIndex = 0;
+	m_iType = 0;
+	m_iCompleteSize = 0;
+	m_flags = 0;
+}
+
+int TDomSite::MotifCheck(const vector<TSeg_base::TResiduePos> &rMappedRes, const string &rSeqData) const
+{
+	if (!m_strMotif.empty())
+	{
+		size_t seqLen = rSeqData.size();
+		vector<TSeg_base::TResiduePos> vecOriPoses;
+		GetTranslatedPosMap(seqLen, vecOriPoses);
+
+		CProSite ps;
+		size_t errPos;
+		CProSite::EParseError err = ps.Parse(m_strMotif, errPos);
+		if (CProSite::eNoError != err)
+		{
+			stringstream ss;
+			ss << "Motif string parse error -- Motif = " << m_strMotif << ", error position: " << errPos;
+			throw CSimpleException(__FILE__, __LINE__, ss.str());
+		}
+		string minMap(k_strEmptyString);
+		ps.GetMinimalXMap(minMap);
+		
+		size_t mtfLen = minMap.size();
+		size_t mappedLen = rMappedRes.size();
+//		assert(mtfLen == vecOriPoses.size());
+		
+		for (size_t i = 0; i < mtfLen; ++i)
+		{
+
+			if (minMap[i] != 'X')	//x always match
+			{
+				for (size_t j = 0; j < mappedLen; ++j)
+				{
+					if (rMappedRes[j].ori == vecOriPoses[i].curr)	//found, means mapped
+						goto labelResidueMapped;
+				}
+				// --  not mapped, return failure
+
+				return 1;
+			labelResidueMapped:;
+					
+			}
+		}
+		
+		if (!rSeqData.empty())
+		{
+//			err = ps.Parse(m_strModifiedMotif, errPos);
+//
+//			if (CProSite::eNoError != err)
+//			{
+//				stringstream ss;
+//				ss << "Motif string parse error -- Working Motif = " << m_strMotif << ", error position: " << errPos;
+//				throw CException(CDiagCompileInfo(__FILE__, __LINE__, "int TShluCdFeat::MotifCheck(const CSegSet &mapped, const string &rSeqData) const"), nullptr, CException::eUnknown, ss.str());
+//			}
+			
+			minMap.clear();	//borrow this for other use
+			
+			for (size_t i = 0; i < mappedLen; ++i)
+				if ((size_t)rMappedRes[i].curr < seqLen)
+				{
+
+					minMap.push_back(rSeqData[rMappedRes[i].curr]);
+				}
+
+			size_t endPos = ps.Match(minMap, seqLen, 0);
+			if (string::npos == endPos)
+			{
+				return 2;
+			}
+		}
+	}
+
+	return 0;
+}
+
+bool DomAcxnSig(const string &acxn, const char * sig)
+{
+	size_t pos = acxn.find(':');
+	if (string::npos == pos) pos = 0;
+	else ++pos;
+
+	return 0 == acxn.compare(pos, strlen(sig), sig);
+}
+
+TCluster::TCluster(void):
+	m_uiPssmId(0), m_uiLength(0), m_iClusterId(INVALIDCLUSTERID), m_strAccession(k_strEmptyString), m_strShortName(k_strEmptyString), m_strTitle(k_strEmptyString), m_strDefline(k_strEmptyString)
+{}
+
+void TCluster::Reset(void)
+{
+	m_uiPssmId = 0;
+	m_uiLength = 0;
+	m_iClusterId = INVALIDCLUSTERID;
+	m_strAccession.clear();
+	m_strShortName.clear();
+	m_strTitle.clear();
+	m_strDefline.clear();
+}
+
+TDomain::TDomain(void):
+	TCluster(), m_uiHierarchyRoot(0), m_uiHierarchyParent(0), m_uiClusterPssmId(0),
+	m_dMinBitScore(0.0), m_bCurated(false), m_bIsStructDom(false), m_bMultiDom(false),
+	m_strConsensus(), m_strSource(),
+	m_lstSpecificFeatures(), m_lstGenericFeatures()
+{}
+
+void TDomain::Reset(void)
+{
+	TCluster::Reset();
+	m_uiHierarchyRoot = 0;	//root pssmid
+	m_uiHierarchyParent = 0;	//root pssmid
+	m_uiClusterPssmId = 0;
+	m_dMinBitScore = 0;
+	m_bCurated = 0;
+	m_bIsStructDom = 0;
+	m_bMultiDom = 0;
+	m_strConsensus.clear();
+	m_strSource.clear();
+	m_lstSpecificFeatures.clear();
+	m_lstGenericFeatures.clear();
+}
+
+void CDomClusterIndex::Reset(void)
+{
+	m_pssmid2cd.Reset();
+	m_acxn2cd.Reset();
+	m_pssmid2fam.Reset();
+	m_clid2fam.Reset();
+}
+
+void CDomClusterIndex::InsertDomainIdx(TDomain *p)
+{
+	bool ins_dummy;
+	m_pssmid2cd.Insert(p, ins_dummy);
+	m_acxn2cd.Insert(p, ins_dummy);
+}
+void CDomClusterIndex::InsertClusterIdx(TCluster *p)
+{
+	bool ins_dummy;
+	m_pssmid2fam.Insert(p, ins_dummy);
+	m_clid2fam.Insert(p, ins_dummy);
+}
+
+void CArchIndex::Reset(void)
+{
+	m_id2sp.Reset();
+	m_str2sp.Reset();
+	m_id2fam.Reset();
+	m_str2fam.Reset();
+}
+
+void CArchIndex::InsertSpArchIdx(TSpDomArch *p)
+{
+	bool ins_dummy;
+	m_id2sp.Insert(p, ins_dummy);
+	m_str2sp.Insert(p, ins_dummy);
+}
+void CArchIndex::InsertFamArchIdx(TDomArch *p)
+{
+	bool ins_dummy;
+	m_id2fam.Insert(p, ins_dummy);
+	m_str2fam.Insert(p, ins_dummy);
+}
+
+void TDomArch::Reset(void)
+{
+	m_uiArchId = 0;
+	m_strArchString.clear();
+	m_strReviewLevel.clear();
+}
+
+void TSpDomArch::Reset(void)
+{
+	TDomArch::Reset();
+	m_strName.clear();
+	m_strLabel.clear();
+	m_uiSupFamArchId = 0;
+}
+
+/*debug*******************************************************/
+#if defined(_DEBUG)
+void TDomArch::Print(void) const
+{
+	cout << "m_uiArchId " << m_uiArchId << " ====================================" << endl;
+	cout << "m_strArchString = " << m_strArchString << endl;
+	cout << "----------------------------------------------------------------" << endl;
+}
+void TSpDomArch::Print(void) const
+{
+	TDomArch::Print();
+	cout << "m_strName = " << m_strName << endl;
+	cout << "m_strLabel = " << m_strLabel << endl;
+	cout << "m_uiSupFamArchId = " << m_uiSupFamArchId << endl;
+	cout << "===============================================================" << endl;
+}
+#endif
+// ***********************************************************/
+
+void TSeqAlignment::PrintEValue(char *buf, double eval)
+{
+	if (eval < 1.0e-180) sprintf(buf, "%.0e", eval);
+	else if (eval < 0.01) sprintf(buf, "%.2e", eval);
+	else if (eval < 1.0) sprintf(buf, "%.2f", eval);
+	else if (eval < 10.0) sprintf(buf, "%.1f", eval);
+	else sprintf(buf, "%.0f", eval);
+}
+
+void TSeqAlignment::PrintBitScore(char *buf, double bscore)
+{
+	if (bscore < 0.0)
+		sprintf(buf, "NA");
+	else if (bscore > 9999.0)
+		sprintf(buf, "%.2e", bscore);
+	else if (bscore > 99.9)
+		sprintf(buf, "%.0ld", (long)bscore);
+	else
+		sprintf(buf, "%.2f", bscore);
+}
+
+
+const char * TSeqAlignment::dimLits[] = {"evalue", "bitscore", "seqidentity", "alignedlen", "scorecombo1"};
+const char * TSeqAlignment::dimLabels[] = {"BLAST E-value", "BLAST bit score", "Sequence Identity", "Aligned Length", "Score Combination"};
+TSeqAlignment::TSortObj::TSortObj(int iSortIdx):
+	m_lpfnCompare(TSeqAlignment::EValueCompare)
+{
+	switch (iSortIdx)
+	{
+		case TSeqAlignment::SORT_BY_BITSCORE:
+			m_lpfnCompare = TSeqAlignment::BitScoreCompare;
+			break;
+		case TSeqAlignment::SORT_BY_SEQ_IDENTITY:
+			m_lpfnCompare = TSeqAlignment::SeqIdentityCompare;
+			break;
+		case TSeqAlignment::SORT_BY_ALIGNED_LENGTH:
+			m_lpfnCompare = TSeqAlignment::AlignedLengthCompare;
+			break;
+		case TSeqAlignment::SORT_BY_SCORE_COMBO:
+			m_lpfnCompare = TSeqAlignment::ScoreComboEvaluate;
+			break;
+		default:;
+	}
+}
+
+
+
+void TSeqAlignment::PrintPercentage(char *buf, double pct)
+{
+	sprintf(buf, "%d%%", (int)(pct + 0.5));
+}
+
+string TSeqAlignment::GetAlignString(void) const
+{
+	stringstream oAlignData;
+	size_t ulTotalSegs = m_vecLens.size();
+	oAlignData << ulTotalSegs;
+	for (size_t j = 0; j < ulTotalSegs; ++j)
+	{
+		oAlignData << "," << m_vecMStarts[j] << "," << m_vecSStarts[j] << "," << m_vecLens[j];
+	}
+	oAlignData << '\0';
+	return oAlignData.str();
+}
+
+void TSeqAlignment::Pr2NaConvert(CSegSet &segset) const
+{
+	if (ePr2Na == m_eAlignType)
+	{
+		int alnLen = (m_iReadingFrame >> 2);
+		int rf = m_iReadingFrame & READINGFRAME::RF_SIZE;	//reading frame
+		segset.m_iFactor *= READINGFRAME::RF_SIZE;
+		if (alnLen > 0)	//is minus
+		{
+			//segset.m_iFactor *= READINGFRAME::RF_SIZE;
+			for (CSegSet::TSegs::iterator iterSeg = segset.m_lstContainer.begin(); iterSeg != segset.m_lstContainer.end(); ++iterSeg)
+			{
+				SeqPos_t newFrom = (alnLen - iterSeg->from) * READINGFRAME::RF_SIZE + rf;
+				iterSeg->from = (alnLen - iterSeg->to) * READINGFRAME::RF_SIZE - READINGFRAME::RF_SIZE + 1;
+				iterSeg->to = newFrom;
+				
+				// -- reverse ori_as well
+				iterSeg->ori_from += (iterSeg->to - iterSeg->from) / segset.m_iFactor;
+				
+			}
+			segset.m_iFactor = -segset.m_iFactor;
+			segset.m_lstContainer.reverse();
+		}
+		else	//plus strand
+		{
+			for (CSegSet::TSegs::iterator iter = segset.m_lstContainer.begin(); iter != segset.m_lstContainer.end(); ++iter)
+			{
+				iter->from = iter->from * READINGFRAME::RF_SIZE + rf;
+				iter->to = iter->to * READINGFRAME::RF_SIZE + rf + READINGFRAME::RF_SIZE - 1;
+			}
+		}
+	}
+}
+
+void TSeqAlignment::MapSegSet(CSegSet &segset, bool doConvert) const
+{
+	if (segset.IsEmpty()) return;
+	
+	CSegSet::TSegs::iterator iter = segset.m_lstContainer.begin();
+	size_t idx = 0;
+	
+	while (iter != segset.m_lstContainer.end())
+	{
+		if (idx >= m_vecLens.size() || m_vecSStarts[idx] > iter->to)	// discard this seg
+		{
+			CSegSet::TSegs::iterator temp = iter;
+			++iter;
+			segset.m_lstContainer.erase(temp);
+		}
+		else
+		{
+			SeqPos_t diff = m_vecSStarts[idx] - m_vecMStarts[idx];
+			SeqPos_t end = m_vecSStarts[idx] + m_vecLens[idx] - 1;
+			if (end >= iter->to)
+			{
+				if (iter->from < m_vecSStarts[idx])	//segment shrinked from left. deal with ori_from
+				{
+					iter->ori_from += (m_vecSStarts[idx] - iter->from) / segset.m_iFactor;
+					iter->from = m_vecSStarts[idx];
+				}
+			
+				if (end == iter->to)	//seg happens to end at aligned seg
+					++idx;	//here is the chance to advance idx
+				
+				
+				// -- mapping
+				iter->from -= diff;
+				iter->to -= diff;
+
+				++iter;
+			}
+			else if (end >= iter->from)	//end < iter->to
+			{
+				CSegSet::TSeg temp(iter->from, end);
+				temp.ori_from = iter->ori_from;
+				
+				if (temp.from < m_vecSStarts[idx])
+				{
+					temp.ori_from += (m_vecSStarts[idx] - temp.from) / segset.m_iFactor;
+					temp.from = m_vecSStarts[idx];
+				}
+				
+				// -- mapping
+				temp.from -= diff;
+				temp.to -= diff;
+				segset.m_lstContainer.insert(iter, temp);
+				
+				// -- cut original seg for next round
+				iter->ori_from += (end - iter->from + 1) / segset.m_iFactor;
+				iter->from = end + 1;
+				//iter->ori_from += (iter->from) / segset.m_iFactor;
+				++idx;
+			}
+			else	//end < iter->from, step to next denseg
+				++idx;
+		}
+	}
+	
+	// -- check motif
+	
+	//if (eNa_strand_minus == m_eStrand) StrandConvert(segset);	//possible strand conversion
+	// -- if protein to na, convert to na coord
+	if (doConvert) Pr2NaConvert(segset);
+}
+
+
+void TSeqAlignment::CreateSlaveSegs(CSegSet &segset) const
+{
+	segset.Clear();
+	for (size_t i = 0, len = m_vecLens.size(); i < len; ++i)
+	{
+		segset.AddSeg(m_vecSStarts[i], m_vecSStarts[i] + m_vecLens[i] - 1);
+	}
+}
+
+void TSeqAlignment::CreateMasterSegs(CSegSet &segset) const
+{
+	segset.Clear();
+	for (size_t i = 0, len = m_vecLens.size(); i < len; ++i)
+	{
+		segset.AddSeg(m_vecMStarts[i], m_vecMStarts[i] + m_vecLens[i] - 1);
+	}
+}
+
+
+void TSeqAlignment::CalcMasterGaps(SeqLen_t gapThreshold, CSegSet &segset) const
+{
+	segset.Clear();
+	if (!m_vecLens.empty())
+	{
+		size_t segs = m_vecLens.size();
+		for (size_t i = 0; i < segs - 1; ++i)
+		{
+			SeqPos_t gapstart = m_vecMStarts[i] + (SeqPos_t)m_vecLens[i];
+			SeqPos_t gaplen = m_vecMStarts[i + 1] - gapstart;
+			
+			if (gaplen >= (SeqPos_t)gapThreshold)	//consider a gap
+				segset.AddSeg(gapstart, gapstart + gaplen - 1);
+		}
+	}
+}
+
+int TSeqAlignment::GetRFIdx(SeqLen_t seqLen) const
+{
+	if (ePr2Na != m_eAlignType) return 0;
+	int alignedLen = m_iReadingFrame >> 2;
+	int rfidx = m_iReadingFrame & READINGFRAME::RF_SIZE;
+	
+	if (alignedLen > 0)	//negative -- minus strand
+		//rfidx = (seqLen - 1 - (alignedLen * RF_SIZE + rfidx)) % RF_SIZE + RF_SIZE;
+		rfidx = (seqLen - rfidx) % READINGFRAME::RF_SIZE + READINGFRAME::RF_SIZE;
+	return rfidx;
+}
+
+int TSeqAlignment::Na2Pr(int na, int &pr) const
+{
+	int len = m_iReadingFrame >> 2;
+	if (len > 0)	//minus strand
+	{
+		pr = (len - na - 1) / 3;
+		return -3;
+	}
+	pr = na / 3;
+	return 3;
+}
+
+int TSeqAlignment::Pr2Na(int pr, int &na) const
+{
+	int len = m_iReadingFrame >> 2;
+	if (len > 0)
+	{
+		na = len - pr * 3 - (m_iReadingFrame & READINGFRAME::RF_SIZE) - 1;
+		return -1;
+	}
+	na = pr * 3 + (m_iReadingFrame & READINGFRAME::RF_SIZE);
+	return 1;
+}
+
+void CleanAlignment(const vector<SeqPos_t> & rSrcStarts, const vector<SeqLen_t> & rSrcLens, vector<SeqPos_t>& rMStarts, vector<SeqPos_t>& rSStarts, vector<SeqLen_t>& rLens)
+{
+	rMStarts.clear();
+	rSStarts.clear();
+	rLens.clear();
+	for (size_t i = 0; i < rSrcLens.size(); ++i)
+	{
+		size_t ii = i + i;
+		if (rSrcStarts[ii] >=0 && rSrcStarts[ii + 1] >= 0)
+		{
+			rMStarts.push_back(rSrcStarts[ii]);
+			rSStarts.push_back(rSrcStarts[ii + 1]);
+			rLens.push_back(rSrcLens[i]);
+		}
+	}
+}
+
+
+
+
+int TDomSeqAlignment::GetTranslatedPosMap(const CSegSet &segs, SeqLen_t seqLen, vector<TSeg_base::TResiduePos> &rMappedAAPos) const
+{
+	rMappedAAPos.clear();
+	segs.GetTranslatedPosMap(seqLen, rMappedAAPos);
+	if (ePr2Na == m_eAlignType)	//needs translation
+		return GetRFIdx(seqLen);
+	else
+		return 0;
+}
+
+int MapCdFeature(const TDomSite &rFeat, const TDomSeqAlignment &rAlign, SeqLen_t seqLen, const string dimAaData[], CSegSet &dst)
+{
+	dst = rFeat;
+	
+	if (!rAlign.m_ClipSet.IsEmpty())
+		dst.Cross(rAlign.m_ClipSet);
+
+	rAlign.MapSegSet(dst);
+
+	vector<TSeg_base::TResiduePos> vecMappedPos;
+	int rfidx = rAlign.GetTranslatedPosMap(dst, seqLen, vecMappedPos);
+	
+
+
+	if (rFeat.MotifCheck(vecMappedPos, dimAaData[rfidx]) > 0)
+		dst.Clear();
+	return rfidx;
+}
+
+
+
+void TDomSeqAlignIndex::CreateRecordSets(const vector<TDomSeqAlignment> &rAlignments, const TDomClusterIndexIfx & rDomInfo, vector< TDomSeqAlignIndex::__TCdAlignRecord> &rDomAligns, vector<TDomSeqAlignIndex::__TCdAlignRecord> &rFeatAligns, int mode) const
+{
+/*debug*******************************************************/
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Entering TDomSeqAlignIndex::CreateRecordSets" << endl;
+#endif
+// ***********************************************************/
+
+//	const vector<size_t> &rIndice = bConcise ? m_vecConciseIndice : m_vecSortedIndice;
+	rDomAligns.clear();
+	rFeatAligns.clear();
+	
+	size_t featIdx0 = 0;
+	size_t amendCount = 0;
+	size_t ccsBase = m_vecConciseIndice.size();
+	
+	if (TDataModes::e_rep == mode)	//all rep
+	{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": m_vecConciseIndice.size() = " << m_vecConciseIndice.size() << endl;
+#endif
+// ***********************************************************/
+
+		for (size_t iidx = 0, iidxEnd = m_vecConciseIndice.size(); iidx < iidxEnd; ++iidx)
+		{
+			__TCdAlignRecord alignRec;
+			alignRec.pAlign = &(rAlignments[m_vecConciseIndice[iidx]]);
+			alignRec.pCdInfo = rDomInfo.FindCdInfo(alignRec.pAlign->m_uiPssmId);
+
+
+			if (alignRec.pCdInfo->m_iClusterId > 0) alignRec.pClst = rDomInfo.FindClusterInfo(alignRec.pCdInfo->m_iClusterId);
+/*debug*******************************************************/
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": alignRec.pCdInfo->m_iClusterId = " << alignRec.pCdInfo->m_iClusterId << ", alignRec.pClst = " << (void*)(alignRec.pClst);
+if (alignRec.pClst) cerr << "m_uiPssmId = " << alignRec.pClst->m_uiPssmId;
+cerr << endl;
+
+#endif
+// ***********************************************************/
+			if (alignRec.pCdInfo->m_uiHierarchyRoot > 0)
+			{
+				if (alignRec.pCdInfo->m_uiHierarchyRoot == alignRec.pAlign->m_uiPssmId) alignRec.pRootCdInfo = alignRec.pCdInfo;
+				else alignRec.pRootCdInfo = rDomInfo.FindCdInfo(alignRec.pCdInfo->m_uiHierarchyRoot);
+			}
+			alignRec.idx = m_vecConciseIndice[iidx];
+			alignRec.idxidx = iidx;
+
+			if (0 == alignRec.pAlign->m_iRepClass && alignRec.pAlign->m_bRep)	//non-multi
+			{
+				ExtractFeatAligns(alignRec, rAlignments, rDomInfo, rFeatAligns);
+				
+				size_t featIdx1 = rFeatAligns.size();
+		    	
+				for (size_t i = featIdx0; i < featIdx1; ++i)
+				{
+					if (rFeatAligns[i].idx == alignRec.idx)
+						rFeatAligns[i].idxidx = alignRec.idxidx;
+					else
+						rFeatAligns[i].idxidx = iidxEnd + amendCount++;
+				}
+				
+				featIdx0 = featIdx1;
+			}
+			
+			rDomAligns.push_back(alignRec);
+		}
+	}
+	else	//non-concise 
+	{
+		size_t repIdx = 0;
+		
+		size_t featIdx0 = 0;
+		size_t amendCount = 0;
+		
+		const vector<size_t> &nonConciseIdx = (TDataModes::e_std == mode ? m_vecStdIndice : m_vecSortedIndice);
+		
+		for (size_t iidx = 0, iidxEnd = nonConciseIdx.size(); iidx < iidxEnd; ++iidx)
+		{
+			__TCdAlignRecord alignRec;
+			alignRec.pAlign = &(rAlignments[nonConciseIdx[iidx]]);
+			alignRec.pCdInfo = rDomInfo.FindCdInfo(alignRec.pAlign->m_uiPssmId);
+			if (alignRec.pCdInfo->m_iClusterId > 0) alignRec.pClst = rDomInfo.FindClusterInfo(alignRec.pCdInfo->m_iClusterId);
+			if (alignRec.pCdInfo->m_uiHierarchyRoot > 0)
+			{
+				if (alignRec.pCdInfo->m_uiHierarchyRoot == alignRec.pAlign->m_uiPssmId) alignRec.pRootCdInfo = alignRec.pCdInfo;
+				else alignRec.pRootCdInfo = rDomInfo.FindCdInfo(alignRec.pCdInfo->m_uiHierarchyRoot);
+			}
+			alignRec.idx = nonConciseIdx[iidx];
+			alignRec.idxidx = -1;
+			if (alignRec.pAlign->m_bRep)
+			{
+				alignRec.idxidx = repIdx++;
+				if (0 == alignRec.pAlign->m_iRepClass)	//non-multi
+				{
+					ExtractFeatAligns(alignRec, rAlignments, rDomInfo, rFeatAligns);
+					size_t featIdx1 = rFeatAligns.size();
+		    	
+					for (size_t i = featIdx0; i < featIdx1; ++i)
+					{
+						if (rFeatAligns[i].idx == alignRec.idx)
+							rFeatAligns[i].idxidx = alignRec.idxidx;
+						else
+							rFeatAligns[i].idxidx = ccsBase + amendCount++;
+					}
+					featIdx0 = featIdx1;
+				}
+			}
+			rDomAligns.push_back(alignRec);
+		}
+	}
+
+	
+	// -- added 9/9/2014 handling structure motifs -- attach to 
+	for (size_t iidx = 0, iidxEnd = m_vecSDIndice.size(); iidx < iidxEnd; ++iidx)
+	{
+		__TCdAlignRecord rec;
+		
+		rec.idx = m_vecSDIndice[iidx];
+		
+		rec.pAlign =  &(rAlignments[rec.idx]);
+		
+		rec.pCdInfo = rDomInfo.FindCdInfo(rec.pAlign->m_uiPssmId);
+		
+		rec.pClst = nullptr;
+		
+		rec.pRootCdInfo = nullptr;
+		
+		rec.idxidx = ccsBase + amendCount++;
+		
+		rFeatAligns.push_back(rec);
+	}
+}
+
+void TDomSeqAlignIndex::CreateConciseAmends(const vector<TDomSeqAlignment> &rAlignments, const TDomClusterIndexIfx & rDomInfo, const vector<TDomSeqAlignIndex::__TCdAlignRecord> &rConciseAligns, vector<TDomSeqAlignIndex::__TCdAlignRecord> &rAmendAligns) const
+{
+	rAmendAligns.clear();
+	for (size_t ics = 0, icsend = rConciseAligns.size(); ics < icsend; ++ics)
+	{
+		const __TCdAlignRecord &csrec = rConciseAligns[ics];
+		if (0 == csrec.pAlign->m_iRepClass && !csrec.pCdInfo->m_bCurated)	//monodom non-curated
+		{
+			__TCdAlignRecord arec;
+			
+			for (size_t iiamd = 0, iiamdend = m_vecStdIndice.size(); iiamd < iiamdend; ++iiamd)
+			{
+				arec.pAlign = &(rAlignments[m_vecStdIndice[iiamd]]);
+				if (0 == arec.pAlign->m_iRepClass && arec.pAlign->m_iRegionIdx == csrec.pAlign->m_iRegionIdx && arec.pAlign != csrec.pAlign)
+				{
+					arec.pCdInfo = rDomInfo.FindCdInfo(arec.pAlign->m_uiPssmId);
+					if (nullptr != arec.pCdInfo && arec.pCdInfo->m_bCurated)
+					{
+						if (arec.pAlign->m_bSpecQualified || !csrec.pAlign->m_bSpecQualified)
+						{
+							arec.pClst = rDomInfo.FindClusterInfo(arec.pCdInfo->m_iClusterId);
+							if (arec.pCdInfo->m_uiHierarchyRoot > 0) arec.pRootCdInfo = rDomInfo.FindCdInfo(arec.pCdInfo->m_uiHierarchyRoot);
+							rAmendAligns.emplace_back(arec);
+							goto labelNextHit;
+						}
+					}
+				}
+			}
+		}
+	labelNextHit:;
+	}
+}
+
+void TDomSeqAlignIndex :: ExtractFeatAligns(const TDomSeqAlignIndex::__TCdAlignRecord &rRepRec, const vector<TDomSeqAlignment> &rAlignments, const TDomClusterIndexIfx & rDomInfo, vector<TDomSeqAlignIndex::__TCdAlignRecord> &rResult) const
+{
+	__TCdAlignRecord rec;
+	if (rRepRec.pCdInfo->m_iClusterId > 0)	//has cluster, do cluster match
+	{
+		for (size_t fiidx = 0, fiidxEnd = m_vecQualifiedFeatIndice.size(); fiidx < fiidxEnd; ++fiidx)
+		{
+			rec.pAlign = &(rAlignments[m_vecQualifiedFeatIndice[fiidx]]);
+			// -- check if duplicated
+			for (const auto & r : rResult)
+			{
+				if (r.pAlign == rec.pAlign)
+					goto labelSkip1;
+			}
+					
+			
+			
+			if (rec.pAlign->m_iRegionIdx == rRepRec.pAlign->m_iRegionIdx)	//region match
+			{
+				rec.pCdInfo = rDomInfo.FindCdInfo(rec.pAlign->m_uiPssmId);
+				if (rec.pCdInfo->m_iClusterId == rRepRec.pCdInfo->m_iClusterId)	//matched cluster
+				{
+					rec.pClst = rRepRec.pClst;
+					rec.idx = m_vecQualifiedFeatIndice[fiidx];
+					//rec.idxidx = FeatIdx2Iidx(rec.idx);
+					if (rec.pCdInfo->m_uiHierarchyRoot > 0)
+					{
+						if (rec.pCdInfo->m_uiHierarchyRoot == rec.pAlign->m_uiPssmId) rec.pRootCdInfo = rec.pCdInfo;
+						else rec.pRootCdInfo = rDomInfo.FindCdInfo(rec.pCdInfo->m_uiHierarchyRoot);
+					}
+					rResult.push_back(rec);
+				}
+			}
+		labelSkip1:
+			;
+		}
+	}
+	else	//no cluster, just match region class -- should not happen
+	{
+		for (size_t fiidx = 0, fiidxEnd = m_vecQualifiedFeatIndice.size(); fiidx < fiidxEnd; ++fiidx)
+		{
+			rec.pAlign = &(rAlignments[m_vecQualifiedFeatIndice[fiidx]]);
+			
+			// -- check if duplicated
+			for (const auto & r : rResult)
+			{
+				if (r.pAlign == rec.pAlign)
+					goto labelSkip2;
+			}
+			if (rec.pAlign->m_iRegionIdx == rRepRec.pAlign->m_iRegionIdx)	//region match
+			{
+				rec.pCdInfo = rDomInfo.FindCdInfo(rec.pAlign->m_uiPssmId);
+				rec.pClst = rDomInfo.FindClusterInfo(rec.pCdInfo->m_iClusterId);
+				if (rec.pCdInfo->m_uiHierarchyRoot > 0)
+				{
+					if (rec.pCdInfo->m_uiHierarchyRoot == rec.pAlign->m_uiPssmId) rec.pRootCdInfo = rec.pCdInfo;
+					else rec.pRootCdInfo = rDomInfo.FindCdInfo(rec.pCdInfo->m_uiHierarchyRoot);
+				}
+				rec.idx = m_vecQualifiedFeatIndice[fiidx];
+				//rec.idxidx = FeatIdx2Iidx(rec.idx);
+				rResult.push_back(rec);
+			}
+		labelSkip2:
+			;
+		}
+	}
+}
+
+
+void TSnpData::ConstructTitle(string& rDest) const
+{
+	rDest = ConstructTitle();
+}
+string TSnpData::ConstructTitle(void) const
+{
+	char dimBuf[12];
+	sprintf(dimBuf, ":%c%d%c", cOriRes, iMstPos + RESIDUE_DISPLAY_OFFSET, cMutRes);
+	return strType + strId + dimBuf;
+}
+
+
+
+
+
+
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offldata.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offldata.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/offldata.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/offldata.hpp	2018-03-13 14:39:35.344386000 -0400
@@ -0,0 +1,834 @@
+#if !defined(__OFFL_DATA__)
+#define __OFFL_DATA__
+#include "segset.hpp"
+#if defined(__DB_OFFLINE__)
+#include "envdef.hpp"
+#include "ptrmap.hpp"
+#else
+#include <NcbiBase/envdef.hpp>
+#include <BasicUtils/ptrmap.hpp>
+#endif
+#include <objects/seq/seq__.hpp>
+#include <vector>
+#include <string>
+
+constexpr const PssmId_t INVALIDPSSMID = 100000000;
+constexpr const ClusterId_t INVALIDCLUSTERID = -1;
+/**********************************************************************
+*	Constants. To avoid static object fiasco
+***********************************************************************/
+struct READINGFRAME
+{
+	static constexpr const int RF_SIZE = 3;	//reading frame size
+	static constexpr const int TOTAL_RFS = RF_SIZE + RF_SIZE;	//total reading frames
+	static const char * RF_TITLES[TOTAL_RFS];
+	static int RF_IDS[TOTAL_RFS];
+	
+	static struct tagTitle
+	{
+		const char * operator [] (int idx) noexcept;
+	} title;
+	
+	static struct tagId
+	{
+		int operator [] (int idx) noexcept;
+	} id;
+	
+	// -- return idx from id, invalid id, regardless of the value, will return 0
+	static int IndexOf (int id) noexcept;
+	
+	// -- rf: reading frame id: 1, 2, 3 as positive, -1, -2, -3. if 0 or any other invalid value, will be treated as protein and return the same value as input cooridinate 
+	static SeqPos_t NA2Pr(SeqPos_t napos, int rf = 0, SeqLen_t na_len = 0);
+	static SeqPos_t Pr2NA(SeqPos_t prpos, int rf = 0, SeqLen_t pr_len = 0);
+	
+	static SeqPos_t NAPlus2Pr(SeqPos_t na) {return na / RF_SIZE;}
+	static SeqPos_t Pr2NAPlus(SeqPos_t pr, int rf) {return pr * READINGFRAME::RF_SIZE + rf;}
+	static SeqPos_t NAMinus2Pr(SeqPos_t na, SeqLen_t na_seq_len) {return (na_seq_len - na - 1) / READINGFRAME::RF_SIZE;}
+	static SeqPos_t Pr2NAMinus(SeqPos_t pr, int rf, SeqLen_t aa_seq_len) {return (aa_seq_len - pr - 1) * READINGFRAME::RF_SIZE - rf - 1;}
+	
+};
+
+
+/**********************************************************************
+*	Result redundent level
+***********************************************************************/
+struct TDataModes
+{
+	enum EIndex
+	{
+		eEnumStart = 0,
+		e_rep = eEnumStart,
+		e_std = e_rep + 1,
+		e_full = e_std + 1,
+		eEnumStop = e_full + 1
+	};
+	
+	static const EIndex eDefault = e_rep;
+	static const char* dimLits[eEnumStop - eEnumStart];
+	static const char* dimDisplay[eEnumStop - eEnumStart];
+};
+
+
+/**********************************************************************
+*	Target data
+***********************************************************************/
+struct TTargetData
+{
+	enum EIndex
+	{
+		eEnumStart = 0,
+		e_doms = eEnumStart,
+		e_feats = e_doms + 1,
+		e_both = e_feats + 1,
+		eEnumStop = e_both + 1
+	};
+	
+	static const EIndex eDefault = e_both;
+	static const char* dimLits[eEnumStop - eEnumStart];
+	static const char* dimDisplay[eEnumStop - eEnumStart];
+};
+
+/**********************************************************************
+*	Special treatment: PDB IDs
+*	PDB IDs have been a mess due to the one-letter chain representation
+*	Currently they are allowing up to 4 letters to identify a chain. The 
+*	delimit between molecule and chain is not in the specs
+*	Reference:
+*		https://www.wwpdb.org/deposition/preparing-pdbx-mmcif-files
+***********************************************************************/
+class CPdbId
+{
+	
+public:
+	// -- Numeric number that starts a pdb id. Old format has only one digit.
+	// -- Future new versions will be like pdb_00001abc
+	typedef unsigned int NUM_ID;
+	static constexpr const size_t NUM_ID_DIGITS = 5;
+	static constexpr const char * NUM_ID_FMT = "%05u";
+	static constexpr const char * NEW_SIG = "pdb_";
+	static constexpr const size_t SIG_LEN = strlen(NEW_SIG);
+	static constexpr const int PDBMOL_LEN = 3;
+	static constexpr const int PDBCHN_MAX_LEN = 4;
+	static constexpr const char DELIM_CHAR = '_';
+	CPdbId(void);
+	
+	CPdbId(const std::string &acxn, bool AA2a = true);
+	
+	
+	
+	bool IsValid(void) const;
+	
+	// -- AA2a: if treat chain id AA as a - NCBI entrez special?
+	// -- only if chain id has only two identical uppercase letters
+	bool SetAcxn(const std::string & acxn, bool AA2a = true);
+	
+	
+	std::string GetMol(void) const;
+	std::string GetChain(void) const;
+	operator std::string(void) const;
+	
+	//void ParsePdbAcc(const std::string& rPdbAcc);
+	//std::string GetStringAcc(char cDelimit = 0, char cEndChar = 0) const;
+	//ncbi::CRef<ncbi::objects::CSeq_id> ConstructPdbId(void) const;
+	//
+	//const char * GetMol(void) const {return dimMol;}
+	//char GetChainLetter(void) const {return cChainLetter;}
+	//unsigned int GetMmdbId(void) const {return uiMmdbId;}
+	//
+	//
+	//bool IsValid(void) const {return 0 != dimMol[0];}
+	//bool operator == (const CPdbId& dst) const;
+	//bool operator == (const ncbi::objects::CSeq_id &dstId) const;
+	//bool operator == (const ncbi::objects::CPDB_seq_id &dstId) const;
+	char m_usedelim;
+protected:
+	NUM_ID m_numid;
+	char m_mol[PDBMOL_LEN + 1];	//for tail '\0'
+	char m_chain[PDBCHN_MAX_LEN + 1];
+	
+};
+
+
+
+/**********************************************************************
+*	Biodata structure -- feature (site annotation)
+*	Make it an individual class (not inherit segset class) because 
+* in-house version of data may expand TSeg_base and inherit from there
+***********************************************************************/
+
+struct TDocsum
+{
+	// -- data members
+	GI_t m_iGi;
+	std::string m_strAccession;
+	std::string m_strNcbiId;
+	SeqLen_t m_uiSeqLen;
+	std::string m_strTitle;
+	//enum CSeq_inst::EMol
+	//{
+	//	ncbi::eMol_not_set =   0,  ///<   > cdna = rna
+	//	eMol_dna     =   1,
+	//	eMol_rna     =   2,
+	//	eMol_aa      =   3,
+	//	eMol_na      =   4,  ///< just a nucleic acid
+	//	eMol_other   = 255
+	//};	
+	int m_iMolType;
+	
+	// -- taxonomy information
+	TaxId_t m_iTaxId;
+	// -- reference http://www.ncbi.nlm.nih.gov/Taxonomy/Utils/wprintgc.cgi
+	int m_iGenCode;
+	int m_iMGenCode;	//mitochondrial genetic code
+	std::string m_strSciName;	//scientific name
+	std::string m_strBlastName;	//blast name
+	std::string m_strCommonName;	//common name
+	
+	TDocsum(void):
+		m_iGi(0), m_strAccession(k_strEmptyString), m_strNcbiId(k_strEmptyString), m_uiSeqLen(0), m_strTitle(k_strEmptyString), m_iMolType(ncbi::objects::CSeq_inst::eMol_not_set),
+		m_iTaxId(0), m_iGenCode(1), m_iMGenCode(2), m_strSciName(k_strEmptyString), m_strBlastName(k_strEmptyString), m_strCommonName(k_strEmptyString) {};
+	
+	void Reset(void);
+};
+
+struct TSequence: public TDocsum
+{
+	enum EValidLevel
+	{
+		e_Invalid = 0,
+		e_Current,
+		e_NonCurrent,
+		e_IsLocal,
+		e_ValidStop
+	};
+	int m_iInputType;	//CCleanInput::EStringDataType values
+	std::string m_strCleanedInput;	//also from CCleanInput
+	std::string m_strSeqData;	//1-letter seqdata
+	std::string m_Src;
+	std::string m_B64PackedIds;
+	int m_iValid;
+	int m_iStatus;	//misc status for compatibility, previous field name is m_iOid
+	PIG_t m_iPig;	//if has one. otherwise 0
+	// -- added 2012/4/12 -- for range. m_iStart is default to 0, m_iEnd is default to -1, meaning whole length.
+	SeqPos_t m_iFrom;
+	SeqPos_t m_iTo;
+	//std::vector<int> m_vecGis;	//from db, 	alias gi
+	
+	struct __SegMask
+	{
+		int from;
+		int to;
+		int rf;	//reading frame
+		__SegMask(void): from(0), to(0), rf(0) {};
+	};
+	
+	std::vector<__SegMask> m_vecMaskedRegions;
+	// -- methods
+	TSequence(void):
+		m_iInputType(0), m_strCleanedInput(k_strEmptyString), m_strSeqData(k_strEmptyString), m_Src(k_strEmptyString), m_iValid(e_Invalid), m_iStatus(0), m_iPig(0), m_iFrom(0), m_iTo(-1), m_vecMaskedRegions()
+	{};
+	// -- return if have seqdata. cannot blast without it.
+	virtual SeqLen_t GetSeqLength(void) const {return m_uiSeqLen;}
+	void Reset(void);
+};
+
+
+
+struct TDomSite: public CSegSet
+{
+	enum EFeatType	//this is arbitrary. 
+	{
+		eType_Other = 0,
+		eType_Active = 1,
+		eType_PolyPBinding = 2,
+		eType_NtBinding = 3,
+		eType_IonBinding = 4,
+		eType_ChemBinding = 5,
+		eType_PostTransMod = 6,
+		eType_StructMotif = 7
+	};
+	static const int TOTAL_OFFL_TYPES = eType_StructMotif + 1;	//for offline only
+	static const char * GENERIC_SITE_TITLE;
+	static const char * FEATTYPES[TOTAL_OFFL_TYPES];
+	
+	//static std::map<int, std::string> m_mapActualFeatTypes;
+	
+	static const Flags_t STRUCTURE_BASED_EVIDENCE = 0x1 << 0;
+	static const Flags_t REFERENCE_BASED_EVIDENCE = 0x1 << 1;
+	static const Flags_t ADDITIONAL_COMMENTS = 0x1 << 2;
+	
+	
+	std::string m_strTitle;	//short title
+	std::string m_strDescr;	//descrption, future use
+	std::string m_strMotif;
+	int m_iMotifuse;
+	int m_iIndex;	//index within pssm or other sequence
+	int m_iType;
+	SeqPos_t m_iCompleteSize;
+	Flags_t m_flags;
+	
+	TDomSite(void):
+		CSegSet(),
+		m_strTitle(), m_strDescr(), m_strMotif(), m_iMotifuse(0), m_iIndex(0), m_iType(0), m_iCompleteSize(0), m_flags(0)
+	{};
+	
+	void Reset(void);
+	
+	virtual SeqPos_t GetCompleteSize(void) const {return m_iCompleteSize;}
+	//void SetMotifStr(const std::string &rMotifStr) {m_strMotif = rMotifStr;}
+	// -- this is to checked the mapped site with motif. If rSeqData is provided, it ckecks
+	// -- both the residue position and type. If rSeqData is not provided, just check for
+	// -- all non-x residues are mapped. return values:
+	// -- 0: success or No motif to check.
+	// -- 1: Essential positions not complete
+	// -- 2: Essential positions complete but residue type mismatch.
+	//TResiduePos contains mapped and original positions, both on protein sequence
+	int MotifCheck(const std::vector<TSeg_base::TResiduePos> &rMappedRes, const std::string &rSeqData = k_strEmptyString) const;
+};
+
+constexpr const char * CLUSTERSIG = "cl";
+constexpr const char * CURATEDSIG = "cd";
+constexpr const char * STRUCTSIG = "sd";
+
+bool DomAcxnSig(const std::string &acxn, const char * sig);
+
+struct TCluster
+{
+	PssmId_t m_uiPssmId;
+	SeqLen_t m_uiLength;	// for cluster, this is the cluster size. For TDomain this is the domain length
+	ClusterId_t m_iClusterId;
+	std::string m_strAccession;
+	std::string m_strShortName;
+	std::string m_strTitle;
+	std::string m_strDefline;
+	TCluster(void);
+	void Reset(void);
+};
+
+struct TDomain: public TCluster
+{
+	PssmId_t m_uiHierarchyRoot;	//root pssmid
+	PssmId_t m_uiHierarchyParent;	//root pssmid
+	PssmId_t m_uiClusterPssmId;
+	double m_dMinBitScore;
+	bool m_bCurated;
+	bool m_bIsStructDom;
+	bool m_bMultiDom;
+	std::string m_strConsensus;
+	std::string m_strSource;	//where is this domain defined, usually db name.
+	
+	std::list<TDomSite> m_lstSpecificFeatures;
+	std::list<TDomSite> m_lstGenericFeatures;
+	TDomain(void);
+	void Reset(void);
+};
+
+// -- a template interface!
+struct TDomClusterIndexIfx
+{
+	virtual const TDomain * FindCdInfo(PssmId_t pssmid) const = 0;
+	virtual const TDomain * FindCdInfo(const std::string &acxn) const = 0;
+	virtual const TCluster * FindClusterInfo(ClusterId_t clusterid) const = 0;
+	virtual const TCluster * FindClusterByPssmId(PssmId_t pssmid) const = 0;
+};
+
+class CDomClusterIndex: public TDomClusterIndexIfx
+{
+public:
+	// -- Since TCluster is a base class of TDomain, the sort object
+	// -- can share
+	struct TSortByPssmId
+	{
+		int operator () (const TCluster & v1, const TCluster & v2) const
+		{
+			return (int)v1.m_uiPssmId - (int)v2.m_uiPssmId;
+		}
+		
+		int operator () (PssmId_t pssmid, const TCluster & v) const
+		{
+			return (int)pssmid - (int)v.m_uiPssmId;
+		}
+	};
+	
+	struct TSortByClusterId
+	{
+		int operator () (const TCluster & v1, const TCluster & v2) const
+		{
+			return v1.m_iClusterId - v2.m_iClusterId;
+		}
+		
+		int operator () (ClusterId_t clstid, const TCluster & v) const
+		{
+			return (int)clstid - (int)v.m_iClusterId;
+		}
+	};
+	
+	struct TSortByAcxn
+	{
+		int operator () (const TCluster & v1, const TCluster & v2) const
+		{
+			return v1.m_strAccession.compare(v2.m_strAccession);
+		}
+		
+		int operator () (const std::string & acxn, const TCluster & v) const
+		{
+			return acxn.compare(v.m_strAccession);
+		}
+	};
+	
+	typedef CPtrMap<PssmId_t, TDomain, TSortByPssmId> TPssmId2CdInfo;
+	typedef CPtrMap<std::string, TDomain, TSortByAcxn> TAcxn2CdInfo;
+	typedef CPtrMap<PssmId_t, TCluster, TSortByPssmId> TPssmId2ClusterInfo;
+	typedef CPtrMap<ClusterId_t, TCluster, TSortByClusterId> TClusterId2ClusterInfo;
+	
+	virtual const TDomain * FindCdInfo(PssmId_t pssmid) const {return m_pssmid2cd.Find(pssmid);}
+	virtual const TDomain * FindCdInfo(const std::string & acxn) const {return m_acxn2cd.Find(acxn);}
+	virtual const TCluster * FindClusterInfo(ClusterId_t clusterid) const {return m_clid2fam.Find(clusterid);}
+	virtual const TCluster * FindClusterByPssmId(PssmId_t pssmid) const {return m_pssmid2fam.Find(pssmid);}
+	
+	CDomClusterIndex(void): TDomClusterIndexIfx(), m_pssmid2cd(), m_acxn2cd(), m_pssmid2fam(), m_clid2fam() {};
+	
+	
+	template<typename _TDomStore, typename _ClusterStore>
+	CDomClusterIndex(_TDomStore& doms, _ClusterStore& clsts):
+		TDomClusterIndexIfx(),
+		m_pssmid2cd(doms.GetPointers()), m_acxn2cd(doms.GetPointers()), m_pssmid2fam(clsts.GetPointers()), m_clid2fam(clsts.GetPointers())
+	{};
+	
+	
+	void InsertDomainIdx(TDomain *p);
+	void InsertClusterIdx(TCluster *p);
+	
+	void Reset(void);
+	
+	template<typename _T>
+	void SetPssmId2CdPtrs(_T&& vec) {m_pssmid2cd.Reset(std::forward<_T> (vec));}
+		
+	template<typename _T>
+	void SetAcxn2CdPtrs(_T&& vec) {m_acxn2cd.Reset(std::forward<_T> (vec));}
+	
+	template<typename _T>
+	void SetPssmId2ClusterPtrs(_T&& vec) {m_pssmid2fam.Reset(std::forward<_T> (vec));}
+		
+	template<typename _T>
+	void SetClusterId2ClusterPtrs(_T&& vec) {m_clid2fam.Reset(std::forward<_T> (vec));}
+	
+protected:
+	
+	TPssmId2CdInfo m_pssmid2cd;
+	TAcxn2CdInfo m_acxn2cd;
+	TPssmId2ClusterInfo m_pssmid2fam;
+	TClusterId2ClusterInfo m_clid2fam;
+};
+
+struct TDomArch
+{
+	ArchId_t m_uiArchId;	//specific or not
+	std::string m_strArchString;
+	std::string m_strReviewLevel;
+	TDomArch(void): m_uiArchId(0), m_strArchString(k_strEmptyString), m_strReviewLevel() {};
+	TDomArch(ArchId_t archid, const std::string &archstr = k_strEmptyString): m_uiArchId(archid), m_strArchString(archstr), m_strReviewLevel() {};
+	TDomArch(ArchId_t archid, std::string &&archstr): m_uiArchId(archid), m_strArchString(move(archstr)), m_strReviewLevel() {};
+	
+/*debug*******************************************************/
+#if defined(_DEBUG)
+void Print(void) const;
+#endif
+// ***********************************************************/
+	void Reset(void);
+};
+
+
+
+struct TSpDomArch: public TDomArch
+{
+	std::string m_strName;
+	std::string m_strLabel;
+	ArchId_t m_uiSupFamArchId;	//superfamily
+	
+	TSpDomArch(void): TDomArch(), m_strName(k_strEmptyString), m_strLabel(k_strEmptyString), m_uiSupFamArchId(0) {};
+	//TSpDomArch(ArchId_t archid, const std::string &archstr = k_strEmptyString): TDomArch(archid, k_strEmptyString), m_strName(k_strEmptyString), m_strLabel(k_strEmptyString), m_uiSupFamArchId(0) {};
+	template<typename TArchStr>
+	TSpDomArch(ArchId_t archid, TArchStr&& archstr):
+		TDomArch(archid, std::forward<TArchStr> (archstr)), m_strName(k_strEmptyString), m_strLabel(k_strEmptyString), m_uiSupFamArchId(0) {};
+
+/*debug*******************************************************/
+#if defined(_DEBUG)
+void Print(void) const;
+#endif
+// ***********************************************************/
+	void Reset(void);
+};
+
+// -- interface
+struct TArchIndexIfx
+{
+	virtual const TSpDomArch * FindSpArch(ArchId_t archid) const = 0;
+	virtual const TSpDomArch * FindSpArch(const std::string & archstr) const = 0;
+	
+	virtual const TDomArch * FindFamArch(ArchId_t archid) const = 0;
+	virtual const TDomArch * FindFamArch(const std::string & archstr) const = 0;
+};
+
+class CArchIndex: public TArchIndexIfx
+{
+public:
+	
+	// -- as TDomArch is a base class of TSpDomArch, the sort object can share
+	struct TSortByArchStr
+	{
+		int operator () (const TDomArch & v1, const TDomArch & v2) const
+		{
+			return v1.m_strArchString.compare(v2.m_strArchString);
+		}
+		int operator () (const std::string & archstr, const TDomArch & v) const
+		{
+			return archstr.compare(v.m_strArchString);
+		}
+	};
+	
+	struct TSortByArchId
+	{
+		int operator () (const TDomArch & v1, const TDomArch & v2) const
+		{
+			return (int)v1.m_uiArchId - (int)v2.m_uiArchId;
+		}
+		int operator () (unsigned int archid, const TDomArch & v) const
+		{
+			return (int)archid - (int)v.m_uiArchId;
+		}
+	};
+	
+	typedef CPtrMap<ArchId_t, TSpDomArch, TSortByArchId> TArchId2SpArch;
+	typedef CPtrMap<std::string, TSpDomArch, TSortByArchStr> TArchStr2SpArch;
+	
+	typedef CPtrMap<ArchId_t, TDomArch, TSortByArchId> TArchId2FamArch;
+	typedef CPtrMap<std::string, TDomArch, TSortByArchStr> TArchStr2FamArch;
+		
+	virtual const TSpDomArch * FindSpArch(ArchId_t archid) const {return m_id2sp.Find(archid);}
+	virtual const TSpDomArch * FindSpArch(const std::string & archstr) const {return m_str2sp.Find(archstr);}
+	
+	virtual const TDomArch * FindFamArch(ArchId_t archid) const {return m_id2fam.Find(archid);}
+	virtual const TDomArch * FindFamArch(const std::string & archstr) const {return m_str2fam.Find(archstr);}
+	
+	CArchIndex(void): TArchIndexIfx(), m_id2sp(), m_str2sp(), m_id2fam(), m_str2fam() {};
+	
+	void InsertSpArchIdx(TSpDomArch *p);
+	void InsertFamArchIdx(TDomArch *p);
+	
+	
+	template<typename _TSpArchStore, typename _FamArchStore>
+	CArchIndex(_TSpArchStore& sp, _FamArchStore& fam):
+		TArchIndexIfx(),
+		m_id2sp(sp.GetPointers()), m_str2sp(sp.GetPointers()), m_id2fam(fam.GetPointers()), m_str2fam(fam.GetPointers())
+	{};
+	
+	void Reset(void);
+
+	template<typename _T>
+	void SetArchId2SpPtrs(_T&& vec) {m_id2sp.Reset(std::forward<_T> (vec));}
+		
+	template<typename _T>
+	void SetArchStr2SpPtrs(_T&& vec) {m_str2sp.Reset(std::forward<_T> (vec));}
+	
+	template<typename _T>
+	void SetArchId2FamPtrs(_T&& vec) {m_id2fam.Reset(std::forward<_T> (vec));}
+		
+	template<typename _T>
+	void SetArchStr2FamPtrs(_T&& vec) {m_str2fam.Reset(std::forward<_T> (vec));}
+	
+protected:
+	TArchId2SpArch m_id2sp;
+	TArchStr2SpArch m_str2sp;
+	TArchId2FamArch m_id2fam;
+	TArchStr2FamArch m_str2fam;
+};
+
+
+
+
+struct TSeqAlignment
+{
+	enum EIndex
+	{
+		eEnumStart = 0,
+		// ------------------
+		SORT_BY_EVALUE = eEnumStart,
+		SORT_BY_BITSCORE,
+		SORT_BY_SEQ_IDENTITY,
+		SORT_BY_ALIGNED_LENGTH,
+		SORT_BY_SCORE_COMBO,
+		
+		// ------------------
+		eEnumStop
+	};
+	
+	
+	static const EIndex eDefault = SORT_BY_EVALUE;
+	static const char* dimLits[eEnumStop];
+	static const char* dimLabels[eEnumStop];
+	
+	typedef bool LPFN_COMPARE(const TSeqAlignment *p1, const TSeqAlignment *p2);
+	
+	static bool EValueCompare(const TSeqAlignment *p1, const TSeqAlignment *p2)
+	{
+		return p1->m_dEValue < p2->m_dEValue;
+	}
+	
+	static bool BitScoreCompare(const TSeqAlignment *p1, const TSeqAlignment *p2)
+	{
+		return p1->m_dBitScore > p2->m_dBitScore;
+	}
+	
+	static bool AlignedLengthCompare(const TSeqAlignment *p1, const TSeqAlignment *p2)
+	{
+		return p1->m_uiAlignedLen > p2->m_uiAlignedLen;
+	}
+	
+	static bool SeqIdentityCompare(const TSeqAlignment *p1, const TSeqAlignment *p2)
+	{
+		return p1->m_dSeqIdentity > p2->m_dSeqIdentity;
+	}
+	
+	
+	static bool ScoreComboEvaluate(const TSeqAlignment *p1, const TSeqAlignment *p2)
+	{
+		if (p1->m_dEValue < p2->m_dEValue) return true;
+		else if (p1->m_dEValue > p2->m_dEValue) return false;
+		else return (p1->m_dBitScore > p2->m_dBitScore);
+	}
+	
+	struct TSortObj
+	{
+		TSortObj(LPFN_COMPARE lpfnCompare): m_lpfnCompare(lpfnCompare) {};
+		TSortObj(int iSortIdx);
+		LPFN_COMPARE * GetCompareFunc(void) const {return m_lpfnCompare;}
+		
+		bool operator () (const TSeqAlignment *p1, const TSeqAlignment *p2)
+		{
+			return m_lpfnCompare(p1, p2);
+		}
+		
+		LPFN_COMPARE *m_lpfnCompare;
+	};
+	
+	// -- added 6/27/2011 -- for na aligns
+	enum EAlignType
+	{
+		eNormal,	//Na to Na or prot to prot
+		ePr2Na
+	};
+	
+	
+	static void PrintEValue(char *buf, double eval);
+	static void PrintBitScore(char *buf, double bscore);
+	static void PrintPercentage(char *buf, double pct);	//pct is 0.0~100.0
+	
+
+	// -- scores
+	SeqLen_t m_uiAlignedLen;
+	double m_dAlignedPct;
+	int m_iScore;
+	double m_dEValue;
+	double m_dBitScore;
+	int m_iNumIdent;
+	double m_dSeqIdentity;
+	EAlignType m_eAlignType;
+
+
+
+	// -- added 6-23-2011: for NA search
+	// -- defined in objects/seqloc/Na_strand.hpp
+	int m_eStrand;
+	int m_iReadingFrame;	// 0 -- 2
+	//SeqPos_t m_iSlaveCoordConvert;	//a slave coordination conversion factor for negative factor
+	
+	// -- processed align info
+	std::vector<SeqPos_t> m_vecMStarts;
+	std::vector<SeqPos_t> m_vecSStarts;
+	std::vector<SeqLen_t> m_vecLens;
+	//std::vector<TGap> m_mstGaps;
+	int m_iRegionIdx;	//region on the query sequence. 
+	
+	CSegSet m_ClipSet;
+	
+	// -- methods
+	TSeqAlignment(void):
+		m_uiAlignedLen(0), m_dAlignedPct(0.0), m_iScore(0), m_dEValue(0.0), m_dBitScore(0), m_iNumIdent(0), m_dSeqIdentity(0.0),
+		m_eAlignType(eNormal),
+		m_eStrand(ncbi::objects::eNa_strand_unknown),
+		m_iReadingFrame(0), m_vecMStarts(), m_vecSStarts(), m_vecLens(),
+		m_iRegionIdx(0), m_ClipSet()
+	{};
+	
+	inline
+	void PrintEValue(char *buf) const {TSeqAlignment::PrintEValue(buf, m_dEValue);}
+	inline
+	void PrintBitScore(char *buf) const {TSeqAlignment::PrintEValue(buf, m_dBitScore);}
+	inline
+	void PrintAlignedPct(char *buf) const {TSeqAlignment::PrintEValue(buf, m_dAlignedPct);}
+	inline
+	void PrintSeqIdentity(char *buf) const {TSeqAlignment::PrintEValue(buf, m_dSeqIdentity);}
+	
+	// -- this is for getting the aligned string for cddsrv.
+	std::string GetAlignString(void) const;
+
+	
+	//void StrandConvert(CSegSet &segset) const;
+	void Pr2NaConvert(CSegSet &segset) const;
+	void MapSegSet(CSegSet &segset, bool doConvert = true) const;
+	//void CreateNormalSegs(CSegSet &segset) const;
+	void CreateSlaveSegs(CSegSet &segset) const;
+	void CreateMasterSegs(CSegSet &segset) const;
+	void CalcMasterGaps(SeqLen_t gapThreshold, CSegSet &segset) const;
+		
+	int GetRFIdx(SeqLen_t seqLen) const;
+
+	int Na2Pr(SeqPos_t na, SeqPos_t &pr) const;
+	int Pr2Na(SeqPos_t pr, SeqPos_t &na) const;
+};
+
+// -- this is to convert denseg align format to TSeqAlignment
+void CleanAlignment(const std::vector<SeqPos_t> & rSrcStarts, const std::vector<SeqLen_t> & rSrcLens, std::vector<SeqPos_t>& rMStarts, std::vector<SeqPos_t>& rSStarts, std::vector<SeqLen_t>& rLens);
+
+struct TDomSeqAlignment: public TSeqAlignment
+{
+	static constexpr const SeqLen_t GAP_THRESHOLD = 35;
+	PssmId_t m_uiPssmId;
+	// -- calculated
+	SeqPos_t m_iFrom;
+	SeqPos_t m_iTo;
+	double m_dNMissing;
+	double m_dCMissing;
+	bool m_bSpecQualified;	//higher bitscore than threshold
+	int m_iRepClass;	//single and multi -- sort separately
+	bool m_bRep;
+	bool m_bLifted;	//lifted by a higher evalue and approved by architecture frequencs
+	bool m_bSuppressed;
+	
+	
+	TDomSeqAlignment(void):
+		m_uiPssmId(0), m_iFrom(0), m_iTo(0), m_dNMissing(0.0), m_dCMissing(0.0), m_bSpecQualified(false), m_iRepClass(0), m_bRep(0), m_bLifted(0), m_bSuppressed(0)
+	{};
+	
+	// -- including properly mapped features
+	
+	// -- extra
+	bool IsSpecific(void) const {return m_bRep && m_bSpecQualified;}
+	//bool IsSpecific(void) const {return m_bSpecQualified;}
+	
+	// -- map a feature to dst. return 0: success. Return 1: not all
+	// -- essential residues are mapped. return 2: residue type
+	// -- mismatch (if seqData is not empty)
+	
+	// -- convert segs (master coordinates already) to translated cooridinates so TDomSite can perform motif check.
+	// -- return reading frame for the alignment, which can be used to select a translation frame index (0 - 5). if 
+	// -- return 0 for protein sequence that needs no translation.
+	int GetTranslatedPosMap(const CSegSet &segs, SeqLen_t seqLen, std::vector<TSeg_base::TResiduePos> &rMappedAAPos) const;
+};
+
+int MapCdFeature(const TDomSite &rFeat, const TDomSeqAlignment &rAlign, SeqLen_t seqLen, const std::string dimAaData[], CSegSet &dst);
+
+
+struct TDomSeqAlignIndex
+{
+	struct __TCdAlignRecordBase
+	{
+		const TDomSeqAlignment * pAlign;
+		const TDomain * pCdInfo;
+		
+		__TCdAlignRecordBase(void): pAlign(nullptr), pCdInfo(nullptr) {};
+	};
+	
+	struct __TEquClusterHit
+	{
+		bool operator () (const __TCdAlignRecordBase &a, const __TCdAlignRecordBase &b) const;
+	};
+	
+	// -- this compare assume 
+	struct __TEquivalentHit
+	{
+		bool operator () (const __TCdAlignRecordBase &a, const __TCdAlignRecordBase &b) const;
+	};
+	
+	struct TSortByFromObj
+	{
+		bool operator () (const __TCdAlignRecordBase &a, const __TCdAlignRecordBase &b) const
+		{
+			return a.pAlign->m_iFrom < b.pAlign->m_iFrom;
+		}
+	};
+	
+
+	struct __TCdAlignRecord: public __TCdAlignRecordBase
+	{
+		const TCluster * pClst;
+		const TDomain * pRootCdInfo;
+		
+		//const CDomainInfoMaps::TCuratedClusterInfo * pCuratedClst;
+		size_t idx;	//need to give area id an index to align info
+		size_t idxidx;	//the index in concise
+		
+		__TCdAlignRecord(void): __TCdAlignRecordBase(), pClst(nullptr), pRootCdInfo(nullptr), idx(-1), idxidx(-1) {};
+	};
+	std::vector<size_t> m_vecSortedIndice;
+	std::vector<size_t> m_vecConciseIndice;
+	std::vector<size_t> m_vecStdIndice;
+	// -- modified 5/8/2012 -- now feature and rep hits are separated -- since we introduced non-NCBI-curated specific hits
+	std::vector<size_t> m_vecQualifiedFeatIndice;	//should be every region's best evalue curated
+	// -- modified 9/8/2014 -- Structure domains to add motif annotations
+	std::vector<size_t> m_vecSDIndice;
+	
+	TDomSeqAlignIndex(void): m_vecSortedIndice(), m_vecConciseIndice(), m_vecStdIndice(), m_vecQualifiedFeatIndice(), m_vecSDIndice() {};
+	void CreateRecordSets(const std::vector<TDomSeqAlignment> &rAlignments, const TDomClusterIndexIfx & rDomInfo, std::vector<__TCdAlignRecord> &rDomAligns, std::vector<__TCdAlignRecord> &rFeatAligns, int mode) const;
+	// -- added 12/6/2016: Concise view now should always include curated models (if available).
+	void CreateConciseAmends(const std::vector<TDomSeqAlignment> &rAlignments, const TDomClusterIndexIfx & rDomInfo, const std::vector<__TCdAlignRecord> &rConciseAligns, std::vector<__TCdAlignRecord> &rAmendAligns) const;
+	void ExtractFeatAligns(const __TCdAlignRecord &rRepRec, const std::vector<TDomSeqAlignment> &rAlignments, const TDomClusterIndexIfx & rDomInfo, std::vector<__TCdAlignRecord> &rResult) const;
+};
+
+
+struct TDomQuery: public TSequence
+{
+	int m_iDataSrc;	//precalc or live
+	std::vector<TDomSeqAlignment> m_vecAlignments;	//alignments from rpsblast
+	TDomSeqAlignIndex m_dimSplitAligns[READINGFRAME::TOTAL_RFS];
+	
+	TDomQuery(void): TSequence(), m_iDataSrc(0), m_vecAlignments(), m_dimSplitAligns() {};
+	
+	
+	struct __MotifType
+	{
+		std::list<TDomSite> :: const_iterator iterMotifFeat;
+		std::vector<TDomSeqAlignIndex::__TCdAlignRecord> :: const_iterator iterAlignRec;
+		bool bIsSpecific;
+		PssmId_t uiSrcPSSMId;
+		__MotifType(std::list<TDomSite> :: const_iterator iterM, std::vector<TDomSeqAlignIndex::__TCdAlignRecord> :: const_iterator iterA, bool spec, PssmId_t srcpssm): 
+			iterMotifFeat(iterM), iterAlignRec(iterA), bIsSpecific(spec), uiSrcPSSMId(srcpssm) {};
+	};
+	
+};
+
+struct TSnpData
+{
+	int iSnpId;
+	int iSnpTitle;
+	SeqPos_t iMstPos;	// -- 0 based
+	SeqPos_t iNbrPos;	// -- 0 based
+	std::string strType;	//such as "rs"
+	std::string strId;	//numeric
+	char cOriRes;	//original residue
+	char cMutRes;	//mutate to residue
+	
+	TSnpData(void):
+		iSnpId(0), iSnpTitle(-1), iMstPos(-1), iNbrPos(-1), strType(NcbiEmptyString), strId(NcbiEmptyString), cOriRes(' '), cMutRes(' ')
+	{};
+	
+	inline
+	bool IsSynon(void) const {return cOriRes == cMutRes;}
+	
+	void ConstructTitle(std::string& rDest) const;
+	std::string ConstructTitle(void) const;
+};
+// *******************************************************************/
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/prosite.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/prosite.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/prosite.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/prosite.cpp	2018-03-13 14:39:35.361226000 -0400
@@ -0,0 +1,741 @@
+#include "prosite.hpp"
+#include <stack>
+#include <string>
+#include <iostream>
+
+using namespace std;
+
+static const std::string kPlainEmptyString;
+
+CProSite::TPatternPos::TPatternPos(void):
+	m_uiFlags(0), m_strAltChars(kPlainEmptyString), m_ulMinCount(1), m_ulMaxCount(1), m_pfnMatch(&TPatternPos::x_PosMatch)
+{};
+
+
+
+void CProSite::Search(const std::string &text, vector<CProSite::TMatched> &result) const
+{
+	result.clear();
+	size_t tlen = text.size();
+	for (size_t i = 0; i < tlen; ++i)
+	{
+		size_t mpos = Match(text, tlen, i);
+		if (string::npos != mpos)	//success
+			result.push_back(TMatched(i, mpos));
+	}
+}
+
+void CProSite::DebugPrint(void) const
+{
+	cout << "Total positions: " << m_vecCompiledPattern.size() << " =====================================================================" << endl;
+	for (vector<TPatternPos> :: const_iterator iter = m_vecCompiledPattern.begin(); iter != m_vecCompiledPattern.end(); ++iter)
+	{
+		size_t totalAlts = iter->m_strAltChars.size();
+		
+		cout << "Filter mode: " << ((iter->m_uiFlags & TPatternPos::NEGATIVE_FILTER) ? "negative" : "positive") << ", Match mode: " << ((iter->m_uiFlags & TPatternPos::LAZY_MATCH) ? "lazy" : "aggresive") << ", minimal count: " << iter->m_ulMinCount << ", maximal count: " << iter->m_ulMaxCount << ", Total alternatives: " << totalAlts << ": ";
+		char sep[2] = {0, 0};
+		for (size_t i = 0; i < totalAlts; ++i)
+		{
+			cout << sep << '\'' << iter->m_strAltChars[i] << '\'';
+			sep[0] = ',';
+		}
+		cout << endl;
+	}
+	cout << "=======================================================================================================" << endl;
+}
+
+ 
+CProSite::EParseError CProSite::Parse(const string &expr, size_t &errorPos)
+{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": expr = " << expr << endl;
+#endif
+// ***********************************************************/
+
+	if (expr.empty()) return eUnexpectedEnd;
+	
+	enum __EParserStatus
+	{
+		eParserReady = 0,
+		ePlainText,	//collecting plain text
+		eAlternates,	//in [] collecting alternative
+		eAltRedund,
+		eNegations,	//in {} collecting alternative
+		eNegRedund,
+		eRepeats,	//in () collecting repeats
+		eRange	//only valid for X, in (a,b) collecting 
+	} status = eParserReady;
+	
+	EParseError eErrorType = eNoError;	
+
+	
+	string::const_iterator iterChar = expr.begin(), iterCharEnd = expr.end();
+	
+	m_vecCompiledPattern.clear();
+	TPatternPos __dummy;
+	vector<TPatternPos> :: iterator iterCurr = m_vecCompiledPattern.end();
+	
+	string lit(kPlainEmptyString);
+	bool bEscaped = false;	//if '\' is detected
+	bool bInfLit = false;
+	
+	while (iterCharEnd != iterChar)
+	{
+		char c = *iterChar;
+		if ('a' <= c && 'z' >= c) c -= 0x20;	//turn to capital letters
+		switch (c)
+		{
+		case '*':	//stop codon
+			if (!bEscaped)	//not escaped, as equivalent to (0, inf)
+			{
+				switch (status)
+				{
+				case ePlainText:
+					iterCurr->m_ulMinCount = 0;
+					iterCurr->m_ulMaxCount = -1;	//the biggest possible
+					if (iterCurr->m_strAltChars == "X") iterCurr->m_uiFlags |= TPatternPos::LAZY_MATCH;
+					break;
+				case eAlternates:	//always treat as a literal * (stop codon)
+				case eNegations:
+					iterCurr->m_strAltChars.push_back(c);
+					break;
+				case eRange:	//accepting max
+				case eRepeats:
+					if (lit.empty() && !bInfLit) 
+					{
+						bInfLit = true;
+						break;
+					}
+				case eAltRedund:
+				case eNegRedund:
+					break;
+				default:
+					eErrorType = eSyntaxError;
+					goto labelErrorRet;
+				}
+				break;
+			}
+			
+		case 'A':
+		case 'C':
+		case 'D':
+		case 'E':
+		case 'F':
+		case 'G':
+		case 'H':
+		case 'I':
+		case 'K':
+		case 'L':
+		case 'M':
+		case 'N':
+		case 'P':
+		case 'Q':
+		case 'R':
+		case 'S':
+		case 'T':
+		case 'U':	//newly added selenocysteine
+		case 'V':
+		case 'W':
+		case 'Y':
+		
+			switch (status)
+			{
+			case eParserReady:	//No current
+				status = ePlainText;
+			case ePlainText:	//current is valid
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+			case eAlternates:	//single char alternative, assume: iterCurrAltPattern is undefined
+			case eNegations:
+				iterCurr->m_strAltChars.push_back(c);
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			bEscaped = false;
+			break;
+		case 'X':	//special: wildcard, no alternates or negates allowed.
+			switch (status)
+			{
+			case eParserReady:	//No current
+				status = ePlainText;
+			case ePlainText:	//current is valid
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				iterCurr->m_strAltChars.push_back(c);
+				//iterCurr->m_uiFlags |= TPatternPos::LAZY_MATCH;
+				break;
+			case eAlternates:	//if alternates, and 'X' mean everything canbe accepted.
+			case eNegations:
+				iterCurr->m_strAltChars.push_back(c);
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			bEscaped = false;
+			break;
+		case '0':
+		case '1':
+		case '2':
+		case '3':
+		case '4':
+		case '5':
+		case '6':
+		case '7':
+		case '8':
+		case '9':
+			switch (status)
+			{
+			case eRepeats:
+			case eRange:
+				if (!bInfLit)
+				{
+					lit.push_back(c);
+					break;
+				}
+			
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+				
+			case eAltRedund:
+			case eNegRedund:
+				break;	//ignore it
+			}
+			bEscaped = false;
+			break;
+		case '(':
+			switch (status)
+			{
+			case ePlainText:
+				status = eRepeats;	//change to repeats. assert(cTargetChar is defined)
+				lit.clear();
+				break;
+			// -- added 02/12/2016 to tolerate redunence in alternations
+			case eAlternates:
+				status = eAltRedund;
+				break;
+			case eNegations:
+				status = eNegRedund;
+				break;
+			// -- End added 02/12/2016 
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case ')':
+			switch (status)
+			{
+			case eRepeats:	//end of repeat
+				if (!lit.empty())	//has input
+				{
+					iterCurr->m_ulMinCount = iterCurr->m_ulMaxCount = (size_t)atol(lit.c_str());
+				}
+				else if (bInfLit)
+				{
+					iterCurr->m_ulMinCount = 0;
+					iterCurr->m_ulMaxCount = -1;	//the biggest possible
+					if (iterCurr->m_strAltChars == "X") iterCurr->m_uiFlags |= TPatternPos::LAZY_MATCH;	//infinit X will have lazy match
+					bInfLit = false;
+				}
+				else
+				{
+					eErrorType = eSyntaxError;
+					goto labelErrorRet;
+				}
+				status = ePlainText;
+
+				break;
+			case eRange:	//end of range, assume iterGroup already renewed by the ',' token
+				if (!lit.empty())	//has input
+				{
+					iterCurr->m_ulMaxCount = (size_t)atol(lit.c_str());
+					// -- check for reversed
+					if (iterCurr->m_ulMaxCount < iterCurr->m_ulMinCount)
+					{
+						iterCurr->m_ulMaxCount ^= iterCurr->m_ulMinCount;
+						iterCurr->m_ulMinCount ^= iterCurr->m_ulMaxCount;
+						iterCurr->m_ulMaxCount ^= iterCurr->m_ulMinCount;
+					}
+				}
+				else if (bInfLit)
+				{
+					iterCurr->m_ulMaxCount = -1;
+					if (iterCurr->m_strAltChars == "X") iterCurr->m_uiFlags |= TPatternPos::LAZY_MATCH;
+					bInfLit = false;
+				}
+				else
+				{
+					eErrorType = eSyntaxError;
+					goto labelErrorRet;
+				}
+				status = ePlainText;
+				break;
+			case eAltRedund:
+				status = eAlternates;
+				break;
+			case eNegRedund:
+				status = eNegations;
+				break;	//ignore it 
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			};
+			break;
+
+		case ',':	//turn repeat into range
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case eRepeats:	//turn repeats into a range spec.
+			
+				if (!lit.empty())
+				{
+					iterCurr->m_ulMinCount = (size_t)atol(lit.c_str());
+					lit.clear();
+					status = eRange;
+					break;
+				}
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			case eAltRedund:
+			case eNegRedund:
+				break;
+			};
+			break;
+		case '\\':
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			bEscaped = true;
+			break;
+			
+		case '[':	//start variable set
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case ePlainText:
+			case eParserReady:
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				//iterCurr->m_uiFlags = true;
+				status = eAlternates;
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			};
+			break;
+		case ']':	//end variable set
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case eAlternates:
+				if (!iterCurr->m_strAltChars.empty())
+				{
+					iterCurr->x_NormalizeAltChars();
+					status = ePlainText;
+					break;
+				}
+				
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case '{':	//negative set
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case ePlainText:	//start of alternative
+			case eParserReady:
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				iterCurr->m_uiFlags |= TPatternPos::NEGATIVE_FILTER;
+				iterCurr->m_pfnMatch = &TPatternPos::x_NegMatch;
+				status = eNegations;
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			};
+			break;
+		case '}':	//end negative set
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case eNegations:
+				if (!iterCurr->m_strAltChars.empty())
+				{
+					iterCurr->x_NormalizeAltChars();
+					status = ePlainText;
+					break;
+				}
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case '<':	//start anchor
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case eAlternates:
+				if (m_vecCompiledPattern.begin() != iterCurr)	//not the first 
+				{
+					eErrorType = eSyntaxError;
+					goto labelErrorRet;
+				}
+			case eNegations:
+				iterCurr->m_strAltChars.push_back(c);
+				break;
+			case eParserReady:
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				iterCurr->m_strAltChars.push_back(c);
+				status = ePlainText;
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case '>':	//end anchor
+			if (bEscaped)
+			{
+				eErrorType = eInvalidChar;
+				goto labelErrorRet;
+			}
+			switch (status)
+			{
+			case ePlainText:
+			case eParserReady:
+				iterCurr = m_vecCompiledPattern.insert(m_vecCompiledPattern.end(), __dummy);
+				iterCurr->m_strAltChars.push_back(c);
+				status = ePlainText;
+				break;
+			case eNegations:
+				iterCurr->m_strAltChars.push_back(c);
+				break;
+			default:
+				eErrorType = eSyntaxError;
+				goto labelErrorRet;
+			}
+			break;
+		case '-':	//ignore
+		case ' ':
+		case '\t':
+			break;
+		default:
+			eErrorType = eInvalidChar;
+			goto labelErrorRet;
+		}
+		++iterChar;
+	}
+	
+labelErrorRet:
+	errorPos = (iterChar - expr.begin());
+	return eErrorType;	
+}
+ 
+size_t CProSite::Match(const string &text, size_t tlen, size_t start_pos) const
+{
+	if (start_pos >= tlen) return string::npos;
+	stack<x_TMatchRec> stkFlexStack;
+	
+	x_TMatchRec curr(m_vecCompiledPattern.begin());
+	
+	vector<TPatternPos> :: const_iterator iterPosEnd = m_vecCompiledPattern.end();
+	
+	
+	while (iterPosEnd != curr.iterPos)
+	{
+		int matched = curr.iterPos->Match(text, tlen, curr.flex, start_pos);
+		if (matched < 0)	//match failed
+		{
+			if (stkFlexStack.empty()) return string::npos;
+			curr = stkFlexStack.top();
+			stkFlexStack.pop();
+		}
+		else	//match success
+		{
+			if (matched > 0) stkFlexStack.push(curr);
+			start_pos = curr.flex.back();
+			++curr.iterPos;
+			curr.flex.clear();
+		}
+	}
+	
+	
+	// -- successfully matched all PatternPosition
+	return start_pos;	//should always be valid.
+	
+}
+void CProSite::TPatternPos::x_NormalizeAltChars(void)
+{
+/*debug*******************************************************/
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Entering CProSite::TPatternPos::x_NormalizeAltChars(void), m_strAltChars = " << m_strAltChars << endl;
+#endif
+// ***********************************************************/
+
+	if (!m_strAltChars.empty())
+	{
+		size_t idx = 0, ttl = m_strAltChars.size();
+		vector<size_t> veciidx;
+		veciidx.reserve(ttl);
+		while (idx < ttl)
+		{
+			char currc = m_strAltChars[idx];
+			if ('X' == currc)	//no matter others, just being the one
+			{
+				m_strAltChars.clear();
+				m_strAltChars.push_back('X');
+				break;
+			}
+			veciidx.clear();
+			
+			size_t mv = 0;
+			size_t idx2 = idx + 1;
+			while (idx2 < ttl)
+			{
+				if (m_strAltChars[idx2] == currc)
+					++mv;
+				else if (mv > 0)
+					m_strAltChars[idx2 - mv] = m_strAltChars[idx2];
+				
+				++idx2;
+			}
+			
+			ttl -= mv;
+			
+			while (mv > 0)
+			{
+				m_strAltChars.pop_back();
+				--mv;
+			}
+			
+			++idx;
+		}
+	}
+/*debug*******************************************************/
+#if defined(_DEBUG)
+cerr << __FILE__ << ':' << __LINE__ << ": Leaving CProSite::TPatternPos::x_NormalizeAltChars(void), m_strAltChars = " << m_strAltChars << endl;
+#endif
+// ***********************************************************/
+}
+// -- negative position match
+size_t CProSite::TPatternPos::x_NegMatch(const string &text, size_t tlen, size_t pos) const
+{
+	string::const_iterator iterChar = m_strAltChars.begin(), iterCharEnd = m_strAltChars.end();
+	size_t adv = 0;
+	
+	while (iterCharEnd != iterChar)
+	{
+		switch (*iterChar)
+		{
+		case '<':	//start anchor
+			if (0 == pos)	//matched, fail it
+				return string::npos;
+			break;
+		case '>':	//end anchor
+			if (pos == tlen)	//matched
+				return string::npos;
+			break;
+		case 'X':
+			if (pos < tlen)
+				return string::npos;
+			break;
+		default:
+			if (pos < tlen)
+			{
+				char c = text[pos];
+				adv = 1;
+				if ('a' <= c && 'z' >= c) c -= 0x20;
+				if (*iterChar == c)	//matched
+					return string::npos;
+			}
+			else
+				return string::npos;
+		}
+		
+		++iterChar;
+	}
+	return adv;	//nothing matched, successful
+}
+ 
+// -- positive position match
+size_t CProSite::TPatternPos::x_PosMatch(const string &text, size_t tlen, size_t pos) const
+{
+	string::const_iterator iterChar = m_strAltChars.begin(), iterCharEnd = m_strAltChars.end();
+	while (iterCharEnd != iterChar)
+	{
+		switch (*iterChar)
+		{
+		case '<':	//start anchor
+			if (0 == pos)	//matched
+				return 0;
+			break;
+		case '>':	//end anchor
+			if (pos == tlen)	//matched
+				return 0;
+			break;
+		case 'X':	//match any
+			if (pos < tlen)	//last, 
+				return 1;
+			break;
+		default:
+			if (pos < tlen)
+			{
+				char c = text[pos];
+				if ('a' <= c && 'z' >= c) c -= 0x20;
+				if (*iterChar == c)	//matched
+					return 1;
+			}
+		}
+		
+		++iterChar;
+	}
+	return string::npos;
+}
+
+
+int CProSite::TPatternPos::Match(const string &text, size_t tlen, vector<size_t> &rMatchRec, size_t start_pos) const
+{
+
+	size_t matched = rMatchRec.size();	//assume: at least one [0] as the start position
+
+	int retVal = 0;	//return 0: match success but no more flex, -1: match failed. >1: # of flex left
+	if (m_uiFlags & LAZY_MATCH)	//do not clear rMatchRec
+	{
+		if (0 == matched)	//the first time
+		{
+			
+			rMatchRec.push_back(start_pos);
+			
+			// -- first, must match to minimal count
+			
+			while (rMatchRec.size() <= m_ulMinCount)
+			{
+				size_t adv = (this->*m_pfnMatch)(text, tlen, start_pos);
+				
+				if (string::npos == adv)	//fail
+				{
+					return -1;
+				}
+				start_pos += adv;
+				rMatchRec.push_back(start_pos);
+			}
+			if (m_ulMaxCount > m_ulMinCount) retVal = 1;
+			else retVal = 0;
+		}
+		else if (matched <= m_ulMaxCount)	//still flex	//revisit
+		{
+			start_pos = rMatchRec[matched - 1];
+			size_t adv = (this->*m_pfnMatch)(text, tlen, start_pos);
+			if (string::npos == adv)	//successful
+				retVal = -1;
+			else
+			{
+				start_pos += adv;
+				rMatchRec.push_back(start_pos);
+				if (m_ulMaxCount > matched) retVal = 1;
+				else retVal = 0;
+			}
+		}
+	}
+	else	//aggressive match
+	{
+		if (0 == matched)	//the first time
+		{
+			rMatchRec.push_back(start_pos);
+			while ((matched = rMatchRec.size()) <= m_ulMaxCount)
+			{
+				size_t adv = (this->*m_pfnMatch)(text, tlen, start_pos);
+				if (string::npos == adv)	//fail
+					break;
+				start_pos += adv;
+				rMatchRec.push_back(start_pos);
+			}
+		}
+		else 
+		{
+			rMatchRec.pop_back();
+			matched = rMatchRec.size();
+		}
+		if (matched < m_ulMinCount + 1) retVal = -1;	// minimal match not reached
+		else if (matched > m_ulMinCount + 1) retVal = 1;	//with flex
+		else retVal = 0;
+	}
+	return retVal;
+}
+
+void CProSite::GetMinimalXMap(string &minMap) const
+{
+	minMap.clear();
+	size_t ttl = m_vecCompiledPattern.size();
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << "GetMinimalXMap: ttl = " << ttl << endl;
+#endif
+// ***********************************************************/
+	if (ttl > 0)
+	{
+		minMap.reserve(ttl + ttl);
+		for (size_t i = 0; i < ttl; ++i)
+		{
+/*debug*******************************************************/
+#if defined(_DEBUG)
+cerr << "m_vecCompiledPattern[i].m_ulMinCount = " << m_vecCompiledPattern[i].m_ulMinCount << "m_vecCompiledPattern[i].m_strAltChars = " << m_vecCompiledPattern[i].m_strAltChars << endl;
+#endif
+// ***********************************************************/
+			if (m_vecCompiledPattern[i].m_ulMinCount > 0)
+			{
+/*debug*******************************************************
+#if defined(_DEBUG)
+cerr << "m_vecCompiledPattern[i].m_strAltChars.size() = " << m_vecCompiledPattern[i].m_strAltChars.size() << endl;
+#endif
+// ***********************************************************/
+				switch (m_vecCompiledPattern[i].m_strAltChars.size())
+				{
+				case 0:
+					break;
+				case 1:
+					if ('X' == m_vecCompiledPattern[i].m_strAltChars[0]) minMap.append(m_vecCompiledPattern[i].m_ulMinCount, 'X');
+					else if (m_vecCompiledPattern[i].m_uiFlags & TPatternPos::NEGATIVE_FILTER) minMap.append(m_vecCompiledPattern[i].m_ulMinCount, 'A');
+					else minMap.append(m_vecCompiledPattern[i].m_ulMinCount, 'S');
+					break;
+				default:	//>1
+					minMap.append(m_vecCompiledPattern[i].m_ulMinCount, 'A');
+				}
+			}
+		}
+	}
+	
+}
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/prosite.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/prosite.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/prosite.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/prosite.hpp	2018-03-13 14:39:35.367423000 -0400
@@ -0,0 +1,66 @@
+#if !defined(__PROSITE__)
+#define __PROSITE__
+
+#include <string>
+#include <vector>
+
+
+class CProSite
+{
+public:
+	enum EParseError
+	{
+		eNoError,
+		eInvalidChar,
+		eSyntaxError,
+		eUnexpectedEnd
+	};
+
+	struct TMatched
+	{
+		size_t start, end;
+		TMatched(size_t s = std::string::npos, size_t e = std::string::npos): start(s), end(e) {};
+	};
+	CProSite(void):m_vecCompiledPattern() {};
+	EParseError Parse(const std::string &expr, size_t &errorPos);
+	size_t Match(const std::string &text, size_t tlen, size_t start_pos) const;
+	void Search(const std::string &text, std::vector<TMatched> &result) const;
+	
+	// -- return a vector of minimal match length, with 'X' as generic, 'A' as alternative and S as strict.
+	void GetMinimalXMap(std::string &minMap) const;
+	void DebugPrint(void) const;
+	
+private:
+	struct TPatternPos
+	{
+		static const unsigned int NEGATIVE_FILTER = 0x1;
+		static const unsigned int LAZY_MATCH = 0x2;
+		unsigned int m_uiFlags;	//positive or negative select
+		std::string m_strAltChars;
+		size_t m_ulMinCount, m_ulMaxCount;
+		size_t (TPatternPos::*m_pfnMatch)(const std::string &text, size_t tlen, size_t pos) const;
+		
+		TPatternPos(void);
+		//return <0 as match fail. return 0 as "just match" without flex. return >0 as how many flex positions
+		int Match(const std::string &text, size_t tlen, std::vector<size_t> &rMatchRec, size_t start_pos = std::string::npos) const;
+		size_t x_NegMatch(const std::string &text, size_t tlen, size_t pos) const;
+		size_t x_PosMatch(const std::string &text, size_t tlen, size_t pos) const;
+			
+		void x_NormalizeAltChars(void);
+	};
+	
+
+
+	struct x_TMatchRec
+	{
+		std::vector<size_t> flex;
+		std::vector<TPatternPos> :: const_iterator iterPos;
+		
+		x_TMatchRec(std::vector<TPatternPos> :: const_iterator p): flex(), iterPos(p) {};
+	};
+	
+	std::vector<TPatternPos> m_vecCompiledPattern;
+	
+};
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ptrmap.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ptrmap.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ptrmap.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ptrmap.hpp	2018-03-13 14:39:35.306498000 -0400
@@ -0,0 +1,182 @@
+#if !defined(__PTR_MAP__)
+#define __PTR_MAP__
+
+#include <vector>
+
+/**********************************************************************
+*	A template class for sorting and binary search (map) pointers
+*	to TVal. Actual storage of data is not handled, so keep the storage valid
+*	and address not changed. Usually work with compactstore class is perfect.
+*	Comp is a user-defined object that must have the following operator ()
+*	defined:
+struct TComp
+{
+	int operator () (const TVal &v1, const TVal &v2) const;	//for relevent sort by TKey
+	int operator () (const TKey &k, const TVal &v) const;	//for search by TKey
+};
+for sorting int operator (), return -1 if v1 goes before v2, 0 if equivalent, and 1 if v2 goes before v1
+for searching int operator (), return -1 if the k is associated with TVal before v, 0 if k match v (found), 1 if k is associated with TVal after v
+**********************************************************************/
+template<typename TKey, typename TVal, typename TComp>
+class CPtrMap
+{
+public:
+	typedef TVal *VAL_PTR;
+	typedef const TVal *CONST_VAL_PTR;
+	typedef std::vector< VAL_PTR > TSORTED_PTRS;
+	
+	CPtrMap(void): m_ptr_vec(), m_comp(), m_sort_cmp(m_comp) {};
+	CPtrMap(const TComp &c) : m_ptr_vec(), m_comp(c), m_sort_cmp(c) {};
+	CPtrMap(const TSORTED_PTRS &v, const TComp &c = TComp());
+	CPtrMap(TSORTED_PTRS &&v, const TComp &c = TComp());
+	
+	void Reset(void) {m_ptr_vec.clear();};
+	void Reset(const TSORTED_PTRS & ptrs);
+	void Reset(TSORTED_PTRS &&ptrs);
+	
+	
+	VAL_PTR Find(const TKey &k);
+	CONST_VAL_PTR Find(const TKey &k) const;
+	
+	CONST_VAL_PTR operator [] (std::size_t i) const;
+	VAL_PTR operator [] (std::size_t i);
+	
+	VAL_PTR Insert(VAL_PTR pv, bool &inserted);
+	
+	// -- pass over
+	inline
+	std::size_t size(void) const
+	{
+		return m_ptr_vec.size();
+	};
+	
+	inline
+	void reserve(std::size_t n)
+	{
+		m_ptr_vec.reserve(n);
+	};
+
+
+private:
+	TSORTED_PTRS m_ptr_vec;
+	TComp m_comp;
+	struct TSortComp
+	{
+		const TComp &m_comp;
+		bool operator() (CONST_VAL_PTR p1, CONST_VAL_PTR p2)
+		{
+			return m_comp(*p1, *p2) < 0;
+		}
+		
+		TSortComp(const TComp &cmp): m_comp(cmp) {};
+	} m_sort_cmp;
+	
+};
+
+
+template<typename TKey, typename TVal, typename TComp>
+CPtrMap<TKey, TVal, TComp> :: CPtrMap(const CPtrMap<TKey, TVal, TComp> :: TSORTED_PTRS &v, const TComp &c):
+	m_ptr_vec(v), m_comp(c), m_sort_cmp(c)
+{
+	sort(m_ptr_vec.begin(), m_ptr_vec.end(), m_sort_cmp);
+}
+
+template<typename TKey, typename TVal, typename TComp>
+CPtrMap<TKey, TVal, TComp> :: CPtrMap(CPtrMap<TKey, TVal, TComp> :: TSORTED_PTRS &&v, const TComp &c):
+	m_ptr_vec(std::forward<TSORTED_PTRS>(v)), m_comp(c), m_sort_cmp(c)
+{
+	sort(m_ptr_vec.begin(), m_ptr_vec.end(), m_sort_cmp);
+}
+
+template<typename TKey, typename TVal, typename TComp>
+typename CPtrMap<TKey, TVal, TComp> :: VAL_PTR CPtrMap<TKey, TVal, TComp> :: Find(const TKey &k)
+{
+	std::size_t rbegin = 0, rend = m_ptr_vec.size(), dist = rend - rbegin;
+
+	while (dist > 0)
+	{
+		std::size_t rmid = rbegin + (dist >> 1);
+		int ord = m_comp(k, *m_ptr_vec[rmid]);
+		if (0 == ord)
+			return m_ptr_vec[rmid];	//found
+		else if (ord > 0) rbegin = rmid + 1;
+		else rend = rmid;
+		dist = rend - rbegin;
+	}
+	return nullptr;
+}
+
+template<typename TKey, typename TVal, typename TComp>
+typename CPtrMap<TKey, TVal, TComp> :: CONST_VAL_PTR CPtrMap<TKey, TVal, TComp> :: Find(const TKey &k) const
+{
+	
+	std::size_t rbegin = 0, rend = m_ptr_vec.size(), dist = rend - rbegin;
+	
+	while (dist > 0)
+	{
+		std::size_t rmid = rbegin + (dist >> 1);
+
+		int ord = m_comp(k, *m_ptr_vec[rmid]);
+		if (0 == ord)
+			return m_ptr_vec[rmid];	//found
+		else if (ord > 0) rbegin = rmid + 1;
+		else rend = rmid;
+		dist = rend - rbegin;
+	}
+	return nullptr;
+}
+
+template<typename TKey, typename TVal, typename TComp>
+inline
+typename CPtrMap<TKey, TVal, TComp> :: CONST_VAL_PTR CPtrMap<TKey, TVal, TComp> :: operator [] (std::size_t i) const
+{
+	return (i >= m_ptr_vec.size() ? nullptr : m_ptr_vec[i]);
+}
+
+
+template<typename TKey, typename TVal, typename TComp>
+inline
+typename CPtrMap<TKey, TVal, TComp> :: VAL_PTR CPtrMap<TKey, TVal, TComp> :: operator [] (std::size_t i)
+{
+	return (i >= m_ptr_vec.size() ? nullptr : m_ptr_vec[i]);
+}
+
+template<typename TKey, typename TVal, typename TComp>
+typename CPtrMap<TKey, TVal, TComp> :: VAL_PTR CPtrMap<TKey, TVal, TComp> :: Insert(typename CPtrMap<TKey, TVal, TComp> :: VAL_PTR pv, bool &inserted)
+{
+	std::size_t rbegin = 0, rend = m_ptr_vec.size(), dist = rend - rbegin;
+	
+	while (dist > 0)
+	{
+		std::size_t rmid = rbegin + (dist >> 1);
+		int ord = m_comp(*pv, *m_ptr_vec[rmid]);
+		if (0 == ord)
+		{
+			return m_ptr_vec[rmid];	//found
+			inserted = false;
+		}
+		else if (ord < 0) rbegin = rmid + 1;
+		else rend = rmid;
+		dist = rend - rbegin;
+	}
+	m_ptr_vec.insert(m_ptr_vec.begin() + rend, pv);
+	inserted = true;
+	return m_ptr_vec[rend];
+}
+
+template<typename TKey, typename TVal, typename TComp>
+void CPtrMap<TKey, TVal, TComp> :: Reset(const typename CPtrMap<TKey, TVal, TComp> :: TSORTED_PTRS & ptrs)
+{
+	m_ptr_vec = ptrs;
+	if (m_ptr_vec.size() > 1) sort(m_ptr_vec.begin(), m_ptr_vec.end(), m_sort_cmp);
+}
+
+template<typename TKey, typename TVal, typename TComp>
+void CPtrMap<TKey, TVal, TComp> :: Reset(typename CPtrMap<TKey, TVal, TComp> :: TSORTED_PTRS &&ptrs)
+{
+	m_ptr_vec = std::move(ptrs);
+	if (m_ptr_vec.size() > 1) sort(m_ptr_vec.begin(), m_ptr_vec.end(), m_sort_cmp);
+
+}
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/segset.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/segset.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/segset.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/segset.cpp	2018-03-13 14:39:35.350715000 -0400
@@ -0,0 +1,26 @@
+#include "segset.hpp"
+
+
+
+bool TSeg_base::IsValid(void) const
+{
+	return (to >= from);
+}
+
+//Deliberately left out lext and rext
+bool TSeg_base::operator == (const TSeg_base& other) const
+{
+	return from == other.from && to == other.to;
+}
+
+bool TSegSortLeft::operator () (const TSeg_base* s1, const TSeg_base* s2)
+{
+	return s1->from < s2->from;
+}
+
+bool TSegSortLength::operator () (const TSeg_base* s1, const TSeg_base* s2)
+{
+	return s1->to - s1->from > s2->to - s2->from;
+}
+
+
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/segset.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/segset.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/segset.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/segset.hpp	2018-03-13 14:39:35.355292000 -0400
@@ -0,0 +1,510 @@
+#if !defined(__SEG_SET__)
+#define __SEG_SET__
+#if defined(__DB_OFFLINE__)
+#include "envdef.hpp"
+#include "normbase.hpp"
+#else
+#include <NcbiBase/envdef.hpp>
+#include <BasicUtils/normbase.hpp>
+#endif
+#include <list>
+#include <vector>
+#include <algorithm>
+struct TSeg_base
+{
+	struct TResiduePos
+	{
+		SeqPos_t curr, ori;
+		TResiduePos(SeqPos_t c = 0, SeqPos_t o = 0): curr(c), ori(o) {};
+	};
+	
+	SeqPos_t from;
+	SeqPos_t to;
+	
+	// -- give up tracking conversion, just keep the original in the segment.
+	SeqPos_t ori_from;
+	
+	bool operator == (const TSeg_base& other) const;
+	
+	TSeg_base(SeqPos_t f = 0, SeqPos_t t = 0): from(f), to(t), ori_from(f) {};
+	bool IsValid(void) const;
+	
+	bool LeftTo(const TSeg_base& rSrcSeg) const {return (to < rSrcSeg.from - 1);} 
+	bool RightTo(const TSeg_base& rSrcSeg) const {return (from > rSrcSeg.to + 1);}
+	bool LeftTouch(const TSeg_base& rSrcSeg) const {return (to == rSrcSeg.from - 1);}
+	bool RightTouch(const TSeg_base& rSrcSeg) const {return (from == rSrcSeg.to + 1);}
+	bool MoreLeft(const TSeg_base& rSrcSeg) const {return (from < rSrcSeg.from);}
+	bool MoreRight(const TSeg_base& rSrcSeg) const {return (to > rSrcSeg.to);}
+	bool Overlap(const TSeg_base& rSrcSeg) const {return ((from >= rSrcSeg.from && from <= rSrcSeg.to) || (rSrcSeg.from >= from && rSrcSeg.from <= to));}
+	bool Touch(const TSeg_base& rSrcSeg) const {return (LeftTouch(rSrcSeg) || RightTouch(rSrcSeg));}
+};
+
+// -- sort from left most to right
+struct TSegSortLeft
+{
+	bool operator () (const TSeg_base* s1, const TSeg_base* s2);
+};
+
+// -- sort from long to short segs, so short segs will be drawn later than long segs
+struct TSegSortLength
+{
+	bool operator () (const TSeg_base* s1, const TSeg_base* s2);
+};
+
+
+template <typename SEGTYPE>
+class CSegSetTmpl
+{
+	friend class TSeqAlignment;
+	
+	friend class CDataCache & operator << (class CDataCache &dc, const CSegSetTmpl<SEGTYPE> & d);
+	friend class CDataCache & operator >> (class CDataCache &dc, CSegSetTmpl<SEGTYPE> & d);
+public:
+	
+	typedef SEGTYPE TSeg;
+	typedef std::list<SEGTYPE> TSegs;	
+	
+	
+	CSegSetTmpl(void): m_iFactor(1), m_lstContainer(), m_ulGapThreshold(-1) {};
+	CSegSetTmpl(const std::vector<SeqPos_t>& starts, const std::vector<SeqLen_t>& lens);	//always set ofs to zero! so must use slave coordinates.
+	virtual ~CSegSetTmpl(void) {};
+	
+	//this must be a normal segs: align from left to right
+	void SetData(const std::vector<SeqPos_t>& starts, const std::vector<SeqLen_t>& lens);	//always set ofs to zero! so must use slave coordinates.
+	void SetData(const std::vector<SeqPos_t> &residues);
+
+	bool operator == (const CSegSetTmpl& other) const;
+	
+	// -- status
+	bool IsEmpty(void) const {return m_lstContainer.empty();}
+	int GetTransFactor(void) const {return m_iFactor;}
+	
+	// -- manipulate. 
+	// -- any operation, the ori_from and ori_to are calculated based on target segment. src segs ori information are discarded.
+	void AddSeg(SeqPos_t f, SeqPos_t t);	//  
+	void AddSeg(const SEGTYPE& seg);
+	
+	void Clear(void) {m_lstContainer.clear();}
+	
+	void Merge(const CSegSetTmpl& src);
+	void Cross(const CSegSetTmpl& src);
+	void Clip(const CSegSetTmpl& src);
+	void Inv(SeqPos_t from, SeqPos_t to);	//inverse against a total range
+
+	SeqPos_t GetLeft(void) const;
+	SeqPos_t GetRight(void) const;
+	//SeqPos_t GetLeftOfs(void) const;
+	//SeqPos_t GetRightOfs(void) const;
+	SeqPos_t GetTotalResidues(void) const;
+
+	void GetOverall(SEGTYPE &target, SeqPos_t &ori_to) const;	//ori-to is calculated from the last segment factor is 1 or 3 -- if Pr2na
+	SeqPos_t GetOriTo(typename TSegs::const_iterator citer, SeqPos_t pos = -1) const;
+	SeqPos_t GetOriTo(void) const;
+	const TSegs& GetSegs(void) const {return m_lstContainer;}
+	// -- gapThreshold is AA residue counts. Will automatically convert to NA (if applicable) counts in the result
+	void GetGaps(CSegSetTmpl<SEGTYPE> &dst) const;
+	//void GetSimplePosMap(std::vector<TResiduePos> &dst) const;
+	//void GetOriSimplePosMap(std::vector<TResiduePos> &dst) const;
+	void GetTranslatedPosMap(size_t aaSeqLen, std::vector<TSeg_base::TResiduePos> &dst) const;
+	virtual int GetCompleteSize(void) const {return -1;}
+	
+protected:
+	// -- the actual container
+	int m_iFactor;	//factor: when map protein to na, it is 3, otherwise it is 1. sign denotes the direction
+	TSegs m_lstContainer;
+public:
+	SeqLen_t m_ulGapThreshold;
+
+};
+
+template <typename SEGTYPE>
+CSegSetTmpl<SEGTYPE>::CSegSetTmpl(const std::vector<SeqPos_t> &starts, const std::vector<SeqLen_t> &lens): m_iFactor(1), m_lstContainer(), m_ulGapThreshold(-1)
+{
+	// -- do not clear segset first. we may need to add segs
+	SetData(starts, lens);
+}
+
+
+template <typename SEGTYPE>
+bool CSegSetTmpl<SEGTYPE>::operator == (const CSegSetTmpl<SEGTYPE> & other) const
+{
+	return m_lstContainer == other.m_lstContainer;
+}
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::SetData(const std::vector<SeqPos_t>& starts, const std::vector<SeqLen_t>& lens)
+{
+	m_lstContainer.clear();
+	for (size_t i = 0; i < lens.size(); ++i)
+		AddSeg(starts[i], starts[i] + lens[i] - 1);
+}
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::SetData(const std::vector<SeqPos_t> &residues)
+{
+	m_lstContainer.clear();
+	
+	if (residues.empty()) return;
+	
+	std::vector<SeqPos_t> sorted(residues);
+	std::sort(sorted.begin(), sorted.end());
+	
+	SEGTYPE seg;
+	
+	seg.from = seg.to = seg.ori_from = sorted[0];
+	
+	size_t i = 0, iEnd = sorted.size();
+	
+	while (i < iEnd)
+	{
+		if (sorted[i] > seg.to + 1)
+		{
+			AddSeg(seg);
+			seg.from = seg.to = seg.ori_from = sorted[i];
+		}
+		else if (sorted[i] > seg.to)
+		{
+			seg.to = sorted[i];
+		}
+		
+		++i;
+	}
+	AddSeg(seg);
+}
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::AddSeg(SeqPos_t f, SeqPos_t t)
+{
+	AddSeg(SEGTYPE(f, t));
+}
+
+// -- will discard seg original info
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::AddSeg(const SEGTYPE& seg)
+{
+	if (!seg.IsValid()) return;
+	typename TSegs::iterator curr = m_lstContainer.begin(), dstEnd = m_lstContainer.end();
+	
+	while (dstEnd != curr && curr -> to < seg.from - 1) ++curr;
+	if (curr == m_lstContainer.end())	//add to end
+	{
+		m_lstContainer.insert(dstEnd, seg);
+		return;
+	}
+	else if (curr->from > seg.to + 1)	// gap big enough
+	{
+		m_lstContainer.insert(curr, seg);
+		return;
+	}
+	else	//merge the seg in
+	{
+		if (curr->from > seg.from)
+		{
+			curr->ori_from -= (curr->from - seg.from) / m_iFactor;
+			curr->from = seg.from;	//extended left
+			
+		}
+		if (curr->to < seg.to)
+		{
+			curr->to = seg.to;	//extended right
+		}
+		
+		typename TSegs::iterator nxt = curr;
+		
+		++nxt;
+		while (nxt != dstEnd && nxt->from <= curr->to + 1)
+		{
+			if (curr->to < nxt->to)
+			{
+				curr->to = nxt->to;	//merge next
+			}
+			m_lstContainer.erase(nxt);
+			nxt = curr;
+			++nxt;
+		}
+	}
+}
+
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::Merge(const CSegSetTmpl<SEGTYPE> &src)
+{
+	typename TSegs::iterator curr = m_lstContainer.begin();
+	typename TSegs::const_iterator scur = src.m_lstContainer.begin();
+	
+	while (curr!= m_lstContainer.end() && scur != src.m_lstContainer.end())
+	{
+		if (curr->to < scur->from - 1) ++curr;
+		else if (scur->to < curr->from - 1)
+		{
+			m_lstContainer.insert(curr, *scur);
+			++scur;
+		}
+		else
+		{
+			// -- merge this src seg
+			if (curr->from > scur->from)
+			{
+				curr->ori_from -= (curr->from - scur->from) / m_iFactor;
+				curr->from = scur->from;
+			}
+			if (curr->to < scur->to)
+			{
+				curr->to = scur->to;
+			}
+			// -- to next src seg
+			++scur;
+			
+			// maintain this set			
+			typename TSegs::iterator nxt = curr;
+			++nxt;
+			while (nxt != m_lstContainer.end() && nxt->from <= curr->to + 1)
+			{
+				if (curr->to < nxt->to)
+				{
+					curr->to = nxt->to;	//merge next
+				}
+				m_lstContainer.erase(nxt);
+				nxt = curr;
+				++nxt;
+			}
+		}
+	}
+	// -- add the rest segs in
+	
+	while (scur != src.m_lstContainer.end())
+		m_lstContainer.push_back(*scur++);
+}
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::Cross(const CSegSetTmpl<SEGTYPE> & src)
+{
+	typename TSegs::iterator curr = m_lstContainer.begin();
+	typename TSegs::const_iterator scur = src.m_lstContainer.begin();
+	
+	while (curr!= m_lstContainer.end() && scur != src.m_lstContainer.end())
+	{
+		if (curr->to < scur->from)
+		{
+			typename TSegs::iterator del = curr;
+			++curr;
+			m_lstContainer.erase(del);
+		} 
+		else if (scur->to < curr->from)
+		{
+			++scur;
+		}
+		else
+		{
+			if (curr->from < scur->from)
+			{
+				curr->ori_from += (scur->from - curr->from) / m_iFactor;
+				curr->from = scur->from;
+			}
+			if (curr->to > scur->to + 1)
+			{
+				SEGTYPE temp(curr->from, scur->to);
+				temp.ori_from = curr->ori_from;
+				m_lstContainer.insert(curr, temp);
+				
+				curr->ori_from += (scur->to + 2 - curr->from) / m_iFactor;
+				curr->from = scur->to + 2;
+				++scur;
+			}
+			else
+			{
+				if (curr->to > scur->to)
+				{
+					curr->to = scur->to;
+					++scur;
+				}
+				++curr;
+			}
+		}
+	}
+	m_lstContainer.erase(curr, m_lstContainer.end());
+}
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::Clip(const CSegSetTmpl<SEGTYPE>& src)
+{
+	typename TSegs::iterator curr = m_lstContainer.begin();
+	typename TSegs::const_iterator scur = src.m_lstContainer.begin();
+	
+	while (curr!= m_lstContainer.end() && scur != src.m_lstContainer.end())
+	{
+		if (curr->to < scur->from)
+		{
+			++curr;
+		} 
+		else if (scur->to < curr->from)
+		{
+			++scur;
+		}
+		else
+		{
+			if (curr->from < scur->from)
+			{
+				SEGTYPE temp(curr->from, scur->from - 1);
+				temp.ori_from = curr->ori_from;
+				m_lstContainer.insert(curr, temp);
+			}
+			if (curr->to <= scur->to)
+			{
+				typename TSegs::iterator del = curr;
+				++curr;
+				m_lstContainer.erase(del);
+			}
+			else
+			{
+				curr->ori_from += (scur->to + 1 - curr->from) / m_iFactor;
+				curr->from = scur->to + 1;
+				++scur;
+			}
+		}
+	}
+}
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::Inv(SeqPos_t from, SeqPos_t to)	//inverse against a total range, discard original coordinates
+{
+	typename TSegs::iterator hdr = m_lstContainer.begin(), curr = hdr, dstEnd = m_lstContainer.end();
+	
+	while (curr != dstEnd && curr->to < from)
+		++curr;
+	m_lstContainer.erase(hdr, curr);
+	
+	SeqPos_t start = from;
+	while (curr != dstEnd && curr->from < to)
+	{
+		if (curr->from > start)	//insert new
+		{
+			SEGTYPE temp(start, curr->from - 1);
+			m_lstContainer.insert(curr, temp);
+		}
+		start = curr->to + 1;
+		typename TSegs::iterator del = curr;
+		++curr;
+		m_lstContainer.erase(del);
+	}
+	
+	// -- assert()
+	if (start <= to)
+		m_lstContainer.insert(curr, SEGTYPE(start, to));
+	// -- assert(curr->from > end);
+	m_lstContainer.erase(curr, dstEnd);
+}
+
+template <typename SEGTYPE>
+SeqPos_t CSegSetTmpl<SEGTYPE>::GetLeft(void) const
+{
+	return IsEmpty() ? -1 : m_lstContainer.begin()->from;
+}
+
+template <typename SEGTYPE>
+SeqPos_t CSegSetTmpl<SEGTYPE>::GetRight(void) const
+{
+	return IsEmpty() ? -1 : m_lstContainer.rbegin()->to;
+}
+
+
+template <typename SEGTYPE>
+SeqPos_t CSegSetTmpl<SEGTYPE>::GetTotalResidues(void) const
+{
+	SeqPos_t iResult = 0;
+	for (typename TSegs::const_iterator iter = m_lstContainer.begin(); iter != m_lstContainer.end(); ++iter)
+	{
+		iResult += iter->to - iter->from + 1;
+	}
+	return iResult/abs(m_iFactor);
+}
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::GetOverall(SEGTYPE &target, SeqPos_t &ori_to) const
+{
+	if (IsEmpty())
+	{
+		target.from = target.to = target.ori_from = -1;
+	}
+	else
+	{
+		typename TSegs::const_iterator iterFirst = m_lstContainer.begin();
+		typename TSegs::const_reverse_iterator iterLast = m_lstContainer.rbegin();
+		target.from = iterFirst->from;
+		target.ori_from = iterFirst->ori_from;
+		target.to = iterLast->to;
+		ori_to = iterLast->ori_from + (iterLast->to - iterLast->from) / m_iFactor;
+	}
+}
+
+template <typename SEGTYPE>
+SeqPos_t CSegSetTmpl<SEGTYPE>::GetOriTo(void) const
+{
+	if (m_lstContainer.empty()) return -1;
+	typename TSegs::const_reverse_iterator riter = m_lstContainer.rbegin();
+		
+	return riter->ori_from + (riter->to - riter->from) / m_iFactor;
+}
+
+template <typename SEGTYPE>
+SeqPos_t CSegSetTmpl<SEGTYPE>::GetOriTo(typename TSegs::const_iterator citer, SeqPos_t pos) const
+{
+	//return citer->ori_from + (citer->to - citer->from) / m_iFactor;
+	if (pos < 0) pos = citer->to;
+	return citer->ori_from + (pos - citer->from) / m_iFactor;
+}
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::GetGaps(CSegSetTmpl &dst) const
+{
+	dst.Clear();
+	
+	if (IsEmpty() || (-1 == m_ulGapThreshold)) return;
+	int fac = abs(m_iFactor);
+	SeqLen_t gapThreshold = fac * m_ulGapThreshold;
+	if (3 == fac && gapThreshold > 2) gapThreshold -= 2;
+	
+	typename TSegs::const_iterator iter = m_lstContainer.begin(), iter2 = iter, iterEnd = m_lstContainer.end();
+	
+	++iter2;
+	
+	while (iterEnd != iter2)
+	{
+		SeqPos_t f = iter->to + 1, t = iter2->from - 1;
+		if (t - f + 1 > (int)gapThreshold)	//consider as gap
+			dst.AddSeg(f, t);
+			
+		++iter;
+		++iter2;
+	}
+}
+
+template <typename SEGTYPE>
+void CSegSetTmpl<SEGTYPE>::GetTranslatedPosMap(size_t aaSeqLen, std::vector<TSeg_base::TResiduePos> &dst) const
+{
+	if (m_iFactor > 0)	//positive, nothing to worry about
+	{
+		for (typename TSegs::const_iterator iter = m_lstContainer.begin(), iterEnd = m_lstContainer.end(); iter != iterEnd; ++iter)
+		{
+			for (SeqPos_t c = iter->from, inc = 0; c <= iter->to; c += m_iFactor, ++inc)
+			{
+				dst.push_back(TSeg_base::TResiduePos(c / m_iFactor, iter->ori_from + inc));
+			}
+		}
+	}
+	else
+	{
+		for (typename TSegs::const_iterator iter = m_lstContainer.begin(), iterEnd = m_lstContainer.end(); iter != iterEnd; ++iter)
+		{
+			for (SeqPos_t c = iter->to, inc = 0; c > iter->from; c += m_iFactor, ++inc)
+			{
+				dst.push_back(TSeg_base::TResiduePos(aaSeqLen + c / m_iFactor, iter->ori_from + inc));
+			}
+		}
+	}
+}
+
+typedef CSegSetTmpl<TSeg_base> CSegSet;
+
+
+#endif
\ No newline at end of file
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ustring.cpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ustring.cpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ustring.cpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ustring.cpp	2018-03-13 14:39:35.323778000 -0400
@@ -0,0 +1,815 @@
+#include "ustring.hpp"
+//#include <wstring>
+#include <sstream>
+#include <cstring>
+#include <utility>
+
+using namespace std;
+
+//const USTRING k_ustrEmptyUSTRING;
+const USTRING & GetEmptyUSTRING(void)
+{
+	static const USTRING EmptyUSTRING;
+	return EmptyUSTRING;
+}
+
+inline
+UCHAR __ucase0(UCHAR uc)
+{
+
+	if (uc >= 0x61 && uc <= 0x7a) return uc - 0x20;
+	return uc;
+}
+
+inline void __ucase1(UCHAR &uc)
+{
+	if (uc >= 0x61 && uc <= 0x7a) uc -= 0x20;
+}
+
+
+bool ucitraits::eq(UCHAR uc1, UCHAR uc2)
+{
+	__ucase1(uc1);
+	__ucase1(uc2);
+	return uc1 == uc2;
+}
+
+bool ucitraits::lt(UCHAR uc1, UCHAR uc2)
+{
+	__ucase1(uc1);
+	__ucase1(uc2);
+	return uc1 < uc2;
+}
+
+int ucitraits::compare(const UCHAR* p, const UCHAR* q, size_t n)
+{
+	for (size_t i = 0; i < n; ++i)
+	{
+		if (ucitraits::lt(p[i], q[i]))
+			return -1;
+		if (ucitraits::eq(p[i], q[i]))
+			continue;
+		return 1;
+	}
+	return 0;
+}
+
+const UCHAR UTFBOM = 0xFEFF;
+
+const size_t UTF8BUFSIZE = 6;
+const size_t UTF16SIZE = 2;
+
+bool IsValidUTF8Start(unsigned char uc, size_t &numbytes)
+{
+
+	unsigned mask = 0x80;
+	if (0 == (uc & mask))
+	{
+		numbytes = 1;
+		return true;
+	}
+
+	mask >>= 1;
+	if (0 == (uc & mask))	//invalid! 
+		return false;
+	numbytes = 2;
+
+	mask >>= 1;
+	while (mask > 1 && (uc & mask) > 0)
+	{
+		++numbytes;
+		mask >>= 1;
+	}
+
+	if (1 == mask)
+		return false;
+
+	return true;
+}
+
+// -- return if successful. If not enough bytes in m_dimBuf, return false. If not start
+// -- with valid utf-8 sequence, throw TEncErr
+// -- if return true (success), numBytes contains number of bytes consumed. 
+// -- if return false (fail due to not enough bytes), numBytes contains number of more bytes needed
+// -- if noMoreBytes, rest bytes treated as is (non-encoded byte).
+bool DecodeFromUTF8(const BYTE *m_dimBuf, size_t ttlBytes, UCHAR &uc, size_t &numBytes, bool noMoreBytes)
+{
+	numBytes = 0;
+	if (ttlBytes > 0)
+	{
+		if (!IsValidUTF8Start(m_dimBuf[0], numBytes))
+		{
+
+			//if (!forceCont)
+			//{
+			//	char dimBuf[16];
+			//	sprintf(dimBuf, "0x%x", (unsigned int)(m_dimBuf[0]));
+			//	throw TEncErr(string("Invalid UTF8 start byte -- ") + dimBuf);
+			//}
+
+			// -- treat as non-necoded byte
+			//uc = m_dimBuf[0];
+			numBytes = 1;
+			//return true;
+		}
+
+		if (1 == numBytes)	//just one
+			uc = m_dimBuf[0];
+		else if (numBytes > ttlBytes)
+		{
+			if (!noMoreBytes)
+			{
+				numBytes -= ttlBytes;
+
+				return false;
+			}
+			// -- if no more bytes, treat rest bytes as unencoded
+			uc = m_dimBuf[0];
+			numBytes = 1;
+		}
+		// -- start decoding
+		else
+		{
+			unsigned char ucmask = 0xff >> (numBytes + 1);
+
+			uc = (m_dimBuf[0] & ucmask);
+
+			for (size_t idx = 1; idx < numBytes; ++idx)
+			{
+				uc = (uc << 6) + (m_dimBuf[idx] & 0x3f);
+
+			}
+		}
+		return true;
+	}
+	return false;
+}
+
+// -- if noPair == true, when two bytes for leading surrogate detected but not enough bytes for trailing surrogates, decode leading as normal
+// -- code point (illegal in UTF16 standard) instead of return false for more bytes.
+bool DecodeFromUTF16LE(const BYTE *m_dimBuf, size_t ttlBytes, UCHAR &uc, size_t &numBytes, bool noMoreBytes)
+{
+	numBytes = 0;
+	if (ttlBytes > 0)
+	{
+		numBytes = UTF16SIZE;
+		if (ttlBytes < numBytes)
+		{
+			if (!noMoreBytes)
+			{
+				numBytes -= ttlBytes;
+				return false;
+			}
+
+			// no more bytes, treat this as unencoded byte
+			uc = m_dimBuf[0];
+			numBytes = 1;
+		}
+		else	//we have at least two butes
+		{
+			uc = (((UCHAR)(m_dimBuf[1])) << 8) + m_dimBuf[0];
+
+			if (m_dimBuf[1] >= 0xD8 && m_dimBuf[1] < 0xDC)	//possible surrpair
+			{
+				numBytes += UTF16SIZE;
+
+				if (ttlBytes < numBytes)
+				{
+					if (!noMoreBytes)
+					{
+						numBytes -= ttlBytes;
+						return false;
+					}
+					// -- code this as 
+					numBytes -= UTF16SIZE;
+				}
+				else if (m_dimBuf[3] >= 0xDC && m_dimBuf[3] < 0xE0)	//surrpair)
+					uc = 0x10000 + ((uc - 0xD800) << 10) + (((UCHAR)m_dimBuf[3] << 8) + m_dimBuf[2] - 0xDC00);
+				else
+					numBytes -= UTF16SIZE;
+			}
+		}
+
+		return true;
+
+	}
+	return false;
+}
+
+bool DecodeFromUTF16BE(const BYTE *m_dimBuf, size_t ttlBytes, UCHAR &uc, size_t &numBytes, bool noMoreBytes)
+{
+	numBytes = 0;
+	if (ttlBytes > 0)
+	{
+		numBytes = UTF16SIZE;
+		if (ttlBytes < numBytes)	//only one byte -- has to return false
+		{
+			if (!noMoreBytes)
+			{
+				numBytes -= ttlBytes;
+				return false;
+			}
+			// no more bytes, treat this as unencoded byte
+			uc = m_dimBuf[0];
+			numBytes = 1;
+		}
+		else
+		{
+			// -- at least two bytes
+			uc = (((UCHAR)(m_dimBuf[0])) << 8) + m_dimBuf[1];
+
+			if (m_dimBuf[0] >= 0xD8 && m_dimBuf[0] < 0xDC)	//possible surrpair
+			{
+				numBytes += UTF16SIZE;
+				if (ttlBytes < numBytes)	//not enough for a second pair
+				{
+					if (!noMoreBytes)	//return false for trailing surrogate
+					{
+						numBytes -= ttlBytes;
+						return false;
+					}
+					// -- no more bytes, just treat it as normal cp
+					numBytes -= UTF16SIZE;
+				}
+				else if (m_dimBuf[2] >= 0xDC && m_dimBuf[2] < 0xE0)	//surrpair)
+					uc = 0x10000 + ((uc - 0xD800) << 10) + (((UCHAR)m_dimBuf[2] << 8) + m_dimBuf[3] - 0xDC00);
+				else	//not surrogate pair, already calculated uc
+					numBytes -= UTF16SIZE;
+			}
+		}
+		return true;
+	}
+	return false;
+}
+
+
+int DetectEncoding(const char *src, size_t ttlchars, size_t &bomEnd)
+//int DetectEncoding(const string &str, size_t &bomEnd)
+{
+	// -- UTF-8 BOM: 
+	size_t idx = 0;
+	bomEnd = 0;	//assume no BOM
+	if (idx < ttlchars)
+	{
+		unsigned char uc = (unsigned char)src[idx];
+		switch (uc)
+		{
+		case 0xff:	//possible UTF16LE
+			++idx;
+			if (idx < ttlchars)
+			{
+				uc = (unsigned char)src[idx];
+				if (0xfe == uc)	//BOM Found for E_UTF16LE
+				{
+					bomEnd = ++idx;
+					return E_UTF16LE;
+				}
+			}
+
+			break;
+		case 0xfe:	//possible UTF16BE
+			++idx;
+			if (idx < ttlchars)
+			{
+				uc = (unsigned char)src[idx];
+				if (0xff == uc)	//BOM Found for E_UTF16BE
+				{
+
+					bomEnd = ++idx;
+					return E_UTF16BE;
+				}
+			}
+
+			break;
+
+		case 0xef:	//UTF8-sig
+			++idx;
+			if (idx < ttlchars)
+			{
+				uc = (unsigned char)src[idx];
+				if (0xbb == uc)	//BOM Found for E_UTF8
+				{
+					++idx;
+					if (idx < ttlchars)
+					{
+						uc = (unsigned char)src[idx];
+						if (0xbf == uc)	//UTF8 mark found
+						{
+							bomEnd = ++idx;
+							return E_UTF8;
+						}
+					}
+
+				}
+			}
+
+			break;
+		}	//switch looking for signatures
+
+		// -- no signature found. 
+		idx = 0;
+		bomEnd = 0;
+		size_t odd_nulls = 0, even_nulls = 0, odd_sps = 0, even_sps = 0, utf8seqsz = 0;
+
+		// -- check if are UTF8 valid
+		bool bUTF8Valid = true;
+
+		size_t spLeadAt = string::npos;
+
+		while (idx < ttlchars)
+		{
+			uc = (unsigned char)src[idx];
+			if (0 == uc)
+			{
+				++((idx & 0x1) ? odd_nulls : even_nulls);
+			}
+
+			// -- if still in valid UTF-8 sequence
+			if (bUTF8Valid)
+			{
+				if (0 == utf8seqsz)	//should start a new sequence
+				{
+					if ((bUTF8Valid = IsValidUTF8Start(uc, utf8seqsz)))
+						--utf8seqsz;
+				}
+				else if ((0xc0 & uc) == 0x80)
+					--utf8seqsz;
+				else
+					bUTF8Valid = false;
+			}
+
+			if (string::npos == spLeadAt && uc >= 0xD8 && uc < 0xDC)
+			{
+				spLeadAt = idx;
+
+			}
+			else if (uc >= 0xDC && uc < 0xE0)
+			{
+				if (idx == spLeadAt + 2)
+					++((spLeadAt & 0x1) ? odd_sps : even_sps);
+				spLeadAt = string::npos;
+			}
+
+
+			++idx;
+		}
+
+		// -- now check for flags
+		if (bUTF8Valid)
+			return E_UTF8;
+
+		// -- now borrow bUTF8Valid as flag of big (true) or little (false) endian
+		if (even_nulls > odd_nulls)
+		{
+			if (even_sps > odd_sps || (even_nulls - odd_nulls > odd_sps - even_sps))
+				return E_UTF16BE;	//high confidence
+
+			return E_UTF16LE;
+		}
+		else if (even_nulls < odd_nulls)
+		{
+			if (even_sps < odd_sps || (odd_nulls - even_nulls > even_sps - odd_sps))
+				return E_UTF16LE;	//high confidence
+
+			return E_UTF16BE;
+		}
+		else if (even_sps > odd_sps)
+			return E_UTF16BE;
+
+		return E_UTF16BE;
+	}
+	return E_UNKNOWN;
+}
+
+
+
+
+// -- must guarantee enough space for *m_dimBuf. 
+// -- return number of bytes generated
+size_t EncodeToUTF8(UCHAR uc, BYTE *m_dimBuf)
+{
+	unsigned char mask = 0xff, hdr = 0xfe;
+	size_t numbytes = 0;
+	if (uc < 0x80L)
+	{
+		m_dimBuf[0] = (unsigned char)(uc & 0x7f);
+		return 1;
+	}
+	else if (uc < 0x800L)
+	{
+		numbytes = 2;
+	}
+	else if (uc < 0x10000L)
+	{
+		numbytes = 3;
+	}
+	else if (uc < 0x200000L)
+	{
+		numbytes = 4;
+	}
+	else if (uc < 0x4000000L)
+	{
+		numbytes = 5;
+	}
+	else
+	{
+		numbytes = 6;
+	}
+
+	for (size_t i = numbytes; i > 1; --i)
+	{
+		m_dimBuf[i - 1] = 0x80 | (uc & 0x3f);
+		uc >>= 6;
+	}
+
+	m_dimBuf[0] = (uc & (mask >> (numbytes + 1))) | (hdr << (7 - numbytes));
+
+	return numbytes;
+}
+
+
+size_t EncodeToUTF16LE(UCHAR uc, BYTE *m_dimBuf)
+{
+	size_t numbytes = UTF16SIZE;
+	if (uc >= 0x10FFFF)	//max for UTF16, just treat as 0x10FFFF
+	{
+		m_dimBuf[1] = 0xDB;
+		m_dimBuf[0] = 0xFF;
+		m_dimBuf[3] = 0xDF;
+		m_dimBuf[2] = 0xFF;
+		numbytes = UTF16SIZE + UTF16SIZE;
+	}
+	else if (uc > 0xFFFF)	//use surrogte-pair
+	{
+		uc -= 0x10000;
+		UINT16 tailing = 0xDC00 + (uc & 0x3FF);
+		uc = (uc >> 10) + 0xD800;
+		m_dimBuf[1] = uc >> 8;
+		m_dimBuf[0] = uc & 0xFF;
+		m_dimBuf[3] = tailing >> 8;
+		m_dimBuf[2] = tailing & 0xFF;
+		numbytes = UTF16SIZE + UTF16SIZE;
+	}
+	else // -- no surrogte-pair
+	{
+		m_dimBuf[1] = uc >> 8;
+		m_dimBuf[0] = uc & 0xFF;
+	}
+
+	return numbytes;
+}
+
+size_t EncodeToUTF16BE(UCHAR uc, BYTE *m_dimBuf)
+{
+	size_t numbytes = UTF16SIZE;
+	if (uc >= 0x10FFFF)	//max for UTF16, just treat as 0x10FFFF
+	{
+		m_dimBuf[0] = 0xDB;
+		m_dimBuf[1] = 0xFF;
+		m_dimBuf[2] = 0xDF;
+		m_dimBuf[3] = 0xFF;
+		numbytes = UTF16SIZE + UTF16SIZE;
+	}
+	else if (uc > 0xFFFF)	//use surrogte-pair
+	{
+		uc -= 0x10000;
+		UINT16 tailing = 0xDC00 + (uc & 0x3FF);
+		uc = (uc >> 10) + 0xD800;
+		m_dimBuf[0] = uc >> 8;
+		m_dimBuf[1] = uc & 0xFF;
+		m_dimBuf[2] = tailing >> 8;
+		m_dimBuf[3] = tailing & 0xFF;
+		numbytes = UTF16SIZE + UTF16SIZE;
+	}
+	else // -- no surrogte-pair
+	{
+		m_dimBuf[0] = uc >> 8;
+		m_dimBuf[1] = uc & 0xFF;
+	}
+	return numbytes;
+}
+
+
+
+string EncodeUBytesToUTF8(const UCHAR *pSrc, size_t ttlUChars)
+{
+	BYTE buf[UTF8BUFSIZE];
+	string dst;
+	for (size_t i = 0; i < ttlUChars; ++i)
+		dst.append(reinterpret_cast<const char*> (buf), EncodeToUTF8(pSrc[i], buf));
+	return dst;
+}
+
+CUTFIstream::CUTFIstream(istream &bytes_in) :
+m_pBytesInStream(&bytes_in), m_iDetectedEncoding(E_UTF8), m_lpfnDecode(&DecodeFromUTF8), m_ulBytesFromStream(0), m_ulBufIdx(0), m_ulTotalBytes(0)
+{
+	if (!m_pBytesInStream->good())
+		throw TEncErr(eUnableToReadIstream, m_pBytesInStream->rdstate(), 0, "Initial reading of input stream error, stream not in goodbit");
+	m_ulTotalBytes = m_pBytesInStream->read(reinterpret_cast< char* > (m_dimBuf), BUFSIZE).gcount();
+	if (0 == m_ulTotalBytes)
+		throw TEncErr(eUnableToReadIstream, m_pBytesInStream->rdstate(), 0, "Reading operation returned 0 bytes");
+
+	size_t bomEnd = 0;
+	m_iDetectedEncoding = DetectEncoding(reinterpret_cast< const char* > (m_dimBuf), m_ulTotalBytes, bomEnd);
+	switch (m_iDetectedEncoding)
+	{
+	case E_UTF8:
+		break;	//nothing needs to be done
+	case E_UTF16LE:
+		m_lpfnDecode = &DecodeFromUTF16LE;
+		break;
+	case E_UTF16BE:
+		m_lpfnDecode = &DecodeFromUTF16BE;
+		break;
+	default:
+		{
+			m_pBytesInStream->seekg(0, m_pBytesInStream->beg);
+			throw TEncErr(eUnrecognizedEncoding, 0, 0, "Unable to determine stream encoding");
+		}
+	}
+	m_pBytesInStream->clear();
+	m_pBytesInStream->seekg(bomEnd, m_pBytesInStream->beg);
+	m_ulTotalBytes = 0;
+	//m_ulBufIdx = 0;
+	m_ulBytesFromStream += bomEnd;
+}
+
+
+bool CUTFIstream::ReadUC(UCHAR &uc)
+{
+	size_t bytes_consumed = 0;
+	bool no_more_bytes = m_pBytesInStream->eof();
+	bool gotit = m_lpfnDecode(m_dimBuf + m_ulBufIdx, m_ulTotalBytes - m_ulBufIdx, uc, bytes_consumed, no_more_bytes);
+	if (!gotit && !no_more_bytes)
+	{
+		no_more_bytes = fill_buf();
+		gotit = m_lpfnDecode(m_dimBuf + m_ulBufIdx, m_ulTotalBytes - m_ulBufIdx, uc, bytes_consumed, no_more_bytes);
+	}
+
+	if (gotit)
+		m_ulBufIdx += bytes_consumed;
+	return gotit;
+}
+
+
+
+
+streamsize CUTFIstream::GetCurrIstreamPos(void) const
+{
+	return m_ulBytesFromStream + m_ulBufIdx - m_ulTotalBytes;
+}
+
+streamsize CUTFIstream::ret_buff(void)
+{
+	streamsize pos = GetCurrIstreamPos();
+
+	if (pos < m_ulBytesFromStream)
+	{
+		m_pBytesInStream->clear();
+		m_pBytesInStream->seekg(pos, m_pBytesInStream->beg);
+	}
+		
+
+	m_ulTotalBytes = m_ulBufIdx = 0;	//reset buffer
+	return pos;
+}
+
+bool CUTFIstream::fill_buf(void)
+{
+	size_t leftover = m_ulTotalBytes - m_ulBufIdx;
+	if (leftover > 0 && m_ulBufIdx > 0)
+		memcpy(m_dimBuf, m_dimBuf + m_ulBufIdx, leftover * sizeof(BYTE));
+	m_ulBufIdx = 0;
+	m_ulTotalBytes = leftover;
+
+	bool no_more_bytes = m_pBytesInStream->eof();
+	if (leftover < BUFSIZE && !no_more_bytes)
+	{
+		size_t bytes_read = m_pBytesInStream->read(reinterpret_cast< char* > (m_dimBuf + leftover), (BUFSIZE - leftover) * sizeof(BYTE)).gcount();
+		m_ulTotalBytes += bytes_read;
+		no_more_bytes = m_pBytesInStream->eof();
+		m_ulBytesFromStream += bytes_read;
+	}
+
+	return no_more_bytes;
+}
+
+bool CUTFIstream::eof(void) const
+{
+	return (m_pBytesInStream->eof() && m_ulBufIdx >= m_ulTotalBytes);
+}
+
+bool CUTFIstream::good(void) const
+{
+	return (m_pBytesInStream->good() || m_ulBufIdx < m_ulTotalBytes);
+}
+
+
+CUTFIstream::~CUTFIstream(void)
+{
+	ret_buff();
+}
+
+
+CUTFOstream::CUTFOstream(ostream & os, int enc, const TEscapeSeqs *pesc) :
+m_pBytesOutStream(&os), m_iEncoding(enc), m_pEscSeqs(pesc), m_lpfnEncode(&EncodeToUTF8), m_ulSentinelBufSize(UTF8BUFSIZE), m_pWriteUCFunc(&CUTFOstream::write_uc), m_pWriteUStrFunc(&CUTFOstream::write_ustr), m_ulBufIdx(0)
+{
+	switch (enc)
+	{
+	case E_UTF16LE:
+		m_iEncoding = enc;
+		m_lpfnEncode = &EncodeToUTF16LE;
+		m_ulSentinelBufSize = UTF16SIZE + UTF16SIZE;	//for surrogate pairs
+		break;
+	case E_UTF16BE:
+		m_iEncoding = enc;
+		m_lpfnEncode = &EncodeToUTF16BE;
+		m_ulSentinelBufSize = UTF16SIZE + UTF16SIZE;	//for surrogate pairs
+		break;
+	default:;
+	}
+
+	if (nullptr != m_pEscSeqs)
+	{
+		m_pWriteUCFunc = &CUTFOstream::write_uc_esc;
+		m_pWriteUStrFunc = &CUTFOstream::write_ustr_esc;
+	}
+}
+
+void CUTFOstream::PrintBOM(void)
+{
+	write_uc(UTFBOM);
+}
+
+bool CUTFOstream::write(const UCHAR *src, std::streamsize n)
+{
+	return (this->*m_pWriteUStrFunc)(src, n);
+}
+
+bool CUTFOstream::write_uc(UCHAR uc)
+{
+	bool success = true;
+	m_ulBufIdx += m_lpfnEncode(uc, m_dimBuf + m_ulBufIdx);
+	try
+	{
+		m_pBytesOutStream->write(reinterpret_cast< const char* >(m_dimBuf), m_ulBufIdx);
+		success = m_pBytesOutStream->good();
+	}
+	catch (...)
+	{
+		success = false;
+	}
+
+	m_ulBufIdx = 0;
+
+	return success;
+}
+
+bool CUTFOstream::write_ustr(const UCHAR *src, streamsize n)
+{
+	bool isgood = m_pBytesOutStream->good();
+	streamsize idx = 0;
+
+	// -- no escape sequence
+	while (idx < n && isgood)
+	{
+		m_ulBufIdx += m_lpfnEncode(src[idx], m_dimBuf + m_ulBufIdx);
+
+		if (m_ulBufIdx + m_ulSentinelBufSize > BUFSIZE)
+		{
+			// -- write to stream
+			try
+			{
+				m_pBytesOutStream->write(reinterpret_cast< const char* > (m_dimBuf), m_ulBufIdx);
+			}
+			catch (...)
+			{
+				;
+			}
+
+			m_ulBufIdx = 0;
+			isgood = m_pBytesOutStream->good();
+
+		}
+
+		++idx;
+	}
+	// -- last batch
+	if (m_ulBufIdx > 0 && isgood)
+	{
+		try
+		{
+			m_pBytesOutStream->write(reinterpret_cast< const char* > (m_dimBuf), m_ulBufIdx);
+		}
+		catch (...)
+		{
+			;
+		}
+		isgood = m_pBytesOutStream->good();
+		m_ulBufIdx = 0;
+	}
+	return isgood;
+}
+
+
+// -- assume m_pEscSeqs is not nullptr
+bool CUTFOstream::write_uc_esc(UCHAR uc)
+{
+
+	TEscapeSeqs::const_iterator iterEsc = m_pEscSeqs->find(uc);
+
+	if (m_pEscSeqs->end() != iterEsc)
+		return write_ustr(&(*iterEsc->second.begin()), iterEsc->second.size());
+
+	return write_uc(uc);
+}
+
+bool CUTFOstream::write_ustr_esc(const UCHAR *ustr, streamsize n)
+{
+	TEscapeSeqs::const_iterator iterEsc = m_pEscSeqs->end(), iterEscEnd = iterEsc;
+	streamsize idx = 0;
+	bool isgood = m_pBytesOutStream->good();
+
+	size_t escIdx = 0, escEnd = 0;
+	while (idx < n && isgood)
+	{
+		if (escEnd > 0)	//dealing with escape sequence
+		{
+			if (escIdx == escEnd)
+			{
+				++idx;
+				escIdx = escEnd = 0;
+				continue;
+			}
+			else	//assume escIdx < escEnd
+			{
+				m_ulBufIdx += m_lpfnEncode(iterEsc->second[escIdx], m_dimBuf + m_ulBufIdx);
+				++escIdx;
+			}
+		}
+		else	//0 == escEnd, normal text
+		{
+			UCHAR uc = ustr[idx];
+
+			iterEsc = m_pEscSeqs->find(uc);
+			if (iterEscEnd != iterEsc)
+			{
+				if (iterEsc->second.empty())	//escaped away
+				{
+					++idx;
+					continue;
+				}
+				escIdx = 0;
+				escEnd = iterEsc->second.size();
+				continue;
+			}
+			else	// -- no escape, normal write
+			{
+				m_ulBufIdx += m_lpfnEncode(uc, m_dimBuf + m_ulBufIdx);
+				++idx;
+			}
+		}
+
+		if (m_ulBufIdx + m_ulSentinelBufSize > BUFSIZE)
+		{
+			// -- write to stream
+			try
+			{
+				m_pBytesOutStream->write(reinterpret_cast< const char* > (m_dimBuf), m_ulBufIdx);
+			}
+			catch (...)
+			{
+				;
+			}
+
+			isgood = m_pBytesOutStream->good();
+			m_ulBufIdx = 0;
+		}
+	}
+
+	// -- last batch
+	if (m_ulBufIdx > 0 && isgood)
+	{
+		// -- write to stream
+		try
+		{
+			m_pBytesOutStream->write(reinterpret_cast< const char* > (m_dimBuf), m_ulBufIdx);
+		}
+		catch (...)
+		{
+			;
+		}
+
+		isgood = m_pBytesOutStream->good();
+		m_ulBufIdx = 0;
+	}
+
+	return isgood;
+
+}
+
+CUTFOstream & operator << (CUTFOstream & enc_stream, UCHAR uc)
+{
+	(enc_stream.*(enc_stream.m_pWriteUCFunc))(uc);
+	return enc_stream;
+}
diff -Naur ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ustring.hpp ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ustring.hpp
--- ncbi-blast-2.7.1+-src/c++/src/app/sparclelabel/ustring.hpp	1969-12-31 19:00:00.000000000 -0500
+++ ncbi-blast-2.7.1+-src-working/c++/src/app/sparclelabel/ustring.hpp	2018-03-13 14:39:35.330649000 -0400
@@ -0,0 +1,384 @@
+#if !defined(__USTRING__)
+#define __USTRING__
+
+//#include "basicutils.hpp"
+#include "normbase.hpp"
+#include <iostream>
+#include <vector>
+#include <map>
+#include <string>
+#include <cstring>
+#include <exception>
+
+typedef UINT32 UCHAR;
+
+constexpr const UCHAR UC_NULL = 0;
+constexpr const UCHAR UC_NL = 0xaL;
+constexpr const UCHAR UC_CR = 0xdL;
+constexpr const UCHAR UC_QUOT = '"';
+constexpr const UCHAR UC_APOS = '\'';
+constexpr const UCHAR UC_WHITESP = ' ';
+constexpr const UCHAR UC_COLON = ':';
+constexpr const UCHAR UC_SEMICOLON = ';';
+constexpr const UCHAR UC_EQUAL = '=';
+constexpr const UCHAR UC_AMPS = '&';
+constexpr const UCHAR UC_TAB = '\t';
+constexpr const UCHAR UC_ESCAPE = '\\';
+constexpr const UCHAR UC_A = 'A';
+constexpr const UCHAR UC_F = 'F';
+constexpr const UCHAR UC_Z = 'Z';
+constexpr const UCHAR UC_a = 'a';
+constexpr const UCHAR UC_f = 'f';
+constexpr const UCHAR UC_z = 'z';
+constexpr const UCHAR UC_0 = '0';
+constexpr const UCHAR UC_8 = '8';
+constexpr const UCHAR UC_9 = '9';
+
+typedef std::char_traits<UCHAR> uctraits;
+
+struct ucitraits : public uctraits
+{
+	static bool eq(UCHAR uc1, UCHAR uc2);
+	static bool lt(UCHAR uc1, UCHAR uc2);
+	static int compare(const UCHAR* p, const UCHAR* q, size_t n);
+};
+
+
+static const int E_UNKNOWN = 0;
+static const int E_UTF8 = 8;
+static const int E_UTF16BE = 16;
+static const int E_UTF16LE = -16;
+static const int E_UTF16 = E_UTF16LE;
+
+
+enum EEncodingError
+{
+	eUnrecognizedEncoding,
+	eInvalidChar,
+	eUnableToReadIstream,
+	eUnableToWriteOstream
+};
+
+struct TEncErr : public std::exception
+{
+	EEncodingError ecode;
+	int int_param;
+	unsigned int uint_param;
+	std::string msg;
+	virtual const char * what(void) const throw() { return msg.c_str(); }
+	TEncErr(EEncodingError e, int i_p, unsigned int ui_p, const std::string &m) : std::exception(), ecode(e), int_param(i_p), uint_param(ui_p), msg(m) {};
+	virtual ~TEncErr(void) throw() {};
+};
+
+
+
+//typedef std::basic_string < UCHAR, ucitraits, std::allocator<UCHAR> > IUSTRING_base;
+bool DecodeFromUTF8(const BYTE *m_dimBuf, size_t ttlBytes, UCHAR &uc, size_t &numBytes, bool noMoreBytes);
+//size_t EncodeToUTF8(UCHAR uc, BYTE *m_dimBuf);
+std::string EncodeUBytesToUTF8(const UCHAR *pSrc, size_t ttlUChars);
+
+template <typename TCHARTRAITS>
+class CUSTRING : public std::basic_string<UCHAR, TCHARTRAITS, std::allocator<UCHAR> >
+{
+public:
+	typedef std::basic_string<UCHAR, TCHARTRAITS, std::allocator<UCHAR> > USTRING_base;
+	static const CUSTRING k_EmptyUSTRING;
+	CUSTRING(void) : USTRING_base() {};
+	CUSTRING(const UCHAR *chars, size_t n) :
+		USTRING_base(chars, n) {};
+	CUSTRING(const CUSTRING &src) :
+		USTRING_base((const USTRING_base &)src) {};
+	CUSTRING(CUSTRING &&src) :
+		USTRING_base(std::move((USTRING_base &&)src)) {};
+	CUSTRING(const USTRING_base &base) : USTRING_base(base) {};
+	CUSTRING(USTRING_base &&base) : USTRING_base(std::move(base)) {};
+
+	CUSTRING & operator = (const CUSTRING &src);
+	CUSTRING & operator = (CUSTRING &&src);
+	CUSTRING & operator = (const USTRING_base &base);
+	CUSTRING & operator = (USTRING_base &&base);
+
+
+	CUSTRING(const std::string &utf8);
+	CUSTRING & operator = (const std::string &utf8);
+
+	//CUSTRING(std::string &utf8);
+	//CUSTRING & operator = (std::string &utf8);
+
+
+	CUSTRING(const char *utf8);
+	CUSTRING & operator = (const char *utf8);
+
+	operator std::string(void) const;
+
+private:
+	void x_ParseCharArray(const BYTE * pData, size_t ttlBytes);
+
+};
+
+template <typename TCHARTRAITS>
+const CUSTRING<TCHARTRAITS> CUSTRING<TCHARTRAITS>::k_EmptyUSTRING;
+
+template <typename TCHARTRAITS>
+CUSTRING<TCHARTRAITS> & CUSTRING<TCHARTRAITS>::operator = (const CUSTRING &src)
+{
+	USTRING_base::operator = ((const USTRING_base&)src);
+	return *this;
+}
+
+template <typename TCHARTRAITS>
+CUSTRING<TCHARTRAITS> & CUSTRING<TCHARTRAITS>::operator = (CUSTRING &&src)
+{
+	USTRING_base::operator = (std::move((USTRING_base &&)src));
+	return *this;
+}
+
+template <typename TCHARTRAITS>
+CUSTRING<TCHARTRAITS> & CUSTRING<TCHARTRAITS>::operator = (const USTRING_base &base)
+{
+	USTRING_base::operator = (base);
+	return *this;
+}
+
+template <typename TCHARTRAITS>
+CUSTRING<TCHARTRAITS> & CUSTRING<TCHARTRAITS>::operator = (USTRING_base &&base)
+{
+	USTRING_base::operator = (std::move(base));
+	return *this;
+}
+
+template <typename TCHARTRAITS>
+void CUSTRING<TCHARTRAITS>::x_ParseCharArray(const BYTE * pData, size_t ttlBytes)
+{
+	if (ttlBytes > 0)
+	{
+		UCHAR uc = 0;
+		size_t bytesDone = 0, bytes_consumed = 0;
+		while (DecodeFromUTF8(pData + bytesDone, ttlBytes - bytesDone, uc, bytes_consumed, true))
+		{
+			USTRING_base::push_back(uc);
+			bytesDone += bytes_consumed;
+		}
+	}
+}
+
+template <typename TCHARTRAITS>
+CUSTRING<TCHARTRAITS>::CUSTRING(const std::string &utf8) : USTRING_base()
+{
+	size_t ttlBytes = utf8.size();
+	if (ttlBytes > 0)
+		x_ParseCharArray(reinterpret_cast<const BYTE* > (utf8.data()), ttlBytes);
+
+}
+
+template <typename TCHARTRAITS>
+CUSTRING<TCHARTRAITS>::CUSTRING(const char *utf8) : USTRING_base()
+{
+	if (nullptr != utf8)
+	{
+		size_t ttlBytes = strlen(utf8);
+		if (ttlBytes > 0)
+			x_ParseCharArray(reinterpret_cast<const BYTE* > (utf8), ttlBytes);
+	}
+}
+
+
+template <typename TCHARTRAITS>
+CUSTRING<TCHARTRAITS> & CUSTRING<TCHARTRAITS>::operator = (const std::string &utf8)
+{
+	USTRING_base::clear();
+	size_t ttlBytes = utf8.size();
+	if (ttlBytes > 0)
+		x_ParseCharArray(reinterpret_cast<const BYTE* > (utf8.data()), ttlBytes);
+	return *this;
+}
+
+
+template <typename TCHARTRAITS>
+CUSTRING<TCHARTRAITS> & CUSTRING<TCHARTRAITS>::operator = (const char *utf8)
+{
+	USTRING_base::clear();
+	if (nullptr != utf8)
+	{
+		size_t ttlBytes = strlen(utf8);
+		if (ttlBytes > 0)
+			x_ParseCharArray(reinterpret_cast<const BYTE* > (utf8), ttlBytes);
+	}
+	return *this;
+}
+
+template <typename TCHARTRAITS>
+CUSTRING<TCHARTRAITS>::operator std::string(void) const
+{
+	return EncodeUBytesToUTF8(USTRING_base::data(), USTRING_base::size());
+}
+
+typedef CUSTRING<uctraits> USTRING;
+typedef CUSTRING<ucitraits> IUSTRING;
+
+const USTRING & GetEmptyUSTRING(void);
+#define k_ustrEmptyUSTRING GetEmptyUSTRING()
+
+typedef bool(*UCDecodeFunc)(const BYTE*, size_t, UCHAR&, size_t&, bool);
+// -- this class automatically detect utf-8 and utf16 (in either little or big endian)
+// -- does not support utf-32. 
+class CUTFIstream
+{
+	template<typename TUSTRING>
+	friend CUTFIstream & operator >> (CUTFIstream & dec_stream, TUSTRING &ustr);
+	//friend CUTFIstream & operator >> (CUTFIstream & dec_stream, UCHAR &uc);
+public:
+	CUTFIstream(std::istream & bytes_in);
+	~CUTFIstream(void);
+
+	// -- try to read n UCHARs and append to ustr, return actual read.
+	bool ReadUC(UCHAR &uc);
+	
+	template<typename TUSTRING>
+	std::streamsize read(typename TUSTRING::USTRING_base &ustr, std::streamsize n);
+	// -- return true if eof reached. otherwise return false
+
+	template<typename TUSTRING>
+	size_t getline(typename TUSTRING::USTRING_base &ustr, UCHAR delim = UC_NL);
+
+
+	int GetEncoding(void) const { return m_iDetectedEncoding; }
+	// -- simple status query
+	bool eof(void) const;
+	bool good(void) const;
+	std::ios::iostate rdstate(void) const { return m_pBytesInStream->rdstate(); }
+	std::streamsize GetCurrIstreamPos(void) const;
+
+private:
+	static const std::streamsize BUFSIZE = 4096;
+		
+	// -- critical resource.
+	std::streamsize ret_buff(void);
+	// -- read from stream to fill buffer. return true if all bytes are read from stream. Otherwise return false (actual read bytes are less than desired.
+	bool fill_buf(void);	//
+
+	std::istream *m_pBytesInStream;
+	int m_iDetectedEncoding;
+	UCDecodeFunc m_lpfnDecode;
+	// -- record total bytes read from istream
+	std::streamsize m_ulBytesFromStream;
+	// -- buffer
+	size_t m_ulBufIdx;
+	size_t m_ulTotalBytes;	//in buffer
+	BYTE m_dimBuf[BUFSIZE];
+};
+
+template<typename TUSTRING>
+std::streamsize CUTFIstream::read(typename TUSTRING::USTRING_base &ustr, std::streamsize n)
+{
+	std::streamsize idx = 0;
+	UCHAR uc = 0;
+	while (idx < n)
+	{
+		if (!ReadUC(uc))
+			break;
+		ustr.push_back(uc);
+		++idx;
+	}
+	return idx;
+}
+
+template<typename TUSTRING>
+size_t CUTFIstream::getline(typename TUSTRING::USTRING_base &ustr, UCHAR delim)
+{
+	std::streamsize idx = 0;
+	UCHAR uc = 0, last = 0;
+
+	if (!ReadUC(uc))
+		return idx;
+	while (uc != delim)
+	{
+		ustr.push_back(uc);
+		++idx;
+		last = uc;
+
+		if (!ReadUC(uc))
+			break;
+	}
+
+	if (UC_NL == uc && UC_CR == last)
+	{
+		ustr.pop_back();
+		--idx;
+	}
+
+	return idx;
+}
+
+
+template<typename TUSTRING>
+CUTFIstream & operator >> (CUTFIstream & dec_stream, TUSTRING &ustr)
+{
+	UCHAR uc = 0;
+	while (dec_stream.ReadUC(uc))
+		ustr.push_back(uc);
+
+	return dec_stream;
+}
+
+
+
+
+//-- Encoding facilities
+// -- for escape sequences
+typedef std::map<UCHAR, std::vector<UCHAR> > TEscapeSeqs;
+typedef size_t(*UCEncodeFunc)(UCHAR, BYTE*);
+class CUTFOstream
+{
+	friend CUTFOstream & operator << (CUTFOstream & enc_stream, UCHAR uc);
+
+	template <typename TUSTRING>
+	friend CUTFOstream & operator << (CUTFOstream & enc_stream, const TUSTRING &ustr);
+public:
+	typedef bool (CUTFOstream::*write_uc_func)(UCHAR);	//with or without escape check
+	typedef bool (CUTFOstream::*write_ustr_func)(const UCHAR *ustr, std::streamsize n);
+	CUTFOstream(std::ostream & os, int enc = E_UTF8, const TEscapeSeqs *pesc = nullptr);
+	void PrintBOM(void);
+
+	bool write(const UCHAR *src, std::streamsize n);
+
+
+private:
+
+	static const std::streamsize BUFSIZE = 4096;
+
+	std::ostream *m_pBytesOutStream;
+	int m_iEncoding;
+	const TEscapeSeqs *m_pEscSeqs;
+
+	UCEncodeFunc m_lpfnEncode;
+	size_t m_ulSentinelBufSize;
+
+	
+
+	write_uc_func m_pWriteUCFunc;
+	write_ustr_func m_pWriteUStrFunc;
+	// -- buffer
+	size_t m_ulBufIdx;
+	BYTE m_dimBuf[BUFSIZE];
+
+	bool write_uc(UCHAR uc);
+	bool write_uc_esc(UCHAR uc);
+
+	bool write_ustr(const UCHAR *ustr, std::streamsize n);
+	bool write_ustr_esc(const UCHAR *ustr, std::streamsize n);
+};
+
+CUTFOstream & operator << (CUTFOstream & enc_stream, UCHAR uc);
+
+
+template <typename TUSTRING>
+CUTFOstream & operator << (CUTFOstream & enc_stream, const TUSTRING &ustr)
+{
+	enc_stream.write(ustr.data(), ustr.size());
+	return enc_stream;
+}
+
+
+
+#endif
